# More about collections

<div style="text-align: right">
<a target="_blank" href="slides/view.html?fichero=06d"><img src="images/diapositivas.png" width="32" /></a>
</div>

## 1. The *Collections* class

The Java [Collections](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html) class contains static methods designed to operate with, or generate new collections. Those methods include generating synchronized collections (for safe operation with multiple threads), order a List (with some kind of comparator), reverse a List, rotate a List, get the minimum element, maximum, ...

## 2. Using generics in our own classes

When you look at Java's [ArrayList reference](https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html) web page, you'll see that this class is defined as `ArrayList<E>`. The symbol `<E>` is a notation used to define a generic class, a class that the compiler doesn't know until we instantiate an object. Another common notation is `<T>`, `<S>`, `<U>`, etc.. In general, a capital letter between `<` and `>`. 

If we create a generic, by default it can be any class, so the only properties and methods that the compiler will allow us to use are the ones inherited from `Object` class (all classes in Java inherit from `Object`):

```java
public class GenericExample<T> 
{
    private T generic;

    public GenericExample(T generic) 
    {
        this.generic = generic;
    }

    public void showType() 
    {
        System.out.println(generic.getClass().getName().toString());
        // We can't use for example .substring() 
        // since <T> can be anything.
    }

    public T getGeneric() 
    {
        return generic;
    }
}
```

We define the type of `<T>` when we instantiate an object of GenericExample:

```java
GenericExample<String> genEx = new GenericExample<>("Hello world!");
genEx.showType();   // java.lang.String

/* Here we can use a String method with 
the generic object because the compiler 
knows that the generic is a string */
System.out.println(genEx.getGeneric().length());
```

We can specify that the generic must be a subtype of class or implement some interface. In this case, as it happens with polymorphism, we can use the superclass or the interface's methods:

```java
public class GenericExample<T extends Person> 
{
    ...
    public void show() 
    {
        // generic can use Person methods
        System.out.println(generic.getAge()); 
    }
    ...
}

// MAIN
GenericExample<String> genEx = 
    new GenericExample<>("Hello world!");           // ERROR
GenericExample<Person> genEx = 
    new GenericExample<>(new Person("Nacho", 40));  // OK
```

We can use more than one generic in a class:

```java
public class GenericExample<T extends String, E extends Person> 
{
    T attribute1;
    E attribute2;

    ...
}
```

### 2.1. An introductory example

Imagine we have a class called `Inventory` that can store items (any object that inherits from class `Item`). Let's see the difference in this case between using generics to define that class and using polymorphism.

The general appearance of `Item` class and some of its subclasses would be like this:

```java
public class Item 
{
    private float price;
    private int weight;

    public float getPrice() 
    {
        return price;
    }

    public void setPrice(float price) 
    {
        this.price = price;
    }

    public int getWeight() 
    {
        return weight;
    }

    public void setWeight(int weight) 
    {
        this.weight = weight;
    }
}

public class Potion extends Item 
{
    public void drink() 
    {
        System.out.println("Gulp gulp gulp.");
    }
}

public class Weapon extends Item 
{
    private int damage;

    public int getDamage() 
    {
        return damage;
    }

    public void setDamage(int damage) 
    {
        this.damage = damage;
    }
}
```

If we use polymorphism to deal with a list of `Item` objects in our `Inventory` class, we would have something like this:

```java
public class Inventory 
{
    private List<Item> items = new ArrayList<>();

    public void addItem(Item item) 
    {
        items.add(item);
    }

    public Item getItem(int index) 
    {
        return items.size() > index?items.get(index):null;
    }
}

// MAIN
Inventory inv = new Inventory();
inv.addItem(new Potion()); // Index 0
inv.addItem(new Weapon()); // Index 1

// returns an Item, usually we don't know which type
Item it = inv.getItem(0); 

if(it instanceof Potion) 
{ 
    ((Potion) it).drink(); 
} else if(it instanceof Weapon) { 
    System.out.println("Damage: " + ((Weapon) it).getDamage());
}
```

If we use generics to handle the same list, we would have this:

```java
public class Inventory<T extends Item> 
{
    private List<T> items = new ArrayList<>();

    public void addItem(T item) 
    {
        items.add(item);
    }

    public T getItem(int index) 
    {
        return items.size() > index?items.get(index):null;
    }
}

// MAIN
Inventory<Item> inv = new Inventory<>();      // Same behavior as before!
Inventory<Potion> potInv = new Inventory<>(); // Only allows potions
potInv.addItem(new Potion());                 // OK
potInv.addItem(new Weapon());                 // ERROR, <T> must be a Potion
Potion pot = potInv.getItem(0);               // Compiler knows is a Potion. 
```

In summary, when we always want to be able to use more than one type of object inside a class instance, we can use polymorphism (an inventory with different types of items), although we still can use generics for this. When we want the possibility to use only one class at a time, defined when we instantiate an object, we can only do that with generics (we can create an inventory that only allows potions, other than only allows weapons and so on, using the same class for all).

## 3. Additional exercises

Here you can find additional exercises to practice with the different types of collections explained in this section.

!!! quote "Exercise 1"

    Create a project called **ListBenchmark**. We are going to test in which cases is better to use an `ArrayList`, or a `LinkedList`. To measure the time an operation takes, you can use this piece of code:

    ```java
    Instant start = Instant.now();
    // Some operation with ArrayList or LinkedList
    Instant end = Instant.now();
    Duration dur = Duration.between(start, end);
    System.out.printf("ArrayList: The operation ... takes: %dms\n", dur.toMillis());
    ```

    You have to compare these situations (`ArrayList<Double>` vs `LinkedList<Double>`). Create one of each empty and reuse the same lists in every comparison:
 
    1. Add 100.000 (double) random items always at position 0. Compare times.
    2. Delete the first 50.000 items (always delete the first one).
    3. Add 50.000 random items in random positions.
    4. Delete 50.000 items from random positions.

    You'll see that when using a lot of random accesses (index), `ArrayList` is much faster (`LinkedList` needs to count from the beginning). When adding or deleting items at the beginning the situation is the opposite (`ArrayList` has to reorder internal indexes every time, whereas `LinkedList` doesn't need to).

!!! quote "Exercise 2"

    Create a project named **Companies** with these classes (including `Main`):

    * `Company`: Has name and money (double) attributes (values set in the constructor).
    * `Person`: Has name and age attributes (values set in the constructor).
    * In the main method, create a `TreeMap` (ordered by companies money) in which the key is a Company and the value is a `TreeSet` of `Persons` (ordered by person's age). Populate the TreeMap with 3 companies (do not add them ordered by money) and each company will have a list of 3 people (not ordered when adding).

    Iterate through the *TreeMap* (use the `.entrySet()` method to get a `Set` of keys ordered) and show the companies with their people (both should be ordered by money and age).

!!! quote "Exercise 3"

    Create a project called **AnimalConversation** containing the following classes (including a `Main` class):

    * An abstract class called `Animal`. It will have a protected attribute called `name` (string, assigned in the constructor), and an abstract method called `talk`, that will return a String with the sound that this animal produces.
    * Classes `Dog`, `Cat` and `Sheep` that inherit from class `Animal` and implement the abstract method `talk` (the dogs will return "Wof wof", the cats will return "Meooow" and the sheeps will return "Beeee").
    * A class called `AnimalConversation` that holds two objects (`animal1` and `animal2`), derived from `Animal`. Use generics to define the type of these two objects (each object can be from a different type but always derived from `Animal`). This class has a method called `chat()`, that prints in console the message from `animal1` (calling its method `talk()`), and then from `animal2`.
    * In the `main` method, instance two or more `AnimalConversation` objects, each to compare different kind of animals (one can compare only `Dog` vs `Cat`, another `Cat` vs `Sheep`, and so onâ€¦). See that depending on how you define the generics in every instance it only allows you to set or get (implement setters and getters) that kind of animal and not others.

!!! quote "Exercise 4"

    Create a project named **LibrarySystem** with these classes (including `Main`):

    * `Book`: Has title and author (string) attributes (values set in the constructor).
    * `Member`: Has name and memberID attributes (values set in the constructor).
    * In the main method, create a `HashMap` in which the key is a `Book` and the value is a `LinkedList` of `Members` (no specific order). Populate the `HashMap` with 3 books (do not add them ordered by title or author) and each book will have a list of 2 members (not ordered when adding).

    Iterate through the `HashMap` (use the `.entrySet()` method to get a `Set` of keys) and show the books with their members.

!!! quote "Exercise 5"

    Create a project called **CollectionsPractice** and follow these instructions:

    1. Create a list of integers: Initialize a `List<Integer>` with at least 10 random integers between 1 and 100. Use `java.util.Random` or any method to generate random integers.
    2. Perform these operations using `Collections` methods:
       - Shuffle the list using `Collections.shuffle()`.
       - Find the maximum and minimum values using `Collections.max()` and `Collections.min()`.
       - Sort the list in ascending order using `Collections.sort()`.
       - Reverse the list using `Collections.reverse()`.
       - Rotate the list by 3 positions using `Collections.rotate()`.
    3. After each operation, print the list to observe the changes.

!!! quote "Exercise 6"

    Create a project called **GenericGarage** and follow these instructions:

    1. Define a `Vehicle` base class with common attributes like `make`, `model`, and `year`. Include methods like `startEngine()` that prints a generic message.
    2. Create two subclasses, `Car` and `Motorcycle` that extend `Vehicle`. Override the `startEngine()` method in each subclass to print specific messages like "Car engine started" and "Motorcycle engine started", respectively.
    3. Define a generic class `Garage<T extends Vehicle>`. Inside `Garage`, maintain a `List<T>` to hold the vehicles, and provide methods `addVehicle(T vehicle)` and `getVehicle(int index)`.
    4. In your `main` method: 
        - Create a `Garage<Car>` and a `Garage<Motorcycle>` objects
        - Add several `Car` and `Motorcycle` objects to their respective garages.
        - Retrieve the vehicles from the garages and call their `startEngine()` methods.

    **Key Points**:

    - **Generics with Inheritance**: By using `<T extends Vehicle>`, the `Garage` class ensures that only objects of type `Vehicle` or its subclasses can be used.
    - **Type Safety**: Generics provide compile-time type safety, eliminating the need for casting and reducing runtime errors.
    - **Polymorphism vs. Generics**: While polymorphism allows treating objects of different subclasses uniformly, generics provide the flexibility to define classes and methods that can operate on objects of various types while maintaining type safety.
    - **Flexibility**: The same `Garage` class can be used to create garages for different types of vehicles, such as cars or motorcycles, depending on the specified type parameter.
