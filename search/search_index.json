{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Java programming","text":"<p>This website is (or will be) a complete course for the Java programming language. Along the different blocks of contents, we will navigate through the most important parts of this language, including Java basics (data types, user interaction...), conditions, loops, static and dynamic structures (arrays, lists...), functions, classes and objects... and also some advanced features, such as file management, dates, regular expressions, unit testing, JavaFX applications and much more.</p> <p>The use of these materials is subject to a Creative Commons License CC BY-NC.</p>"},{"location":"01.html","title":"Getting started","text":"<p>Before starting with Java programming language, you should have some knowledge about what a programming language is, which are the most important programming languages nowadays and how to compile and run a Java program. Here you have some external links to read about it (you may open them in new tabs or windows):</p> <ul> <li>Programs, languages and compilers, in which you'll learn what programs and programming languages are, and how to run them using language translators.</li> <li>First steps with Java, in which you'll see how to install Java and create your first program.</li> <li>Using Geany, a simple tool to create and run programs in many languages.</li> <li>Using IntelliJ, an advanced tool to manage Java projects.</li> </ul>"},{"location":"01a.html","title":"Structure of a Java program","text":"<p>Java is an object-oriented programming language, and this implies that we need to work with classes and objects. We'll see later what a class is, but, for now, we only need to know that every piece of code in Java needs to be placed inside a <code>class</code> clause.</p>"},{"location":"01a.html#1-our-first-java-program","title":"1. Our first Java program","text":"<p>Let's see how to start with Java, by creating a simple Java program that prints \"Hello\" in the screen.</p> <pre><code>public class MyClass\n{\n    static void main()\n    {\n        System.out.println(\"Hello\");\n    }\n}\n</code></pre> <p>Let's explain this code:</p> <ul> <li>First line initializes the class in which we are going to place the code. We are creating a class called MyClass.</li> <li>Every code inside this class must be enclosed in curly braces <code>{</code> ... <code>}</code></li> <li>Next, we start another piece of code called main, which is the main piece of code that will be launched when we run the program. In Java, this main block must always be static and void. We'll learn later what all this stuff means. Again, all the code belonging this main block must be enclosed in their corresponding curly braces.</li> <li>Finally, inside the curly braces of the main block, we add every instruction that we want to run. In this case, we are adding a System.out.println instruction, that is in charge of printing in the screen the text that we specify (Hello, in this case). Also, it's important to finish every instruction with a semicolon <code>;</code>. This tells the compiler that the instruction has finished, and we can start evaluating the next one. We could, this way, write more than one instruction per line, although this way of writing programs is not very usual.</li> </ul> <p>Note</p> <p>In previous Java versions (until Java 21), the <code>main</code> block had a more different, rigid structure:</p> <pre><code>public class MyClass\n{\n    public static void main(String[] args)\n    {\n        System.out.println(\"Hello\");\n    }\n}\n</code></pre> <p>From Java 21 this has changed, and the compiler completes the missing code for us: public element and string[] args parameter. We can even omit the class section and also the static word, but we are not going to do this in this course.</p> <p>Note</p> <p>In later examples of this course you may find the \"old\" version of main module in some examples, but you can replace it with the new one if you want to.</p>"},{"location":"01a.html#2-more-about-this-example","title":"2. More about this example","text":"<p>The structure of this program is very similar to the same program written in C#: we always need to define a class, even if we only need a <code>main</code> block. This <code>main</code> block is written in lower case in Java.</p> <p>Besides, every public class must have the same name as the source file that contains it, so we need to store the source code of the example above in a file called <code>MyClass.java</code> (Java source files have <code>.java</code> extension). If we want to compile this code, we use <code>javac</code> tool from our JDK installation. We can do it through any IDE, such as Geany, or IntelliJ, as long as we have Java JDK properly installed. </p> <pre><code>javac MyClass.java\n</code></pre> <p>Then, a new file called <code>MyClass.class</code> will be generated. This is the compiled file that can be run under the Java Virtual Machine (JVM), using the <code>java</code> command. This last step can also be done under any IDE.</p> <pre><code>java MyClass\n</code></pre> <p>After running this program, we will see a \"Hello\" message in the screen.</p>"},{"location":"01b.html","title":"Variables and operators","text":""},{"location":"01b.html#1-using-variables","title":"1. Using variables","text":"<p>Variables are essential elements in every program, since they let us store values in them, so that we can operate with them, or modify them along the program execution. Every variable has a type which lets us know what kind of information we can store in it. For instanec, there are integer variables, that lets us store integer numbers, or string variables to manage texts. We'll learn about data types in other sections.</p> <p>Whenever we want to use a variable we must declare it. This step consists in:</p> <ul> <li>Specifying the data type of the variable (integer, text...)</li> <li>Specifying the name of the variable, which is also known as the variable identifier. </li> </ul> <p>For instance, this way we declare a variable to store integer values, using the word <code>int</code> to specify the data type:</p> <pre><code>int myVariable;\n</code></pre> <p>Additionally, we can also assign a value to the variable. This step can be done either when we declare it, or later in the code:</p> <pre><code>int myVariable = 3;\nint myOtherVariable;\n...\nmyOtherVariable = 5;\n</code></pre> <p>Also, variables can change their values in later sentences.</p> <pre><code>int myVariable = 3;\n...\nmyVariable = 5;\n</code></pre> <p>We can also declare multiple variables of the same type in the same line, separated by commas, and we can decide for each one if we want to assign an initial value or not:</p> <pre><code>int number1 = 0, number2, result = 1;\n</code></pre> <p>Regarding the identifier, it can contain letters (in either lower or upper case), digits, and the underscore symbol <code>_</code>, but it can't start with a digit. These are examples of valid identifiers (they usually start with a lower case letter in Java, but this is not compulsory)</p> <pre><code>int aNumber;\nint another_number;\nint number1;\nint _one_more_number;\n</code></pre> <p>Whereas these are examples of non-valid identifiers:</p> <pre><code>int 1number;\nint another number;\n</code></pre> <p>We can use the <code>System.out.println</code> instruction to show the value of a variable in the screen:</p> <pre><code>public class MyClass\n{\n    public static void main(String[] args)    \n    {\n        int myVariable = 3;\n        System.out.println(myVariable);\n    }\n}\n</code></pre>"},{"location":"01b.html#2-some-basic-java-operators","title":"2. Some basic Java operators","text":"<p>Operators let us evaluate expressions and produce a given result. For instance, if we use the addition operator <code>+</code> we can sum a couple of numbers and get the final result. This final result can either be assigned to a variable or shown in the screen.</p> <pre><code>int result = 3 + 4;\nSystem.out.println(32 + 52);\n</code></pre>"},{"location":"01b.html#21-arithmetic-operators","title":"2.1. Arithmetic operators","text":"<p>Arithmetic operators let us do some basic, mathematical operations with numbers. This is the list of basic arithmetic operators in Java:</p> Operator Meaning <code>+</code> Addition <code>-</code> Substraction <code>*</code> Multiplication <code>/</code> Division <code>%</code> Division module <p>Regarding the division operator, we must take into account that it produces a result of the same type that the numbers involved. In other words, if we divide two integer numbers, such as 5 / 2, then the result will be integer (2), not real. The module operator gets the module of an integer division. In previous example, 5 % 2 gets the module of dividing 5 by 2, which is 1.</p> <p>Operator precedence</p> <p>The order in which operators are evaluated in an arithmetic expression is important. For instance, if we set an expression like this one:</p> <pre><code>int result = 4 + 2 / 2;\n</code></pre> <p>Then <code>result</code> variable gets a final value of 5, because the division <code>2 / 2</code> is evaluated BEFORE the addition. This is the precedence order for arithmetic operators:</p> <ol> <li>Multiplications, divisions and modules</li> <li>Additions and substractions</li> </ol> <p>If there are more than one operator of the same range in an operation, then they are evaluated from left to right. For instance, in this case, we first apply the multiplication, and then the division, and the final result is 2:</p> <pre><code>int result = 4 * 3 / 6;\n</code></pre> <p>However, we can alter the order in which operations are evaluated in an expression, putting between parentheses the operations that we want to evaluate in first places. This expression has a result of 0, because we are forcing to evaluate the division 3 / 6 = 0 in first place.</p> <pre><code>int result = 4 * (3 / 6);\n</code></pre> <p>This other expression has a reuslt of 3, because we are forcing to evaluate the addition before the division:</p> <pre><code>int result = (4 + 2) / 2;\n</code></pre> <p>Exercise 1</p> <p>Try to determine the final value stored in <code>result</code> variable in each one of these expressions. You can write a small Java program later to check your answers.</p> <ul> <li><code>int result = 4 + 8 * 2 / 4</code></li> <li><code>int result = (4 + 8) * 2 / 4</code></li> <li><code>int result = (4 + 8) * 3 % 5</code></li> </ul>"},{"location":"01b.html#22-assignment-operators","title":"2.2. Assignment operators","text":"<p>We have already used the <code>=</code> operator to assign a value to a variable. But there are some other assignment operators that we can use if we want to include some arithmetic operation in the process. For instance, <code>+=</code> operator, which is also known as auto-addition operator, automatically adds the specified value to variable's current value. In this example, the final value of <code>result</code> variable is 5:</p> <pre><code>int result = 3;\nresult += 2;\n</code></pre> <p>This is the list of the assignment operators available:</p> Operator Meaning <code>=</code> Simple assignment <code>+=</code> Auto-addition <code>-=</code> Auto-substraction <code>*=</code> Auto-multiplication <code>/=</code> Auto-division <code>%=</code> Auto-module <p>Auto increment and auto decrement operators</p> <p>Java also provides two additional operators, which are a mix of arithmetic and assignment operators. These operators are the auto-increment <code>++</code> and auto-decrement <code>--</code> operators. They apply to a single variable, and automatically increase or decrease its value in 1 unit, respectively. </p> <p>For instance, final value of <code>result</code> variable in the following code is 4:</p> <pre><code>int result = 3;\nresult++;\n</code></pre> <p>These operators can be placed either before or after the affected variable. There is an important difference that you must take into account regarding the operator placement:</p> <ul> <li>If we place the operator BEFORE the variable in a complex expression, then we first increase/decrease the affected variable, and then we complete the expression. For instance, in this code, the final value of <code>b</code> variable is 6, because we first increase <code>a</code> value (to 4), and then we auto-sum this value to <code>b</code>.</li> </ul> <pre><code>int a = 3, b = 2;\nb += ++a;\n</code></pre> <ul> <li>If we place the operator AFTER the variable in a complex expression, we first evaluate the whole expression, assign the value, and then, we increase/decrease the affected variable. The same code of previous example gets a result of 5 for <code>b</code> variable if we type it like this, although <code>a</code> variable will end with the same final result, which is 4.</li> </ul> <pre><code>int a = 3, b = 2;\nb += a++;\n</code></pre> <p>Note that these rules don't apply if we use the auto-increment or decrement operator in a single line. These two lines have the same effect over variable <code>a</code>:</p> <pre><code>a++;\n++a;\n</code></pre> <p>Exercise 2</p> <p>Determine the final value of <code>result</code> variable after running all these instructions:</p> <pre><code>int result = 4;\nresult += 3;\nresult *= 2;\nresult--;\nresult %= 4;\n</code></pre>"},{"location":"01b.html#3-constants-declaration","title":"3. Constants declaration","text":"<p>Constants are values that never change. We declare constants in Java by declaring the data as <code>final</code> and <code>static</code> (we will learn later the meaning of these terms). Typically these constants are placed at the beginning of the class.</p> <pre><code>class MyClass\n{\n    static final int MAX_USERS = 10;\n    ...\n}\n</code></pre>"},{"location":"01b.html#4-comments","title":"4. Comments","text":"<p>Comments help us clarify some parts of our code, by adding some \"human\" text. This text is ignored by the compiler, but helps the developer understand or find some parts of the code.</p> <p>In Java, there are two types of comments:</p> <ul> <li>Single line comments, which are preceded by a double slash <code>//</code>:</li> </ul> <pre><code>// We declare an integer variable\nint variable = 3;\n</code></pre> <ul> <li>Multiple line comments, which are started by <code>/*</code> and finished by <code>*/</code>. Everything in between makes up the comment, and it's ignored by the compiler:</li> </ul> <pre><code>/* This is a comment of\n   multiple lines before\n   declaring a variable */\nint variable = 3;\n</code></pre>"},{"location":"01c.html","title":"Basic data types","text":"<p>In previous sections we have talked about variables. We have learnt that we can use them to store values, and these values can be of different types. In this section we are going to learn about the basic data types provided by Java, and how we can use them to store values in our programs.</p>"},{"location":"01c.html#1-numeric-types","title":"1. Numeric types","text":"<p>There are two main numeric types in Java:</p> <ul> <li>Integer values, which can be represented by <code>byte</code>, <code>short</code>, <code>int</code> or <code>long</code> data types</li> <li>Real value, which can be represented by <code>float</code> or <code>double</code> data types.</li> </ul>"},{"location":"01c.html#11-integer-data-types","title":"1.1. Integer data types","text":"<p>As we have said before, we can choose among 4 different data types to represent integer values. The choice can be determined by the range of values that we need to deal with. In this table you can see the range of values allowe by each data type:</p> Data type Memory (bytes) Range allowed <code>byte</code> 1 -128 to 127 <code>short</code> 2 -32768 to 32767 <code>int</code> 4 -2.147.483.648 to 2.147.483.647\u200b <code>long</code> 8 up to 18-19 digit numbers <p>For instance, if we want to manage the age of a person, we could use an <code>int</code> variable, but we would waste some memory, since this age is usually lower than 100, and we would just need a single byte to store it. We could use a <code>byte</code> variable instead:</p> <pre><code>byte age = 34;\n</code></pre> <p>However, if we want to store the price of an object, we should use a <code>short</code> or even an <code>int</code> variable:</p> <pre><code>short price = 4200;\nint higherPrice = 2223424;\n</code></pre>"},{"location":"01c.html#12-real-data-types","title":"1.2. Real data types","text":"<p>If we want to deal with real numbers, Java provides two different data types, each one with its own memory space and range:</p> <ul> <li><code>float</code> data type needs 4 bytes of memory, and lets us manage numbers with up to 6-7 significant numbers. For instance, if we want to store PI value in a float variable with just 4 or 5 fraction digits (i.e. 3.14159), we can use a <code>float</code> variable. </li> </ul> <pre><code>float pi = 3.14159;\n</code></pre> <ul> <li><code>double</code> data type needs 8 bytes of memory, and lets us manage numbers with up to 15 significant numbers. This way we can store more fraction digits, if we want to: </li> </ul> <pre><code>double pi = 3.14159265359;\n</code></pre> <p>Regarding <code>float</code> variables, if we want to assign them a direct value, we must specify an <code>f</code> symbol at the end of this value. So the example given before should be written like this (otherwise we'll get a compilation error): </p> <pre><code>float pi = 3.14159f;\n</code></pre>"},{"location":"01c.html#13-the-overflow-problem","title":"1.3. The overflow problem","text":"<p>When we are working with numbers, we may need to do some operations that exceed the maximum range allowed by a data type. For instance, if we are working with two <code>byte</code> values and we add them, we may exceed the maximum range allowed by <code>byte</code> data type, which is 127. This situation is called overflow.</p> <p>So, we must take care of the data types that we choose for each situation, taking into account the different operations that we expect to do with these variables.</p>"},{"location":"01c.html#2-text-types","title":"2. Text types","text":"<p>In order to deal with texts, Java provides two data types:</p> <ul> <li><code>char</code> data type if we want to use single characters or symbols</li> <li><code>String</code> data type if we want to manage complex texts (with more than one character or symbol).</li> </ul> <p>Regarding <code>char</code> data type, it is 2 bytes length, so that we can represent any possible character or symbol. We just declare the corresponding variable, and assign the character represented between single quotes:</p> <pre><code>char symbol = 'a';\n</code></pre> <p>If we want to work with longer texts, then we use <code>String</code> variables, specifying the text between double quotes:</p> <pre><code>String text = \"Hello world\";\n</code></pre>"},{"location":"01c.html#21-escape-sequences","title":"2.1. Escape sequences","text":"<p>There are some special characters that can't be represented easily with the keyboard in a source file. For instance, the new line character, or even the quotes inside a quoted text. For this purpose, we can use escape sequences, this is, special symbols that represent these unwritable elements. This is a list of the most popular escape characters or sequences:</p> Sequence Meaning <code>\\n</code> New line <code>\\t</code> Tabulation <code>\\\"</code> Double quotes <code>\\'</code> Single quotes <code>\\\\</code> Backslash <code>\\</code> <p>These escape sequences can be placed inside a char or string value:</p> <pre><code>char newLine = '\\n';\nString message = \"Hello world.\\n\\\"Quoted text\\\"\";\n</code></pre>"},{"location":"01c.html#22-character-operations","title":"2.2. Character operations","text":"<p>We can do some basic operations with characters. You need to take into account that Java internally treats characters as numeric values, assigning each character a numeric code. For instance, alphabet characters are represented by consecutive numeric values, from <code>a</code> to <code>z</code>. This way, if we add 3 to <code>a</code> value, we will get <code>d</code> value:</p> <pre><code>char symbol = 'a';\nsymbol += 3;\n</code></pre> <p>We can also use <code>+</code> operator in texts (strings), but in this case we are not doing any addition, we are just concatenating texts or expressions. This expressions produces the text \"Hello3\":</p> <pre><code>String text = \"Hello\" + 3;\n</code></pre> <p>Keep in mind that you can't mix arithmetic and text operations in a single line directly. The following expression produces a result of \"Hello32\":</p> <pre><code>String text = \"Hello\" + 3 + 2;\n</code></pre> <p>If you want to calculate the addition and then concatenate the result, then you must prioritize the addition using parentheses. This expression produces a result of \"Hello5\":</p> <pre><code>String text = \"Hello\" + (3 + 2);\n</code></pre>"},{"location":"01c.html#3-conversion-between-data-types","title":"3. Conversion between data types","text":"<p>Sometimes we need to convert a value of some type into another different type. The way we do this step depends on the types involved.</p>"},{"location":"01c.html#31-some-basic-conversions-typecasting","title":"3.1. Some basic conversions. Typecasting","text":"<p>The conversions between numeric values are quite straightforward. We just need to do a typecast, this is, specify between parentheses the data type to which we want to convert the expression. In this example, we are converting <code>pi</code> real value to an integer (so we get 3 as final result):</p> <pre><code>float pi = 3.1416f;\nint piInteger = (int)pi;\n</code></pre> <p>The opposite step can also be done. In this case, we are converting an integer value into a double one (the final value will be 5.0):</p> <pre><code>int number = 5;\ndouble realNumber = (double)number;\n</code></pre> <p>However, this step is NOT necessary if the source type is smaller than the destination type. For instance, a <code>byte</code> doesn't need to be converted into <code>int</code>:</p> <pre><code>byte value = 3;\nint number = value;\n</code></pre> <p>Typecast can be useful, for instance, to convert integer divisions into real ones. This example divides two integer values, but, as we are converting one of them into <code>float</code>, then the final result will be a real number, with the corresponding fraction digits, and can be stored in a <code>float</code> variable:</p> <pre><code>float result = (float) 3 / 2;\n</code></pre> <p>In general, every arithmetic operation tries to produce a result of the same type of its operands (if we divide two integers, we get an integer result, for instance). However, in certain operations, such as additions or multiplications, Java tries to convert the result to a higher type, and we need to typecast it. In this example, we try to add two byte values, but Java tries to convert the result to <code>int</code>, so we need to specify that we want to keep using a <code>byte</code> as a result (even though we could cause an overflow):</p> <pre><code>byte a = 3, b = 2;\nbyte result = (byte)(a + b);\n</code></pre> <p>If we mix two different types in an arithmetic operation, then Java converts the result to the highest of them. This multiplication gets a <code>float</code> number because one of the operands is <code>float</code>:</p> <pre><code>float a = 3.5f;\nint b = 4;\nfloat result = a * b;\n</code></pre>"},{"location":"01c.html#32-converting-from-to-string","title":"3.2. Converting from / to string","text":"<p>In some situations, we may read numeric values from textual sources, such as text file, or user input. In this case, we need to convert the text into the corresponding numeric value. To do this, Java provides some useful instructions. Here you can see the most useful ones:</p> <ul> <li><code>Integer.parseInt</code> converts a text value into <code>int</code>:</li> </ul> <pre><code>int value = Integer.parseInt(\"23\");\n</code></pre> <ul> <li><code>Float.parseFloat</code>, <code>Double.parseDouble</code>, <code>Byte.parseByte</code>, <code>Short.parseShort</code> and <code>Long.parseLong</code> do the same with their corresponding data types:</li> </ul> <pre><code>float value = Float.parseFloat(\"3.1416\");\n</code></pre> <p>If we want to convert a numeric value into a string, we can choose one of these solutions:</p> <ul> <li>Concatenate the numeric value with an empty string <code>\"\"</code>:</li> </ul> <pre><code>int number = 23;\nString text = \"\" + number;\n</code></pre> <ul> <li>Use <code>String.valueOf</code> instruction to convert the specified value to string:</li> </ul> <pre><code>int number = 23;\nString text = String.valueOf(number);\n</code></pre> <p>Exercise 1</p> <p>Create a program called Ages.java that:</p> <ul> <li>Defines two <code>byte</code> variables to store your age and the age of a friend</li> <li>Defines another <code>byte</code> variable to store the addition of both ages (you may need to typecast the result)</li> <li>Defines a <code>float</code> variable to store the average of these ages, including fraction digits</li> <li>Prints the message \"The age average is \" followed by the average calculated in previous step</li> </ul>"},{"location":"01d.html","title":"Basic input and output","text":"<p>In this document we are going to learn how to interact with final user. First of all, we will see how to print values in the screen using different instructions, and then we will see how to gather information from the keyboard and convert it to the appropriate data type.</p>"},{"location":"01d.html#1-program-output","title":"1. Program output","text":"<p>You can use the <code>System.out.print</code> or <code>System.out.println</code> instruction (depending on whether you want a new line at the end or not) to print messages to the screen. You can join multiple values by using the link operator (<code>+</code>):</p> <pre><code>int result = 12;\nSystem.out.println(\"The result is \" + result);\nSystem.out.print(\"Have a nice day!\");\n</code></pre>"},{"location":"01d.html#11-formatted-output","title":"1.1. Formatted output","text":"<p>Apart from traditional <code>System.out.println</code> instruction to print data, we can use some other options if we want this data to have a given output format. To do this, we can use <code>System.out.printf</code> instruction instead of the previous one. This instruction behaves in a similar way than the original <code>printf</code> function from C language. It has a variable number of parameters, and the first of all is the string to be printed out. Then, this string can have some special characters inside it, which determine the data types that must replace these characters. For instance, if we use this instruction:</p> <pre><code>System.out.printf(\"The number is %d\", number);\n</code></pre> <p>then the symbol <code>%d</code> will be replaced by the variable <code>number</code>, and this variable must be an integer (this is what <code>%d</code> means).</p> <p>There are some other symbols to represent different data types. Here are some of them:</p> <ul> <li><code>%d</code> for integer types (<code>long</code>, <code>int</code>)</li> <li><code>%f</code> for real types (<code>float</code> and <code>double</code>)</li> <li><code>%s</code> for strings</li> <li><code>%c</code> for characters</li> <li><code>%n</code> to represent a new line (similar to <code>\\n</code>, but platform independent). In this case, we don't need to add a parameter at the end of <code>printf</code>.</li> </ul> <p>We can place as many symbols as we want inside the output string, and then we will need to add the corresponding number of parameters at the end of the <code>printf</code> instruction. For instance:</p> <pre><code>System.out.printf(\"The average of %d and %d is %f\", \n    number1, number2, average);\n</code></pre> <p>Besides the primary symbols <code>%d</code> and <code>%f</code>, we can add some other information between the '%' and the letter, that specify some format information. </p> <p>Specifying integer digits</p> <p>For instance, if we want to output an integer with a given number of digits, we can do it this way:</p> <pre><code>System.out.printf(\"The number is %05d\", number);\n</code></pre> <p>where <code>05</code> means that the integer is going to have, at least, 5 digits, and if there are not enough digits in the number, then it will be filled with zeros. The output of this instruction if number is <code>33</code> would be <code>The number is 00033</code>. If we don't put the <code>0</code>, then the number will be filled with whitespaces. So this instruction:</p> <pre><code>System.out.printf(\"The number is %10d\", number);\n</code></pre> <p>if number is <code>33</code>, it would produce the following output: <code>The number is \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a033</code>.</p> <p>Specifying fraction digits</p> <p>In the same way that we format integer numbers, we can format real numbers. We can use the same pattern seen before to specify the total number of integer digits:</p> <pre><code>System.out.printf(\"The number is %3f\", number);\n</code></pre> <p>But, besides, we can specify the total number of fraction digits by adding a point and the total number desired, this way:</p> <pre><code>System.out.printf(\"The number is %3.3f\", number);\n</code></pre> <p>Then, if number is <code>3.14159</code>, the output would be  <code>The number is \u00a0\u00a03.142</code>.</p>"},{"location":"01d.html#2-getting-user-input","title":"2. Getting user input","text":"<p>In order to get the user input, the easiest way may be through the <code>Scanner</code> object. We need to import <code>java.util.Scanner</code> in order to use it, and then we create a <code>Scanner</code> element and call some of its methods to read data from the user. Some of them are <code>nextLine</code> (to read a whole line of text until the user presses Enter) and <code>nextInt</code> (to read an integer explicitly):</p> <pre><code>import java.util.Scanner;\n...\npublic class ClassName\n{ \n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int number = sc.nextInt();\n        String text = sc.nextLine();    \n        sc.close();\n    }\n</code></pre> <p>There are some other methods, such as <code>nextFloat</code>, <code>nextBoolean</code>... but they are very similar to <code>nextInt</code>, and they help us read specific data types from the input, instead of reading texts and then converting them into the corresponding type (as <code>Console.ReadLine</code> does in C#). You can introduce this data separated by whitespaces or new lines (Intro).</p> <pre><code>int number1, number2;\nnumber1 = sc.nextInt();\nnumber2 = sc.nextInt();\n</code></pre> <p>Be careful when combining data types</p> <p>Let's suppose that you have to read this information from the input:</p> <pre><code>23 43\nHello world\n</code></pre> <p>You may think that you need to use <code>nextInt</code> method twice, and then <code>nextLine</code> method to read the last string, but this approach is NOT correct: when you use <code>nextInt</code> to read the integer values, you don't read the end of line that exists beyond number 43, so, when you use <code>nextLine</code> method once, you just read this new line, but not the second line. The correct sequence would be this one:</p> <pre><code>int number1 = sc.nextInt();\nint number2 = sc.nextInt();\nsc.nextLine(); \nString text = sc.nextLine();\n</code></pre> <p>Third line reads and discards the new line after number 43.</p>"},{"location":"01d.html#21-using-systemconsolereadline","title":"2.1. Using System.console().readLine()","text":"<p>There's an additional way of reading data from user input. It consists in using <code>System.console().readLine()</code> method, which is similar to Scanner's <code>newLine</code> method: it reads the whole line until user presses Intro, so we ALWAYS read a string with this instruction, and we need to convert it to its corresponding data type later:</p> <pre><code>System.out.println(\"Write a number:\");\nString text = System.console().readLine();\nint number = Integer.parseInt(text);\n</code></pre> <p>The main drawback of this instruction is that it doesn't work well in the terminal of some IDEs, since the terminal of this IDE is not a system terminal, so you can't rely on it in certain situations.</p> <p>Exercise 1</p> <p>Create a program called FormattedDate with a class with the same name inside. The program will ask the user to enter the day, month and year of birth (all values are integers). Then, it will print his birth date with the format d/m/y. For instance, if the user types day = 7, month = 11, year = 1990, the program will output 7/11/1990.</p> <p>Exercise 2</p> <p>Create a program called GramOunceConverter that converts from grams to ounces. The program will ask the user to enter a weight in grams (an integer number), and then it will show the corresponding weight in ounces (a real number), taking into account that 1 ounce = 28.3495 grams.</p> <p>Exercise 3</p> <p>Create a program called NumbersStrings. This program must ask the user to enter 4 numbers, that will be stored in 4 <code>String</code> variables. Then, the program will join the first pair of numbers into a single integer value, and the second pair of numbers into another integer value, and then add these values. For instance, if the user types the numbers 23, 11, 45 and 112, then the program will create a first integer value of 2311 and a second integer value of 45112. Then, it will add these two values and get a final result of 47423.</p> <p>Exercise 4</p> <p>Create a program called CircleArea that defines a float constant called <code>PI</code> with the value <code>3.14159</code>. Then, the program will ask the user to enter the radius of a circle, and it will output the area of the circle (<code>PI</code> * radius * radius). This area will be printed with two decimal digits.</p>"},{"location":"01e.html","title":"Writing clean code","text":""},{"location":"01e.html#1-introduction-to-clean-code","title":"1. Introduction to clean code","text":"<p>When we are writing a program, we should not only think about what the program needs to do. We should also ask some other questions to ourselves, such as:</p> <ul> <li>What if I have to take this project back in two years? Will I understand the code?</li> <li>What if anyone else has to take this project in the future? Will he/she understand the code?</li> </ul> <p>After these questions, you should think of a way to write your code so that it will be easy to read and understand. This is where clean code rules come into play.</p>"},{"location":"01e.html#11-what-is-clean-code","title":"1.1. What is clean code?","text":"<p>You can find many examples and good explanations to this question in the book Clean Code, by Robert C. Martin. Here we just summarize some of these ideas:</p> <ul> <li>Code must be elegant and easy to read, simple and direct. Clean code reads like well-written prose (Grady Booch).</li> <li>Logic should be straightforward to make it hard for bugs to hide.</li> <li>Performance should be close to optimal so as not to tempt people to make further changes.</li> <li>Keep in mind the Boy Scout rule: Leave the campground cleaner than you found it</li> </ul>"},{"location":"01e.html#12-the-importance-of-practice","title":"1.2. The importance of practice","text":"<p>Writing clean code not only consists in reading documents like this one to keep in mind some rules. It also consists in putting into practice these rules continuously. For instance, you can read how to ride a bike, but you won't learn how to do it until you practice.</p> <p>Besides, if we don't start writing clean code from the beginning of a project, there may be some terrible consequences later: projects can grow too much, and then it may be hard to apply clean code rules to the whole code: the time we spend fixing the code in the future may affect deadlines, maintenance, future versions...</p>"},{"location":"01e.html#13-why-bad-code-exists","title":"1.3. Why bad code exists?","text":"<p>Although everyone should apply clean code rules in their programs, and we can easily see the benefits of working this way, there are many reasons why bad code exists:</p> <ul> <li>Too tight schedules</li> <li>Unexperienced project managers</li> <li>Programmer's docility (he/she doesn't want to get fired)</li> <li>Boredom (always doing the same kind of projects)</li> <li>...</li> </ul>"},{"location":"01e.html#14-whats-coming-next","title":"1.4. What's coming next?","text":"<p>In this document we are going to focus on some basic aspects of clean code rules, such as how to assign variable names and how to place comments in our code.</p>"},{"location":"01e.html#2-dealing-with-variable-names","title":"2. Dealing with variable names","text":"<p>Names are essential in programming, since we will assign a name to (almost) everything we include in our program. At this point you should already know what a variable is and its main purpose (store values that can be modified along the program execution). But you should not assign a variable name carelessly. You should use meaningful names for your variables. </p> <p>When reading the name of a variable (or any other element in the code), it must answer some basic questions, such as why it exists, what it does and how it is used. If a name requires a comment to explain its meaning, then it is not a suitable name. For instance, if we want to store in a variable the age average of a list of people, we should NOT do this:</p> <pre><code>int a;          // Age average\n</code></pre> <p>We could do this instead:</p> <pre><code>int ageAverage;\n</code></pre> <p>Some other aspects that we should take into account when dealing with variable names:</p> <ul> <li>Try not to use too similar names. Variables like <code>totalRegisteredUsers</code> and <code>totalUnregisteredUsers</code> only differ in two letters, and you could use the wrong one in a given piece of code. It's better to call them <code>registered</code> and <code>anonymous</code>.</li> <li>Add meaningful context when it's necessary. For instance, if a variable is named <code>account</code>, what does it mean? A user account? a bank account? It's better to be more specific, and call it <code>bankAccount</code>, for instance</li> <li>Choose one word per concept: if you declare many variables in many parts of your code to refer to a user login, you should always call them in the same way: <code>user</code>, or <code>login</code>, for instance, but don't change the name in each situation.</li> <li>Don't use short names, such as <code>n</code>, or <code>e</code>, because it will be difficult to find your variable among other similar words in the text.</li> <li>Try to use readable names. It's better to use a name like <code>birthDate</code> than <code>ddmmyyyy</code>, because you can pronounce this name in a conversation.</li> </ul>"},{"location":"01e.html#21-uppercase-or-lowercase","title":"2.1. Uppercase or lowercase?","text":"<p>The use of uppercase and lowercase letters in names depend on the programming language itself. There are mainly four naming standards:</p> <ul> <li>Camel Case: it is used in languages such as Java or Javascript. Every word in the variable name starts with upper case, apart from the first word. For instance:</li> </ul> <pre><code>String personName;\n</code></pre> <ul> <li>There is a subset of camel case standard, called Pascal Case in which the first word of the name also starts with uppercase. This subset is employed by C# to define public elements (private elements are named using camel case). For instance:</li> </ul> <pre><code>string personName;\npublic int PersonAge;\n</code></pre> <ul> <li>Snake Case: it is used in languages such as PHP or Python. Variable words are separated by underscores:</li> </ul> <pre><code>$person_name = \"Nacho\";\n</code></pre> <ul> <li>Kebab Case: variable words are separated by hyphens. It is not very popular among programming languages, since many of them don't allow the hyphen as part of the variable name (so as not to mix it up with the substraction operator). There are some few examples, such as Lisp or Clojure.</li> </ul> <pre><code>(def person-name \"Nacho\")\n</code></pre> <ul> <li>Upper case: it is used in many languages to define constants. The words of the name are usually separated by underscores, as in snake case standard:</li> </ul> <pre><code>static final int MAXIMUM_SIZE = 100;\n</code></pre>"},{"location":"01e.html#3-placing-comments","title":"3. Placing comments","text":"<p>Well-placed comments help us understand the code around them, whereas misplaced comments can damage the understanding of the code. Some programmers think that comments are failures, and should be avoided as much as possible. One of the reasons argued is that they are hard to maintain. If we change the code after writing a comment, we may forget to update the comment, and thus it would talk about something that is no longer present in the code.</p> <p>Another reason to avoid comments is that they are tightly linked to bad code. When we write bad code, we often think that we can write some comments to make it understandable, instead of cleaning the code itself.</p> <p>In this section we will learn where to put comments. Firstly, we will see what type of comments are necessary (what we call good comments), and then we will see what comments are avoidable (bad comments).</p>"},{"location":"01e.html#31-good-comments","title":"3.1. Good comments","text":"<p>The following comments are considered necessary:</p> <ul> <li>Legal comments, such as copyright or authorship, according to the company standards. This type of comments are normally placed at the beginning of each source file that belongs to the author or company.</li> <li>Introduction comments, a short comment at the beginning of each source file (typically classes) that explains the main purpose of this source file or class. This comment is usually placed along with a legal comment at the beginning of a source file:</li> </ul> <pre><code>/*\n This class stores information about a user account\n\n Created by Nacho Iborra\n */\n\npublic class User\n{\n    ...\n}\n</code></pre> <ul> <li>Explanation of intent. These comments are used when:</li> <li>We tried to get a better solution to the problem but we could not, and then we explain that a part of the code could be improvable.</li> <li>There is a part of the code that does not follow the same pattern than the code around it (for instance, an integer variable among a bunch of floats), and we want to explain why we have used this instruction or data type.</li> <li>TODO comments, which are placed in incomplete parts. They help us remember all the pending tasks. This type of comments have become so popular that a lot of IDEs automatically detect and highlight them.</li> <li>API documentation. Some programming languages, such as Java or C#, let us add some comments in some parts of the code so that these comments are exported to HTML or XML format, and become part of the documentation. </li> </ul>"},{"location":"01e.html#32-bad-comments","title":"3.2. Bad comments","text":"<p>The following are examples of bad comments that we can avoid...</p> <p>Some type of information comments can be avoided by changing the name of the element that they are explaining. For instance, if we have this comment with this variable:</p> <pre><code>// Total number of customers\nint total;\n</code></pre> <p>We can avoid the comment by renaming the variable this way:</p> <pre><code>int totalCustomers;\n</code></pre> <p>Redundant comments, i.e. comments that are longer to read than the code they are trying to explain, or they are just unnecessary, because the code is self-explanatory. For instance, the following comment is redundant, since the code it is explaining is quite understandable:</p> <pre><code>/* We ask the user two numbers and add them */\nScanner sc = new Scanner(System.in);\nSystem.out.println(\"Enter two numbers\");\nint number1 = sc.nextInt();\nint number2 = sc.nextInt();\nSystem.out.println(number1 + number2);\n</code></pre> <p>Comments without context, i.e. comments that are not followed by the corresponding code. For instance, the following comment is not completed with appropriate code. We say we are writing data into a file, but nothing is executed after that. Maybe there was some piece of code, but it was removed.</p> <pre><code>/* We ask the user two numbers and add them */\nScanner sc = new Scanner(System.in);\nSystem.out.println(\"Enter two numbers\");\nint number1 = sc.nextInt();\nint number2 = sc.nextInt();\nSystem.out.println(number1 + number2);\n// We print the result in a text file\n</code></pre> <p>There should be no mandated comments. Some people think that every variable, for instance, must have a comment explaining its purpose. But that is not a good decision, since we can avoid most of these comments by using appropriate variable names.</p> <p>Also, there should be no journal comments: sometimes an edit registry is placed at the beginning of a source file. It contains all the changes made to the code, including the date and the reason of the change. But nowadays, we can use version control applications, such as GitHub, to keep this registry out of the code itself.</p> <p>Some time ago, some programmers used to place some position markers and/or code dividers,  to quickly find a place in the code, or to separate some code blocks that are quite long. Both types of comments are not recommended if code is properly formatted.</p> <pre><code>// =================== VARIABLES ====================\nint age;\nString name;\n...\n// =================== MAIN =========================\npublic static void main(String[] args)\n{\n    ...\n    ////// FINAL RESULT\n}\n</code></pre> <p>Closing brace comments are also not recommended. They are placed at every closing brace to explain which element is this brace closing. These comments can be avoided, since most of current IDEs highlight each pair of braces when we click on them, so that we can match each pair automatically. </p> <pre><code>public static void main(String[] args)\n{\n    ...\n} // end main\n</code></pre> <p>Warnings are used when we have some code that may cause problems in certain situations, because it needs to be reviewed. It is very usual to find some code blocks completely commented, and a warning message explaining the problem with it. These comments should be turned into \"TODO\" comments, in order to warn the programmer that this code needs to be reviewed in the future, instead of just removing the comments.</p> <p>Exercise 1</p> <p>This program asks the user to introduce three numbers and gets the average of them. Discuss in class which parts of the code are not clean or could be improved, regarding variable names and comments.</p> <pre><code>import java.util.Scanner;\n\npublic class AverageNumbers\n{\n    public static void main(String[] args)\n    {\n        // Variables to store the three numbers and the average\n        int n1, n2, n3;\n        int Result;\n        Scanner sc = new Scanner(System.in);\n\n        // We ask the user to enter three numbers\n        System.out.println(\"Introduce three numbers:\");\n        n1 = sc.nextInt();\n        n2 = sc.nextInt();\n        n3 = sc.nextInt();\n        // The result is the average of these numbers\n        /* We could have used a float number instead, \n            but we decided to keep this program as \n            simple as we could */\n        Result = (n1+n2+n3)/3;\n        System.out.println(\"The average is \" + Result);\n    }\n}\n</code></pre>"},{"location":"02a.html","title":"Boolean type and operators","text":"<p>In this section we are going to talk about the basics of structured programming using logical information. So, we are going to introduce the boolean data types that lets us check some conditions and decide which piece of code we should run next. This way, we can choose among different results depending on a given input condition, or even repeat the execution of a given piece of code many times without having to re-type it again.</p>"},{"location":"02a.html#1-boolean-data-type","title":"1. Boolean data type","text":"<p>Boolean data type is another basic data type (just like integers, characters or floating point numbers) that lets us represent two opposite values: true and false. In Java, this data type is represented by the word <code>boolean</code>. We can declare variables of this type, and also assign an initial value to them (from the range <code>true</code> and <code>false</code>):</p> <pre><code>boolean b = true;\n</code></pre> <p>We can even read boolean values from user input, using <code>nextBoolean</code> method from the Scanner variable. In this case, user must type true or false in the keyboard, which is not very intuitive.</p> <pre><code>Scanner sc = new Scanner(System.in);\nboolean b = sc.nextBoolean();\n</code></pre>"},{"location":"02a.html#2-some-additional-operators","title":"2. Some additional operators","text":"<p>Related with this boolean data type, there are some Java operators that we can use. In this section we are going to talk about relational and logical operators.</p>"},{"location":"02a.html#21-relational-operators","title":"2.1. Relational operators","text":"<p>Relational operators let us compare two different values, and check if one of them is greater, or lower, or equal than the other. This is the complete list of relational operators:</p> Operator Meaning <code>&gt;</code> Greater than <code>&gt;=</code> Greater or equal than <code>&lt;</code> Lower than <code>&lt;=</code> Lower or equal than <code>==</code> Equal to <code>!=</code> Not equal to <p>Note that, if we want to check if two values are equal, we use <code>==</code> comparator instead of just <code>=</code>, which is used for assignment purposes. We can join these operators with boolean values to determine if some comparisons are true or false:</p> <pre><code>int n = 10;\nboolean check1 = n &gt; 5;     // true\nboolean check2 = n != 10;   // false\n</code></pre> <p>Regarding strings, we can't use these comparators, because they don't work as expected (our program compiles, but results may be unpredictable). If we want to check if two strings are the same, we use <code>equals</code> instruction instead of <code>==</code> comparator:</p> <pre><code>String s1 = \"Hello\";\n\nboolean check1 = s1 == \"Hello\";      // Does not work as expected\nboolean check2 = s1.equals(\"Hello\"); // OK\n</code></pre> <p>We'll learn more about how to deal with string values in later sections.</p>"},{"location":"02a.html#22-logical-operators","title":"2.2. Logical operators","text":"<p>Logical operators join two or more simple comparisons to build a complex one. This way we can check if every comparison in the list is true, or at least one of them. The final result of this complex expression is also a boolean value. This is the list of logical operators:</p> Operator Meaning <code>&amp;&amp;</code> AND operator <code>||</code> OR operator <code>!</code> NOT operator <p>Regarding AND operator <code>&amp;&amp;</code>, it joins two comparisons, so that the final result will be true if both comparisons are true. Otherwise it will be false:</p> <pre><code>int n = 10, m = 5;\n\nboolean c1 = n &gt; 5 &amp;&amp; m &lt; 10;   // true &amp;&amp; true = true\nboolean c2 = n &gt; 5 &amp;&amp; m &gt; 10;   // true &amp;&amp; false = false\n</code></pre> <p>OR operator <code>||</code> also joins two comparisons, but in this case the final result will be true if any of the comparisons joined (or both) are true:</p> <pre><code>int n = 10, m = 5;\n\nboolean c1 = n &gt; 5 || m &gt; 10;   // true || false = true\nboolean c2 = n &lt; 5 || m &gt; 10;   // false || false = false\n</code></pre> <p>Finally, the NOT operator <code>!</code> is a unary operator, this is, it affects only one expression (not two), and changes the value of this expression (this is, if the expression was true, the final result is false, and vice versa).</p> <pre><code>int n = 10;\n\nboolean c1 = n &gt; 5;    // true\nboolean c2 = !c1;      // false\n</code></pre> <p>The precedence of these operators is important:</p> <ol> <li>First of all, we evaluate every expression between parentheses</li> <li>Then, we evaluate NOT operators</li> <li>Next, we check AND operators</li> <li>Finally, we look for OR operators</li> </ol> <p>Also, you must take into account that both AND and OR operators work in short circuit mode. This means that:</p> <ul> <li>Regarding AND operator, if the first expression is false, second expression is not checked (final result will be false anyway)</li> <li>Regarding OR operator, if the first expression is true, second expression is not checked (final result will be true anyway).</li> </ul> <p>Exercise 1</p> <p>Try to guess the final result of these expressions <code>e1</code>, <code>e2</code> and <code>e3</code>. You can then write a short program to check your answers:</p> <pre><code>int a = 3, b = 5, c = 8;\n\nboolean e1 = a &lt; 2 &amp;&amp; b &gt;= 5 || c == 8;\nboolean e2 = a &lt; 2 &amp;&amp; (b &gt;= 5 || c == 8);\nboolean e3 = !(a &lt; 2) &amp;&amp; (b &gt;= 5 || c == 8);\n</code></pre>"},{"location":"02b.html","title":"Selective structures","text":"<p>Selective or conditional structures let us choose among different paths in our code depending on a given condition (or conditions) that must be checked. In this document we'll see the selective structures provided by Java.</p>"},{"location":"02b.html#1-the-if-clause","title":"1. The \"if\" clause","text":"<p>You can use the <code>if</code> basic structure to run a piece of code if a given condition is true:</p> <pre><code>if (age &gt;= 18)\n{\n    System.out.println(\"You are old enough\");\n}\n</code></pre> <p>Alternatively, you can use <code>if..else</code> structure to choose among a given path (determined by a condition) or its opposite:</p> <pre><code>if (age &gt;= 18)\n{\n    System.out.println(\"You are old enough\");\n}\nelse\n{\n    System.out.println(\"You are not adult yet\");\n}\n</code></pre> <p>Finally, if there is more than two paths to choose among, we can join <code>if .. else if .. else if .. else</code> structures to choose among several paths depending on the condition relative to each one. Only one path will be chosen.</p> <pre><code>if (number &gt; 0)\n{\n    System.out.println(\"It is positive\");\n}\nelse if (number &lt; -10)\n{\n    System.out.println(\"It is under -10\");\n}\nelse\n{\n    System.out.println(\"It is between -10 and 0\");\n}\n</code></pre> <p>The condition in each <code>if</code> or <code>else if</code> clause can be either a simple condition (like the ones shown in previous examples) or a complex condition, joined by logical operators <code>&amp;&amp;</code> and/or <code>||</code>:</p> <pre><code>if (age &gt;= 18 &amp;&amp; age &lt;= 30)\n{\n    System.out.println(\"You are between 18 and 30\");\n}\n</code></pre>"},{"location":"02b.html#2-the-switch-clause","title":"2. The \"switch\" clause","text":"<p>Besides, there's a <code>switch</code> clause that lets us evaluate the value of a simple variable or expression. Each of the possible values of this expression can be represented with a <code>case</code> clause. Finally, we can use a <code>default</code> case to represent any other possible value that has not been covered by previous case clauses. </p> <p>The data managed in the <code>switch</code> clause must be a primitive type; strings are NOT allowed in early versions of Java (Java 6 and earlier). We need to add a <code>break</code> instruction at the end of each case to exit the switch clause; otherwise, the program keeps running the instruction of next case clause. In other languages, such as C#, the break instruction is compulsory in the case clauses that are not empty, but this does not happen in Java, so we must take care of this situation.</p> <pre><code>switch(number)\n{\n    case 0: System.out.println(\"It is 0\"); break;\n    case 1: System.out.println(\"It is 1\");\n    case 2: System.out.println(\"It is 2\"); break;\n    default: System.out.println(\"Unknown number\");\n}\n</code></pre> <p>In previous example, if number is 1, it would output the messages \"It is 1\" and \"It is 2\", since there is no <code>break</code> clause at case 1.</p> <p>Exercise 1</p> <p>Create a program called MarkCheck that asks the user to enter 3 marks. The program must print one of these messages, depending on the mark values:</p> <ul> <li>All marks are greater or equal than 4</li> <li>Some marks are not greater or equal than 4</li> <li>No mark is greater or equal than 4</li> </ul> <p>Exercise 2</p> <p>Create a program called GramOunceConverter2 that will be an improved version of a previous exercise. In this case, the user will type a weight (float), and a unit (<code>g</code> for grams, <code>o</code> for ounces). Then, depending on the unit chosen, the program will convert the weight to the opposite unit. For instance, if the user types a weight of 33 and chooses <code>o</code> as unit, then the program must convert 33 ounces to grams. You must solve this program using a <code>switch</code> structure. If the unit is other than <code>g</code> or <code>o</code>, then the program must output an error message: \"Unexpected unit\", with no final result.</p>"},{"location":"02b.html#3-additional-exercises","title":"3. Additional exercises","text":"<p>Here you can find more additional exercises to practice with selective structures:</p> <p>Additional exercise 1</p> <p>Write a program that asks the user for their age. Use <code>if-else</code> statements to determine and display:</p> <ul> <li>\"Child\" if the age is less than 13.</li> <li>\"Teenager\" if the age is between 13 and 19.</li> <li>\"Adult\" if the age is 20 or older.</li> </ul> <p>Additional exercise 2</p> <p>Write a program that takes three numbers as input from the user. Use <code>if-else</code> to find and display the largest number among them.</p> <p>Additional exercise 3</p> <p>Ask the user to enter a year. Use an <code>if-else</code> statement to determine if the year is a leap year or not. A year is a leap year if it is divisible by 4 but not divisible by 100, unless it is also divisible by 400.</p> <p>Additional exercise 4</p> <p>Write a program that takes a single character input from the user. Use a <code>switch</code> statement to check whether the character is a vowel (<code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, <code>u</code>) or a consonant. Handle both uppercase and lowercase characters.</p> <p>Additional exercise 5</p> <p>Ask the user to input two numbers and an operator (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>). Use a <code>switch</code> statement to perform the corresponding arithmetic operation and display the result. Handle division by zero with an <code>if-else</code> check.</p> <p>Additional exercise 6</p> <p>Ask the user to input their grade as a percentage (0-100). Use <code>if-else</code> to determine and display:</p> <ul> <li>\"A\" for grades 90 and above.</li> <li>\"B\" for grades between 80 and 89.</li> <li>\"C\" for grades between 70 and 79.</li> <li>\"D\" for grades between 60 and 69.</li> <li>\"F\" for grades below 60.</li> </ul> <p>Additional exercise 7</p> <p>Ask the user to input a number between 1 and 12 representing a month. Use a <code>switch</code> statement to print the number of days in that month. Consider February to have 28 days.</p> <p>Additional exercise 8</p> <p>Write a program that asks the user for a number. Use an <code>if-else</code> statement to check if the number is even or odd and display the result.</p> <p>Additional exercise 9</p> <p>Ask the user to input a color (<code>red</code>, <code>yellow</code>, or <code>green</code>). Use a <code>switch</code> statement to display:</p> <ul> <li>\"Stop\" for red.</li> <li>\"Get Ready\" for yellow.</li> <li>\"Go\" for green.</li> </ul> <p>Handle invalid inputs with a default case.</p> <p>Additional exercise 10</p> <p>Ask the user for the current hour (0-23). Use <code>if-else</code> statements to determine:</p> <ul> <li>\"Morning\" if the hour is between 5 and 11.</li> <li>\"Afternoon\" if the hour is between 12 and 17.</li> <li>\"Evening\" if the hour is between 18 and 21.</li> <li>\"Night\" if the hour is between 22 and 4.</li> </ul>"},{"location":"02c.html","title":"Iterative structures","text":"<p>Iterative structures, also known as loops, can repeat a set of instructions a given number of times, or as long as a condition is true. This way, we avoid writing this set of instructions more than once if we want to repeat it. Now, we are going to see the main iterative structures provided by Java, although we will learn some more in later documents.</p>"},{"location":"02c.html#1-the-while-clause","title":"1. The \"while\" clause","text":"<p>This clause is used to repeat a given set of instructions while a given condition (or set of conditions) is true. For instance, this example counts from 1 to 10:</p> <pre><code>int n = 1;\nwhile (n &lt;= 10)\n{\n    System.out.println(n);\n    n++;\n}\n</code></pre> <p>As soon as the condition inside the while clause is false, the program exits the loop and runs next instruction beyond this loop. Take into account that this instruction can be simple or complex:</p> <pre><code>int n = 1;\nwhile (n &gt;= 1 &amp;&amp; n &lt;= 10)\n{\n    ...\n}\n</code></pre>"},{"location":"02c.html#2-the-dowhile-clause","title":"2. The \"do..while\" clause","text":"<p>This clause si similar to the previous one, but the condition is evaluated at the end of the loop, instead of the beginning. If we do the same loop than in previous example with a <code>do..while</code> structure, it would look like this.</p> <pre><code>int n = 1;\ndo\n{\n    System.out.println(n);\n    n++;\n} while (n &lt;= 10);\n</code></pre> <p>We will use this loop when we don't know how many iterations are expected, but we know that there will be (at least) one iteration. It is very usual when we ask the user to type something and then check the input and ask the user again. On the contrary, while loop is better when we don't even know if there will be one iteration.</p>"},{"location":"02c.html#3-the-for-clause","title":"3. The \"for\" clause","text":"<p>We will use this loop when we know how many iterations are expected. It has 3 parts on it:</p> <ul> <li>The declaration of a counter</li> <li>The condition to repeat the bucle (similar to while or do..while condition)</li> <li>The increment or decrement for the counter (generally to reach the end of the loop when the condition turns into false)</li> </ul> <p>The counter from 1 to 10 should be done with this structure preferably, and it would look like this:</p> <pre><code>for (int n = 1; n &lt;= 10; n++)\n{\n    System.out.println(n);\n}\n</code></pre> <p>Note that we can declare variables in <code>for</code> loops (and in the middle of other code, as in other languages such as C#).</p>"},{"location":"02c.html#31-another-for","title":"3.1. Another \"for\"","text":"<p>There is another way of using the <code>for</code> clause, applied to collections or arrays. It consists in using a variable with the same type, this way:</p> <pre><code>for (int number: numbers)\n    System.out.println(\"\" + number);\n</code></pre> <p>where <code>numbers</code> is expected to be a collection or array of integers. This structure is equivalent to the <code>foreach</code> structure of other languages such as C#, and is expected to be used in a read-only way (only to check the values, but not to modify them).</p> <p>Exercise 1</p> <p>Create a program called GroupPeople that asks the user to enter how many people is going to attend to a conference. The program must create groups of (preferably) 50 people. Whenever this is not possible, then it will attempt to create groups of 10 people, and finally it will create groups of 1 person. The program must output how many groups of each category are necessary. For instance, if 78 people are going to attend to the conference, then we need 1 group of 50 people, 2 groups of 10 people and 8 groups of 1 people.</p> <p>Exercise 2</p> <p>Create a program called SumDigits that asks the user to enter numbers (integer values) until he enters 0. The program must sum up all the numbers entered by the user and then show the final result, and how many digits it has. For instance, if the user types 12, 20, 60, 33, 99 and 0, then the program must output: \"The result is 224, and it has 3 digits\".</p>"},{"location":"02d.html","title":"Some additional concepts","text":"<p>In this document we are going to learn some additional concepts related with the control structures seen in this unit. We'll see how to work with more complex loop structures, and some additional elements that we can add to these loops. Also, we will learn some basic rules to write clean code regarding these control structures.</p>"},{"location":"02d.html#1-nested-loops","title":"1. Nested loops","text":"<p>The iterative structures that we have learnt in previous documents can be combined, so that we can place one of them inside another. This complex structure is also called nested loop. It can be a do..while inside a for, or a for inside another for, or any other combination.</p> <p>For instance, the following code prints a square filled with asterisks, whose size is determined by variable size (we assume that this variable has been previously declared and assigned):</p> <pre><code>for (int i = 1; i &lt;= size; i++)\n{\n    for (int j = 1; j &lt;= size; j++)\n    {\n        System.out.print(\"*\");\n    }\n    System.out.println();\n}\n</code></pre> <p>Exercise 1</p> <p>Write a program called Triangle in which we ask a user to enter a height (integer) and then we write a reversed triangle like the following one (assuming a height of 5):</p> <pre><code>*****\n ****\n  ***\n   **\n    *\n</code></pre> <p>Exercise 2</p> <p>Create a program called Counter that asks the user to write a number between 1 and 100. The program must keep asking the number until it is a number in the valid range. When the number is valid, it must count from this number to 1 in descending order.</p>"},{"location":"02d.html#2-using-break-and-continue","title":"2. Using \"break\" and \"continue\"","text":"<p>There are some special instructions that can be used inside loops to alter its natural behavior. These instructions are break and continue.</p> <p>The break instruction exits the loop in which it is placed. For instance, this loop only counts from 1 to 5, because the break instruction exits before completing the whole count:</p> <pre><code>for (int i = 1; i &lt;= 10; i++)\n{\n    System.out.println(i);\n    if (i == 5)\n        break;\n}\n</code></pre> <p>The continue instruction forces a new iteration of the loop, without running the instructions below it. For instance, this loop counts from 1 to 10, but it does not print number 5, because continue instruction goes back to the beginning of the loop when i is 5, without printing this value at the end of the loop:</p> <pre><code>for (int i = 1; i &lt;= 10; i++)\n{\n    if (i == 5)\n        continue;\n    System.out.println(i);\n}\n</code></pre> <p>These two instructions are NOT recommended in our programs, since they can be easily avoided in order to make our code more understandable. In the first case, if we just want to count from 1 to 5, we should just define a for loop from 1 to 5. In the second case, if we don't want to print number 5 in the screen, we can specify this condition in the if clause:</p> <pre><code>for (int i = 1; i &lt;= 10; i++)\n{\n    if (i != 5)\n        System.out.println(i);\n}\n</code></pre>"},{"location":"02d.html#3-writing-clean-code-spacing","title":"3. Writing clean code. Spacing.","text":"<p>In previous documents we have seen some basic rules to write clean code, but now that we have learnt some additional concepts regarding control structures, our code can get a little bit more complex, and we need to apply some additional rules to keep it tidy.</p> <p>Appropriate code formatting and spacing tells the reader that the programmer has paid attention to every single detail of the program. However, when we find a bunch of lines of code incorrectly indented and/or spaced, we may think that the same inattention may be present in other aspects of the code.</p>"},{"location":"02d.html#31-vertical-spacing","title":"3.1. Vertical spacing","text":"<p>Let's see some simple rules to format and space your code vertically:</p> <ul> <li>As each group of lines represents a task, these groups should be separated from each other with a blank line. In a Java program, for instance, we would have something like this (pay attention to where blank lines are added):</li> </ul> <pre><code>import java.util.Scanner;\n\npublic class Program \n{\n    public static void main(String[] args) \n    {\n        int personAge;\n        String personName;\n        Scanner sc = new Scanner(System.in);\n\n        System.out.println(\"Tell me your name:\");\n        personName = sc.nextLine();\n\n        System.out.println(\"Tell me your age:\");\n        personAge = sc.nextInt();\n\n        if (personAge &gt; 18)\n            System.out.println(\"You are an adult, \" + personName);\n    }\n}\n</code></pre> <ul> <li>Concepts that are tightly related should be placed together vertically. For instance, if we declare two variables to store the name and age of a person, then we should place these declarations one after another, with no separations. This means that we should not add any comment that breaks the union:</li> </ul> <pre><code>String personName;\n/* \n * This comment should not be written here!\n */\nint personAge;\n</code></pre> <ul> <li>Opening braces are put either at the end of the lines that need them (typical in programming languages such as Java or JavaScript) or at the beginning of the following line, with the same indentation than previous line (typical in programming languages such as C or C#). In this last case, they can act as blank lines of separation between blocks</li> </ul> <pre><code>// Java style (opening brace is NOT considered a blank line)\nif (condition) {\n    ...\n}\n\n// C# style (opening brace can be considered a blank line)\npublic static void Main()\n{\n    if (condition)\n    {\n        ...\n    }\n...\n</code></pre> <p>Regarding opening braces, you can decide which of these patterns you want to apply, but you must:</p> <ul> <li>Apply always the same pattern</li> <li>Use the same pattern than all the people in your team</li> </ul>"},{"location":"02d.html#32-horizontal-formatting","title":"3.2. Horizontal formatting","text":"<p>Regarding horizontal spacing or formatting, there are also some simple rules that we can follow.</p> <ul> <li>A line of code should be short (maybe 80 or 100 characters length, as much). Some IDEs show a vertical line (typically red) that sets the \"ideal\" limit for the length of each line. If it is going to be longer, we should cut it and divide the code in multiple lines. You can also apply other rules to determine the maximum line width: you should never have to scroll to the right to see your code, and it should be printable with the same appearance in a vertical page.</li> </ul> <pre><code>if ((personAge &gt; 18 &amp;&amp; personAge &lt;= 65) ||\n    (personName.equals(\"John\")) || (personName.equals(\"Mary\"))) \n{\n    ...\n}\n</code></pre> <ul> <li>Horizontal spacing helps us associate things that are related, and disassociate things that are not. For instance, operators should be separated with a whitespace from the elements they are operating:</li> </ul> <pre><code>int average = (number1 + number2) / 2;\n</code></pre> <ul> <li>Do not align the variable names vertically. It was very typical in old programming languages, such as assembly, but it makes no sense in modern programming languages, where there are lots of different data types. If you do this, you might tend to read the variable names without paying attention to their data types:</li> </ul> <pre><code>StringBuilder longText;\nint           textSize;\nString        textToFindAndReplace;\n</code></pre> <ul> <li>The indentation is important, since it establishes a hierarchy. There are elements that belong to the whole source file, and others that are part of a concrete block. Indentation help us determine the scope of a group of instructions. In this way:</li> <li>Class name is not indented</li> <li>Functions or other elements inside a class are indented one level</li> <li>Implementation of these functions are indented two levels</li> <li>Block implementations inside function code (code of if or while clauses, for instance) are indented three levels</li> <li>... etc.</li> </ul> <pre><code>public class MyClass \n{\n    public static void main(String[] args) \n    {\n        System.out.println(\"Hello\");\n        if (...) \n        {\n            System.out.println(\"Inside an if\");\n        }\n    }\n}\n</code></pre>"},{"location":"03a.html","title":"Arrays","text":"<p>Static data types store values so that the total size of these values does not change along the program execution. In this document we are going to explain what an array is and how to use them to store many values of the same type.</p> <p>An array is a set of data of the same type (integers, texts, characters...) grouped in a single variable. Data is structured so that we can access each element by its index or position in the array, starting at 0. The total number of elements contained in the array must be known before creating the array. So the size of the array is constant, and can't be changed along the program execution.</p>"},{"location":"03a.html#1-unidimensional-arrays","title":"1. Unidimensional arrays","text":"<p>Unidimensional arrays are the simplest type of arrays. They consist in a sequence of data with a single index to access each position. We use square brackets <code>[]</code> to declare a variable as an array, and the <code>new</code> operator to determine its size (number of positions). We can declare the array variable in one line and determine its size in another, different line (once we know the size that we need for the array) or do it all in the same line:</p> <pre><code>int[] numbers = new int[10];        // Array of 10 integers\n\nfloat[] numbers;\nint n;\nScanner sc = new Scanner(System.in);\nSystem.out.println(\"Enter the array size:\");\nn = sc.nextInt();\nnumbers = new int[n];               // Array of n floats\n</code></pre> <p>Square brackets can also be placed after the variable name, although we recommend you to place them before, so we can easily see that this variable is an array:</p> <pre><code>int numbers[] ...\n</code></pre> <p>In order to access the elements of an array, we set the desired index inside the square brackets, starting at position 0. This way we can, for instance, specify a concrete value for each element in the array:</p> <pre><code>numbers[0] = 3;\nnumbers[1] = 6;\n...\n</code></pre> <p>We can also use these indexes to check the concrete value of a position:</p> <pre><code>System.out.println(numbers[1]);\nSystem.out.println(numbers[2] * numbers[4]);\n</code></pre> <p>In order to check the total number of elements of an array, we can use its <code>length</code> property. For instance, inside a <code>for</code> loop:</p> <pre><code>for (int i = 0; i &lt; numbers.length; i++)\n{\n    System.out.println(numbers[i]);\n}\n</code></pre> <p>Alternatively, we can use this <code>for</code> structure to explore the contents of the array. This structure is particularly useful if we just want to check (not change) the values of the array:</p> <pre><code>for (int n: numbers)\n{\n    System.out.println(n);\n}\n</code></pre> <p>Finally, we can set the initial values of the array when we declare it, placing these values into curly braces, separated by commas:</p> <pre><code>int[] numbers = {1, 2, 3, 4};       // Array of 4 numbers\n</code></pre>"},{"location":"03a.html#11-array-search","title":"1.1. Array search","text":"<p>If we want to search a given value inside an array, we usually explore the array from the beginning to the end, looking for that value. We may need to:</p> <ul> <li>Determine if a given value exists in the array. In this case, we can finish as soon as we find this value in the array. For instance, this code checks if number 15 exists in an integer array. Note that we use a <code>while</code> loop along with a boolean variable to stop checkin whenever we find the value:</li> </ul> <pre><code>boolean found = false;\nint i = 0;\nwhile (!found &amp;&amp; i &lt; numbers.length)\n{\n    if (numbers[i] == 15)\n    {\n        found = true;\n    }\n    else\n    {\n        i++;\n    }\n}\n\nif (found)\n{\n    System.out.println(\"Number found at position \" + i);\n}\nelse\n{\n    System.out.println(\"Number not found\";\n}\n</code></pre> <ul> <li>Check how many times a value exists in an array. In this second case, we need to explore the whole array. For instance, this code counts the occurrences of number 15 in an integer array. To do this, we can better use a <code>for</code> structure with a counter:</li> </ul> <pre><code>int counter = 0;\nfor (int i = 0; i &lt; numbers.length; i++)\n{\n    if (numbers[i] == 15)\n    {\n        counter++;\n    }\n}\n\nSystem.out.println(\"Numbe 15 has been found \" + counter + \" times\");\n</code></pre> <p>Looking for minimum / maximum</p> <p>In some situations, we may need to find the maximum or minimum value in an array. An appropriate approach for this consists in:</p> <ol> <li>Assign this minimum/maximum value to position 0. In other words, we suppose that this first number will be the minimum or maximum we are looking for.</li> <li>Explore the rest of the array (from position 1) and check if there is a number that exceeds previous minimum/maximum. If so, we need to update this minimum/maximum.</li> </ol> <p>This example finds the maximum value in an integer array called numbers:</p> <pre><code>int maximum = numbers[0];\nfor (int i = 1; i &lt; numbers.length; i++)\n{\n    if (numbers[i] &gt; maximum)\n    {\n        maximum = numbers[i];\n    }\n}\n\nSystem.out.println(\"The maximum is \" + maximum);\n</code></pre>"},{"location":"03a.html#12-array-sort","title":"1.2. Array sort","text":"<p>Sorting arrays is a task that consists in placing each value in its appropriate position, according to a sorting criteria. For instance, if we want to sort an integer array in ascending order, we need to make sure that every number is placed before the numbers that are higher.</p> <p>There are many different algorithms to face this task. One of the most common are the bubble algorithm and the direct exchange algorithm.</p> <p>Bubble algorithm it compares two consecutive numbers of the array and, if they are not ordered, it swaps their values. At the end of this process, the highest/lowest value will be placed at the end of the array (depending on whether we are sorting in ascending or descending order). We need to replace this process N times to sort the N values of the array. This is the algorithm in Java to sort an array in ascending order:</p> <pre><code>for (int i = 0; i &lt; numbers.length; i++)\n{\n    for (int j = 0; j &lt; numbers.length - i - 1; j++)\n    {\n        if (numbers[j] &gt; numbers[j+1])\n        {\n            int aux = numbers[i];\n            numbers[i] = numbers[j];\n            numbers[j] = aux;\n        }\n    }\n}\n</code></pre> <p>Note that, in every iteration of j variable, we finish one position before previous iteration, because the latest positions of the array have already been sorted in earlier iterations.</p> <p>The direct exchange algorithm explores the whole array for every position i, looking for for the lowest/highest element, and places this element in this i position. This is the algorithm in Java for ascending order:</p> <pre><code>for (int i = 0; i &lt; numbers.length - 1; i++)\n{\n    for (int j = i + 1; j &lt; numbers.length; j++)\n    {\n        if (numbers[i] &gt; numbers[j])\n        {\n            int aux = numbers[i];\n            numbers[i] = numbers[j];\n            numbers[j] = aux;\n        }\n    }\n}\n</code></pre> <p>Note that j index is always greater than i index, so if element at position i is greater than element at position j, we need to swap their values to keep the array sorted.</p> <p>All these sorting algorithms have a complexity of O(n<sup>2</sup>), which means that, for an array of size n we need to do n<sup>2</sup> iterations, approximately, to sort the whole array. There are other approaches, such as the quicksort algorithm, which are faster, but much more difficult to understand and type.</p> <p>Also, Java provides an automatic sorting method for arrays, through <code>Arrays.sort</code> instruction. If array is made of simple data (such as integers, strings or floats, for instance), this instruction automatically sorts the array in ascending order. We need to import <code>java.util</code> package in order to use this instruction.</p> <pre><code>import java.util.Arrays;\n...\nint[] numbers = { 4, 6, 2, 8, 3};\nArrays.sort(numbers);\n</code></pre>"},{"location":"03a.html#2-bidimensional-arrays","title":"2. Bidimensional arrays","text":"<p>Although we can use unidimensional arrays for most of the tasks that we can do with arrays, in some situations we may need to store the information in a table, for instance, with its rows and columns, or store different sequences of data in separate indexes. To do this, we need to use bidimensional arrays.</p> <p>In bidimensional arrays we need two indexes: one to refer to the row we are interested, and another one to point at the column inside this row. We need two pairs of square brackets when we declare a bidimensional array. Inside each pair of brackets we specify the total number of rows and columns of the array, respectively:</p> <pre><code>int[][] table = new int[3][10];     // 3 rows, 10 columns\n</code></pre> <p>We refer to each column by its row number, and then column number (both starting at 0):</p> <pre><code>table[0][2] = 2;        // 1st row, 3rd column\ntable[2][8] = 12;       // 3rd row, 9th column\n</code></pre> <p>If we want to explore bidimensional arrays, we need a nested loop: In the outer loop we can explore rows/columns, and in the inner loop we explore the opposite. We can use the <code>length</code> property of each dimension to determine its size. This example shows the contents of an array row by row:</p> <pre><code>for (int i = 0; i &lt; table.length; i++)\n{\n    for (int j = 0; j &lt; table[i].length; j++)\n    {\n        System.out.print(table[i][j] + \" \");\n    }\n    System.out.println();\n}\n</code></pre> <p>Note that <code>table.length</code> stores the number of rows, and <code>table[i].length</code> the number of columns for row i.</p> <p>Alternatively, we can also establish a different number of columns for each row. This is called an array of arrays. To do this, we need to leave empty the second pair of square brackets when we declare the array:</p> <pre><code>int[][] data = new int[3][];        // 3 rows\n</code></pre> <p>Then, we need to go row by row establishing the number of columns for this row:</p> <pre><code>data[0] = new int[3];       // 1st row: 3 columns\ndata[1] = new int[5];       // 2nd row: 5 columns\ndata[2] = new int[8];       // 3rd row: 8 columns\n</code></pre> <p>We can also establish the default values of the whole array in the same way that we did for unidimensional arrays. In this case, the data of each row is enclosed in curly braces as well:</p> <pre><code>int[][] someMoreData = {\n    {1, 2, 3},\n    {4, 5, 6, 7},\n    {8, 9}\n};\n</code></pre> <p>Exercise 1</p> <p>Create a program called MatrixAddition that asks the user to enter two bidimensional matrices or tables of 3 rows and columns, and then prints the result of adding them. In order to add two matrices, you must do it cell by cell:</p> <pre><code>result[i][j] = matrixA[i][j] + matrixB[i][j]\n</code></pre> <p>Exercise 2</p> <p>Create a program called MarkCount that asks the user to enter 10 marks (integers between 0 and 10). The program must output how many marks of each type have been typed. For instance, if the user types these marks: 1, 7, 5, 7, 2, 6, 7, 3, 5, 8, then the program must output: </p> <pre><code>Marks per category: \n0: 0 marks\n1: 1 marks\n2: 1 marks\n3: 1 marks\n4: 0 marks\n5: 2 marks\n6: 1 marks\n7: 3 marks\n8: 1 marks\n9: 0 marks\n10: 0 marks\n</code></pre>"},{"location":"03b.html","title":"Enums","text":"<p>Enum types represent a data type with a finite or concrete set of possible values. For instance, the seasons of the year, of the days of the week are good examples of enums.</p>"},{"location":"03b.html#1-basic-enum-management","title":"1. Basic enum management","text":"<p>If we want to declare an enum type, we use the word <code>enum</code> followed by a name. This will be the name that we will use to refer to this data type when we declare variables. Then, between curly braces, we specify the values that this enum can have. </p> <p>For instance, this way we can declare an enum for the days of the week:</p> <pre><code>enum dayOfWeek { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, \n    FRIDAY, SATURDAY, SUNDAY};\n</code></pre> <p>This enum should be declared out of the class, as an external data type. Then, we can declare variables of this enum in our program, this way:</p> <pre><code>dayOfWeek aDay = dayOfWeek.FRIDAY;\n</code></pre> <p>Every value inside an enum as a numeric index associated, starting at 0. This way, we can either work with the enum value or with its inner index, if we want to, using <code>ordinal()</code> instruction.</p> <pre><code>dayOfWeek aDay = dayOfWeek.FRIDAY;\nSystem.out.println(aDay);           // Prints FRIDAY\nSystem.out.println(aDay.ordinal()); // Prints 4\n</code></pre> <p>If we want to read an enum value from the keyboard, this value can be either the enum value (for instance, FRIDAY), or the ordinal number for this value (4, if we want to refer to FRIDAY). We can use <code>valueOf</code> or <code>value</code> instructions, respectively, to match the value typed by the user with the value stored in the enum:</p> <pre><code>Scanner sc = new Scanner(System.in);\nSystem.out.println(\"Enter a day of the week:\");\ndayOfWeek aDay1 = dayOfWeek.valueOf(sc.nextLine());  // If user types FRIDAY\ndayOfWeek aDay2 = dayOfWeek.values()[sc.nextInt()];  // If user types 4\n</code></pre> <p>Exercise 1</p> <p>Create a program called MonthEnum.java that defines an enum to store the months of the year. Then, ask the user to type a month and tell him/her the number of days of this month (we assume that February has 28 days).</p>"},{"location":"03c.html","title":"Strings","text":"<p>If we want to work with strings in Java, we have the <code>String</code> class, with some useful methods that we can use: convert to upper or lower case, get a substring, find a text... You can have a whole list of available methods in the String official documentation. Let's explore some of them.</p>"},{"location":"03c.html#1-basic-string-management","title":"1. Basic string management","text":"<p>We can create a string in many different ways: with a constant value, asking the user to type something...</p> <pre><code>String text = \"Hello world\";\nString name = scanner.nextLine();\n</code></pre> <p>We can also concatenate strings with the <code>+</code> operator, or in some cases with <code>+=</code> operator (if we want to add a string at the end of another).</p> <pre><code>text = text + \", how are you?\";\n</code></pre> <p>We can't treat a string as a char array (as in C++ or C#), and get to each character with the corresponding index between square brackets. If we want to get the character at a given position, we need to use the <code>charAt</code> method. We can also get the length of a string with its <code>length()</code> method.</p> <pre><code>for (int i = 0; i &lt; text.length(); i++)\n    System.out.println(text.charAt(i));\n</code></pre> <p>Regarding conversions, we can easily convert a non-string variable into a string just joining it with an empty string. Alternatively, we can also use <code>String.valueof</code> instruction for this purpose:</p> <pre><code>int number = 23;\nString text = \"\" + number;\nString text2 = String.valueOf(number);\n</code></pre>"},{"location":"03c.html#2-some-advanced-operations-with-strings","title":"2. Some advanced operations with strings","text":"<p>In this section we are going to explore some more advanced features of strings, such as comparing strings, taking substrings in a string variable, splitting a string in parts and so on.</p>"},{"location":"03c.html#21-string-comparison","title":"2.1. String comparison","text":"<p>We can compare two strings (alphabetically) in some different ways. If we want to know which is greater or lower, we can use the <code>compareTo</code> method. It returns a negative number if the string on the left is lower, 0 if both strings are equal, or a positive number if the string on the right is lower.</p> <pre><code>if (text1.compareTo(text2) &lt; 0)\n    System.out.println(\"Second text is greater\");\n</code></pre> <p>If we want to check if two strings are equal, we use the <code>equals</code> method (remember, we must NOT use the <code>==</code> comparator for this purpose). We can also use <code>equalsIgnoreCase</code> method if we want to ignore if strings are in uppercase or lowercase.</p> <pre><code>if (text1.equals(text2))\n    System.out.println(\"Texts are equal\");\n\nif (\"hello\".equalsIgnoreCase(\"HELLO\"))\n    System.out.println(\"Text are equal ignoring cases\");\n</code></pre>"},{"location":"03c.html#22-finding-texts-in-strings","title":"2.2. Finding texts in strings","text":"<p>We have a wide variety of instructions inside string elements to find texts. For instance, if we only want to know if a text contains a given subtext, we can use <code>contains</code> method, that returns a boolean:</p> <pre><code>if (text.contains(\"hello\"))\n    System.out.println(\"There is a 'hello' in the text\");\n</code></pre> <p>If we want to know the index at which a given subtext appears, we can choose among <code>indexOf</code> (gets the first occurrence of the subtext, or -1 if it does not exist) or <code>lastIndexOf</code> (gets the last occurrence of the subtext, or -1 if it does not exist)</p> <pre><code>int pos = text.indexOf(\"hello\");\nif (pos &gt;= 0)\n    System.out.println(\"There is a 'hello' at position\" + pos);\n</code></pre> <p>If we want to know if a text starts with a given prefix or ends with a given suffix, we use the <code>startsWith</code> or <code>endsWith</code> methods, which return a boolean</p> <pre><code>if (text.startsWith(\"Hello\"))\n    System.out.println(\"Text starts with 'Hello'\");\n</code></pre>"},{"location":"03c.html#23-string-conversions","title":"2.3. String conversions","text":"<p>We can convert the whole string to upper and lower case with <code>toUpperCase</code> and <code>toLowerCase</code> methods:</p> <pre><code>String text = \"Hello world\";\nString textUpper = text.toUpperCase(); // \"HELLO WORLD\"\n</code></pre> <p>We can get a substring of a given string with the <code>substring</code> method. It has two parameters: the index from which we must start getting the substring (starting at 0), and the index at which we must stop getting the string (excluded). If this second parameter is omitted, it returns the resulting string from the initial index to the end of the string. For instance, <code>\"Welcome\".substring(3, 5)</code> returns \"co\" (indexes 3 and 4 of the string).</p> <p>We can replace a substring with another one with the <code>replace</code> method. It has two arguments: the old text and the new text, and it returns the resulting string. It replaces EVERY occurrence of the old string with the new string.</p> <pre><code>String result = text.replace(\"Hello\", \"Good morning\");\n</code></pre> <p>There are some other options for this purpose, such as <code>replaceAll</code> method, which uses regular expressions to match the text to be replaced, or <code>replaceFirst</code>, which only replaces the first occurrence of the old text with the new one.</p> <p>We can split a string using a delimiter with the <code>split</code> method. It returns an array with the resulting parts.</p> <pre><code>String text = \"Hello world\";\nString[] parts = text.split(\" \"); \n// Two parts, \"Hello\" and \"world\"\n</code></pre> <p>Finally, we can also do the opposite operation, this is, joining parts of a string with a common delimiter, using <code>String.join</code> method. We need to specify the delimiter, and then the array or sequence of texts to be joined.</p> <pre><code>String[] parts = {\"One\", \"Two\", \"Three\"};\nString result = String.join(\",\", parts);   // \"One,Two,Three\"\n</code></pre> <p>Exercise 1</p> <p>Create a program called SortJoin that asks the user to enter a list of names separated by whitespaces. Then, the program must split the string, sort the names alphabetically and output them separated by commas. For instance, if the user types this name list: <code>Susan Kailey William John</code>, then the program must output <code>John, Kailey, Susan, William</code>.</p> <p>Exercise 2</p> <p>Create a program called CheckMessages that asks the user to type 10 strings. The program must store them in an array, and then replace the text \"Eclipse\" with \"IntelliJ\" in every string that contains \"Eclipse\". The program must output the updated version of the strings stored in the array, once the replacement has been done.</p> <p>Exercise 3</p> <p>Create a program called LispChecker. LISP is a programming languages where every instruction is enclosed in parentheses. This could be a set of instructions in LISP:</p> <pre><code>(let ((new (x-point a y))))\n</code></pre> <p>You must implement a program that takes a string with LISP instructions (just one string) and then check if the parentheses are correct (this is, the number of opening parentheses and closing parentheses are the same).</p>"},{"location":"03c.html#3-strings-and-static-data","title":"3. Strings and static data","text":"<p>This section is about static data types. We have seen that these types don't change their size along program execution. However, we can increase or decrease the size of a string by concatenating or removing pieces of text. So, how can we say that a string is a static data size?</p> <p>We need to take into account that Strings in Java are ALWAYS immutable, as in many other programming languages. So, every transformation that we need to do over a string needs to be assigned to a new (or old) variable. That's why methods such as <code>toUppeCase</code> or <code>substring</code> always return a new string, they never affect the original string. However, we can always re-assign the old string with this new value:</p> <pre><code>String text = \"Hello world\";\n\n// This way we don't affect original text\nString newText = text.toUpperCase();\n\n// This way we modify original variable, and it points\n// to this new text (old text is lost in memory)\ntext = text.toUpperCase();\n</code></pre> <p>Due to this, joining these instructions over strings is not very efficient, since we need to create a new string in memory for every new operation. Instead of this, we can also use StringBuilder element instead.</p>"},{"location":"03c.html#31-using-stringbuilder","title":"3.1. Using StringBuilder","text":"<p>Through <code>StringBuilder</code> element we can create editable strings. This increases the speed of certains operations, and decreases the use of memory. In order to create these elements, we just need to use <code>new</code> operator with the initial value of the string to be stored:</p> <pre><code>StringBuilder text = new StringBuilder(\"Hello\");\n</code></pre> <p>Then, we have some methods available to perform some editing tasks:</p> <ul> <li><code>append</code> method lets us add new strings at the end of the existing one, just like <code>+</code> operator does with original strings</li> <li><code>delete</code> method removes a fragment in the string, given the initial and final position to be removed.</li> <li><code>insert</code> method adds a new string in the middle of the existing one (to be more precise, at the given starting index)</li> <li><code>toString</code> method converts this StringBuilder element into a common String</li> <li>Besides, we have some other methods available, whose behavior is similar to the original methods in String: <code>charAt</code>, <code>length</code>, <code>indexOf</code>, <code>lastIndexOf</code>...</li> </ul> <p>Here you can find an example of usage:</p> <pre><code>StringBuilder text = new StringBuilder(\"Hello\");\ntext.append(\" world\");                  // text = \"Hello world\"\ntext.insert(5, \" my\");                  // text = \"Hello my world\"\nSystem.out.println(text.toString());    // \"Hello my world\"\nSystem.out.println(text.indexOf(\"my\")); // 6\ntext.delete(5, 8);                      // text = \"Hello world\"\n</code></pre>"},{"location":"03d.html","title":"Using regular expressions","text":"<p>A regular expression (or regex in its abbreviated form) is a sequence of special characters that lets us detect some patterns in texts. For instance, an id card made of 8 digits and an uppercase letter, or an e-mail containing a <code>@</code>. Using regular expressions, we can easily detect these patterns in a given text and, also, force a text to meet a given pattern when it's being entered by the user.</p>"},{"location":"03d.html#1-basic-regex-syntax","title":"1. Basic regex syntax","text":"<p>In order to work with regular expressions in Java, we need to use some classes from <code>java.util.regex</code> package. To be more precise, we are going to rely on:</p> <ul> <li><code>Pattern</code> class, that lets us define a given pattern for a regular expression</li> <li><code>Matcher</code> class, that lets us check if a givent text meets a given Pattern.</li> </ul>"},{"location":"03d.html#11-pattern-class","title":"1.1. Pattern class","text":"<p>Regarding <code>Pattern</code> class, there are a couple of interesting methods inside it that we need to manage:</p> <ul> <li><code>compile</code>: it creates a Pattern object for a given regular expression</li> <li><code>matcher</code>: it returns a Matcher object to match a pattern with a text</li> </ul>"},{"location":"03d.html#12-matcher-class","title":"1.2. Matcher class","text":"<p>Inside <code>Matcher</code> class, we can use these methods:</p> <ul> <li><code>find</code>: checks if a given pattern is found in a text</li> <li><code>matches</code>: checks if the whole text meets a pattern (not only a part of it). There is also a static method in Pattern class, <code>Pattern.matches</code> that produces the same result.</li> </ul>"},{"location":"03d.html#13-example","title":"1.3. Example","text":"<p>Let's check in the following example if a text contains a digit between 0 and 9. This digit can be represented by the symbol <code>\\d</code>, so we use it inside the pattern, this way:</p> <pre><code>String text = \"Hi, my name is Nacho and I'm 44 years old\";\nPattern p = Pattern.compile(\"\\\\d\");\nMatcher m = p.matcher(text);\n\nif (m.find())\n{\n    System.out.println(\"The text contains digit(s)\");\n}\nelse\n{\n    System.out.println(\"The text does not contain any digit\");\n}\n</code></pre> <p>Note that we need to escape the <code>\\</code> when we place it inside the string, as <code>\\\\d</code></p>"},{"location":"03d.html#14-some-basic-symbols","title":"1.4. Some basic symbols","text":"<p>In this table you can find some basic symbols that we can use inside patterns.</p> Symbol Meaning <code>x</code> 'x' character <code>\\t</code> Tabulation <code>\\n</code> New line <code>[abc]</code> Character 'a', 'b' or 'c' <code>[^abc]</code> Anything but characters 'a', 'b' or 'c' <code>[a-zA-Z]</code> Range from 'a' to 'z' or from 'A' to 'Z' <code>.</code> Any character <code>^</code> Beginning of line (there's nothing before) <code>$</code> End of line (there's nothing after) <code>\\d</code> Digit from 0 to 9 <code>\\D</code> Anything but a digit <code>\\s</code> Spacing char (white space, tab, new line...) <code>\\S</code> Anything but a spacing char <code>\\w</code> Alphanumeric char (letters, digits and underscore) <code>\\W</code> Anything but an alphanumeric char <code>(one|two)</code> Text 'one' or text 'two' <p>With these symbols, we can made expressions such as:</p> <ul> <li>Text finished with a dot (we need to escape the dot with <code>\\</code>):</li> </ul> <pre><code>Pattern p = Pattern.compile(\"\\\\.$\");\n</code></pre> <ul> <li>Text made of 4 digits</li> </ul> <pre><code>Pattern p = Pattern.compile(\"^\\\\d\\\\d\\\\d\\\\d$\");\n</code></pre> <ul> <li>The seasons of the year:</li> </ul> <pre><code>Pattern p = Pattern.compile(\"(winter|spring|summer|autumn)\");\n</code></pre> <p>Exercise 1</p> <p>Create a project called CarIDCheck that asks the user to enter a cad id, and checks if it's made of 4 digits followed by 3 uppercase letters. We are not going to check if these letters are vowels or not, we just check if they are uppercase.</p>"},{"location":"03d.html#2-some-complex-expressions","title":"2. Some complex expressions","text":"<p>In order to make some more complex expressions, we need to make use of some additional symbols in the pattern. To be more precise, we need to specify the cardinality of some parts of the expressions, in orde to shorten them. This is a list of cardinality symbols that you can use in your patterns:</p> Symbol Meaning <code>x?</code> x symbol appears 0 or 1 times <code>x+</code> x symbol appears 1 or more times <code>x*</code> x symbol appears 0 or more times <code>x{n}</code> x symbol appears n times <code>x{n,}</code> x symbol appears at least n times <code>x{n, m}</code> x symbol appears between n and m times (both included) <p>This way, we can easily check: </p> <ul> <li>If a text is made of 4 digits with this:</li> </ul> <pre><code>Pattern p = Pattern.copile(\"^\\\\d{4}$\");\n</code></pre> <ul> <li>An id card made of 8 digits and an uppercase letter:</li> </ul> <pre><code>Pattern p = Pattern.copile(\"^\\\\d{8}[A-Z]$\");\n</code></pre> <p>Exercise 2</p> <p>Repeat previous exercise using cardinality symbols</p> <p>Exercise 3</p> <p>Create a program called EmailChecker that asks the user to enter an e-mail and checks if it's valid. We will consider that a valid e-mail will be made of alphanumeric characters (at least one), followed by a <code>@</code>, one or more alphanumeric characters, a dot and one or more alphanumeric characters. So <code>myEmail@one.com</code> is a valid e-mail, but <code>myOtherMail@aaa</code> is not.</p>"},{"location":"03d.html#3-using-groups","title":"3. Using groups","text":"<p>Groups lets us isolate some parts of a text that meet a given pattern, so we can treat them later in the code. We can use <code>group</code> method inside <code>Matcher</code> class to detect groups, and each group must be defined between parentheses <code>(...)</code> in the pattern. Groups are explored from left to right.</p> <p>Let's see how groups work with the following example: we are going to get every sequence of 4 digits in a text:</p> <pre><code>String text = \"Einstein was born in 1879 and Edison in 1847\";\nPattern p = Pattern.compile(\"(\\\\d{4})\");\nMatcher m = p.Matcher(text);\n\nif (!m.find())\n{\n    System.out.println(\"The text has no sequence of 4 digits\");\n}\nelse\n{\n    do\n    {\n        String data = m.group();\n        System.out.println(\"Found \" + data);\n    }\n    while(m.find());\n}\n</code></pre> <p>As you can see, every time we call <code>group</code> method we move to next group identified in the text, until there are no more matches pending.</p>"},{"location":"03d.html#31-multiple-groups","title":"3.1. Multiple groups","text":"<p>We can define more than one group in a single expression. In this case, <code>group</code> method admits an additional parameter indicating which of the groups we are choosing (starting from 1).</p> <p>The following example identifies names and surnames in a text:</p> <pre><code>String text = \"Albert Einstein was born in 1879\" + \n    \" and Thomas Edison in 1847\";\nPattern p = Pattern.compile(\"([A-Z][a-z]+) ([A-Z][a-z]+)\");\nMatcher m = p.Matcher(text);\n\nif (!m.find())\n{\n    System.out.println(\"The text has no names\");\n}\nelse\n{\n    do\n    {\n        String name = m.group(1);\n        String surname = m.group(2);\n        System.out.println(\"Found \" + name + \" \" + surname);\n    }\n    while(m.find());\n}\n</code></pre> <p>It would output Found Albert Einstein in the first iteration and Found Thomas Edison in the second one.</p> <p>Exercise 4</p> <p>Create a program called HourIdentifier that looks for hours in a text. An hour is made of two digits, followed by <code>:</code>, and two digits. For instance, <code>08:45</code>. We are not going to check if the hour is valid or not, we just need to identify them. Then, store these hours in a list and show them in ascending order. </p>"},{"location":"04a.html","title":"Function definition","text":"<p>The programs that we have been typing so far are becoming more and more complex. It may be hard to maintain or keep clean a piece of code of some hundred lines and, besides, we may need to repeat the same piece of code in many parts of our program. In order to keep our code clean an reusable, we need to divide it into functions or modules. In this section we'll learn what a function is, how to define functions in Java and how to use them.</p>"},{"location":"04a.html#1-basic-function-management","title":"1. Basic function management","text":"<p>Functions let us arrange our code so that we can re-use a piece of code many times without having to duplicate the code. We just assign this piece of code a name (function name) and then we can call this code from other parts of our program. This paradigm is also called modular programming, since we define modules or functions to group our code in small subtasks, and call each subtask whenever we need it.</p> <p>If we want to use functions within a class, we can declare them as <code>public static</code> if we want to call them from anywhere. We will learn in next units how to declare other types of functions and how to set their visibility, but for now we are going to deal with public, static functions.</p> <p>When defining a function, we need to specify the return type (or <code>void</code> if the function does not return anything), the function name and a pair of parentheses. This function prints a welcome message in the screen:</p> <pre><code>public static void welcome()\n{\n    System.out.println(\"Hello, welcome to this program!\");\n}\n</code></pre> <p>We can call this function from any other function of the same class (including <code>main</code> function) by using the function name and the parentheses:</p> <pre><code>public static void main(String[] args)\n{\n    welcome();\n}\n</code></pre> <p>Note that function names always start in lower case in Java (in C#, they start in uppercase if they are public).</p>"},{"location":"04a.html#11-returning-values","title":"1.1. Returning values","text":"<p>Functions can return values. This values can be assigned to variables, or used in other expressions. In order to return a value from a function, its return type must be other than void, and we must use a <code>return</code> clause to specify the value returned. For instance, this function returns a welcome message:</p> <pre><code>public static string welcome()\n{\n    return \"Hello, welcome to this program!\";\n}\n</code></pre> <p>So, if we call this function from the main program, we will not see anything in the screen:</p> <pre><code>public static void main(String[] args)\n{\n    welcome();  // Nothing happens\n}\n</code></pre> <p>We need to assign the return value to a variable, or use it in another expression:</p> <pre><code>public static void main(String[] args)\n{\n    // Option 1\n    string result = welcome();\n    System.out.println(result);\n\n    // Option 2\n    System.out.println(welcome());\n}\n</code></pre>"},{"location":"04a.html#2-using-parameters","title":"2. Using parameters","text":"<p>Some functions need some additional data to do their job. These data can be passed to the function as parameters, some kind of variables that are specified within the parentheses, including the type of each parameter and its name. For instance:</p> <pre><code>public static void myOtherFunction (int a, String b)\n{\n    ...\n}\n</code></pre> <p>Then, whenever we need to call this function, we need to specify the values of these parameters, in the same order:</p> <pre><code>public static void main (String[] args)\n{\n    ...\n    myOtherFunction(3, \"Hello\");\n}\n</code></pre>"},{"location":"04a.html#21-parameters-by-value-or-by-reference","title":"2.1. Parameters by value or by reference","text":"<p>Passing a parameter by value means that we are passing a copy of the original value, so this original value can never be changed from within the function. This is the default situation for simple values, such as integers or floating point numbers:</p> <pre><code>public static void myFunction(int value)\n{\n    // This increment will have no effect after exiting the function\n    value = value + 1; \n    System.out.println(\"Inside function: \" + value);\n}\n\npublic static void main(String[] args)\n{\n    int number = 3;\n    myFunction(number);         // Inside function: 4\n    System.out.println(number); // 3\n}\n</code></pre> <p>However, complex data such as arrays are always passed by reference. This means that we are passing a reference or pointer to the original values, and we can change these values from within the function as long as we don't change the whole reference, this is, as long as we don't reassign the whole variable. Let's have a look at this example:</p> <pre><code>public static void myFunctionWithArray(int[] data)\n{\n    data[0] = 10;           // OK\n}\n\npublic static void myFunctionWithArray2(int[] data)\n{\n    data = {1, 2, 3, 4};    // No effect outside the function\n}\n\npublic static void main(String[] args)\n{\n    int[] numbers = {1, 1, 1, 1};\n    myFunctionWithArray(numbers);\n    // Here numbers = {10, 1, 1, 1}\n    myFunctionsWithArray2(numbers);\n    // Here numbers = {10, 1, 1, 1}\n}\n</code></pre> <p>The same happens with some other complex data, such as objects, as we will see in later units.</p>"},{"location":"04a.html#22-more-on-return-types","title":"2.2. More on return types","text":"<p>Let's have a look at this function. It returns the maximum value of its two input parameters:</p> <pre><code>public static int maximum(int n1, int n2)\n{\n    if (n1 &gt; n2)\n    {\n        return n1;\n    }\n    else\n    {\n        return n2;\n    }\n}\n</code></pre> <p>From the point of view of clean code, a function should only have ONE return point, so that it's easy for us to find out where this function ends. In order to meet this requirement, we can rewrite the function this way:</p> <pre><code>public static int maximum(int n1, int n2)\n{\n    int result = n1;\n    if (n2 &gt; n1)\n    {\n        result = n2;\n    }\n\n    return result;\n}\n</code></pre>"},{"location":"04a.html#23-global-and-local-variables","title":"2.3. Global and local variables","text":"<p>A global variable is a variable that has been defined outside of any function (and inside a class), so that it can be shared among all the functions of this class (and possibly other classes). In order for a variable to be global, we should declare it as public and static for now:</p> <pre><code>class MyClass\n{\n    public static int myGlobalVariable;\n\n    ...\n}\n</code></pre> <p>A local variable is a variable that has been defined inside a function, and it does not exist outside this function:</p> <pre><code>class MyClass\n{\n    public static void aFunction()\n    {\n        int number = 3;\n        anotherFunction();\n    }\n\n    public static void anotherFunction()\n    {\n        System.out.println(number); // Error: number does not exist here\n    }\n}\n</code></pre> <p>Global variables are not a good choice, generally, since they can produce side effects. This is, we can accidentally change their values from any function of our program. The most recommended way of dealing with variables is to declare them as local, and pass them to other functions as parameters:</p> <pre><code>class MyClass\n{\n    public static void aFunction()\n    {\n        int number = 3;\n        anotherFunction(number);\n    }\n\n    public static void anotherFunction(int n)\n    {\n        System.out.println(n); // OK\n    }\n}\n</code></pre> <p>Exercise 1</p> <p>Create a program called Palindrome with a function called <code>isPalindrome</code>. This function will take a string as a parameter and return a boolean indicating if this string is a palindrome (this is, a string that can be read the same backward as forward, ignoring upper or lower case, and whitespaces). Test this function from the main function with the texts Hannah, Too hot to hoot and Java is the best language (this last text is NOT a palindrome).</p> <p>Exercise 2</p> <p>Create a program called CountOcurrences with a function called <code>countString</code>. This function will take two strings a and b, and an integer n as parameters, and it will return a boolean indicating if the string b is contained at least n times in the main string a. Try it from the main function with the main string a = <code>This string is just a sample string</code>, the substring b = <code>string</code> and the number n = 2 (it should return <code>true</code>).</p>"},{"location":"04a.html#3-recursion","title":"3. Recursion","text":"<p>Recursion is the ability of a function to solve a task by calling itself multiple times with simpler versions of the problem to be solved.</p>"},{"location":"04a.html#31-main-components-of-a-recursive-function","title":"3.1. Main components of a recursive function","text":"<p>In every recursive function we can find two components:</p> <ul> <li>Base case: the simplest problem that we can find, in which recursive calls finish. There can be more than one base case in a recursive function, but there must be at least one of them.</li> <li>Recursive case: every internal call to the same function with a simpler version of the problem.</li> </ul> <p>So, whenever we try to solve a problem recursively, we need to think about the simplest value of this problem, and make the function tend to this simplest value through consecutive calls.</p>"},{"location":"04a.html#32-some-introductory-examples","title":"3.2. Some introductory examples","text":"<p>Let's get started with recursion by analyzing some simple examples...</p>"},{"location":"04a.html#321-the-factorial","title":"3.2.1. The factorial","text":"<p>Factorial is a mathematical operation that consists in multiplying a number by all its descending sequence up to 1. For instance factorial of number 5 can be calculated as 5 * 4 * 3 * 2 * 1, and it's represented as 5!.</p> <p>We can see the factorial as a simple multiplication sequence, or as a recursive expression: the factorial of a given number can be decomposed in two parts: the number itself and the factorial of the previous number. So, factorial of number 5 can be seen as 5 multiplied by the factorial of number 4:</p> <pre><code>5 * 4 * 3 * 2 * 1 = 5 * 4!\n</code></pre> <p>Recursively, we can also calculate the factorials of all the subsequent numbers:</p> <pre><code>4! = 4 * 3!\n3! = 3 * 2!\n2! = 2 * 1!\n1! = 1\n</code></pre> <p>As soon as we get to number 1, we've found our base case, the simplest number to calculate the factorial. After this point is reached, we can go back and calculate the rest of pending operations:</p> <pre><code>1! = 1\n2! = 2 * 1 = 2\n3! = 3 * 2 = 6\n4! = 4 * 6 = 24\n5! = 5 * 24 = 120\n</code></pre> <p>We can represent this as a recursive function in Java, this way:</p> <pre><code>public static int factorial(int number)\n{\n    // Base case\n    if (number == 1)\n    {\n        return 1;\n    }\n    // Recursive case\n    else\n    {\n        return number * factorial(number - 1);\n    }\n}\n</code></pre> <p>Alternatively, we can also express this operation as an iterative algorithm as well:</p> <pre><code>public static inf factorialIterative(int number)\n{\n    int result = 1;\n    for (int i = number; i &gt; 1; i--)\n    {\n        result = result * i;\n    }\n    return result;\n}\n</code></pre> <p>Note</p> <p>Recursive functions are an exception to the rule of a single return point. In recursive functions, we usually find a return point for the base case and another return point for the recursive case.</p>"},{"location":"04a.html#322-fibonacci-series","title":"3.2.2. Fibonacci series","text":"<p>Let's see another example. Fibonacci series starts with numbers 0 and 1, and then next number is always generated as the sum of two previous numbers. So, we have this sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21...</p> <p>How could we calculate the nth number of the Fibonacci series? We could define a function like this:</p> <pre><code>public static int fibonacci(int n)\n{\n    int previous, previous2, result;\n\n    if (n == 0)\n    {\n        result = 0;\n    }\n    else if (n == 1)\n    {\n        result = 1;\n    }\n    else\n    {\n        previous2 = 0;\n        previous = 1;\n        for (int i = 2; i &lt;= n; i++)\n        {\n            result = previous + previous2;\n            previous2 = previous;\n            previous = result;\n        }\n    }\n\n    return result;\n}\n</code></pre> <p>However, if we represent this function recursively, we can get this:</p> <pre><code>public static int fibonacci(int n)\n{\n    if (n == 0 || n == 1)\n    {\n        return n;\n    }\n    else\n    {\n        return fibonacci(n-1) + fibonacci(n-2);\n    }\n}\n</code></pre> <p>So, in some situations, recursion helps us write a shorter code to solve a problem.</p> <p>Exercise 3</p> <p>Create a program called CountDigits with a function called <code>countDigits</code> that receives a number and, recursively, counts the number of digit that this number has. Try it with number 1252 (4 digits), from the main function.</p> <p>Exercise 4</p> <p>Create a program called PalindromeRecursive with a function called <code>isPalindrome</code> that receives a string (with only alphabetical letters from a to z in lower case) and recursively determines if this string is palindrome or not, returning a boolean with the result. Try it with the same input values suggested for Exercise 1.</p>"},{"location":"04a.html#4-using-main-arguments","title":"4. Using main arguments","text":"<p>As you may have noticed, main function has a String array as parameter:</p> <pre><code>public static void main(String[] args)\n{\n    ...\n}\n</code></pre> <p>This means that we can pass as many arguments as we need to this main function from the command line. The first argument will be placed at index 0, the second argument at index 1 and so on.</p> <pre><code>public static void main(String[] args)\n{\n    if (args.length &gt; 0)\n        System.out.println(\"Received \" + args.length + \" args.\");\n}\n</code></pre> <p>For instance, if we try to run a program called Main with this command line:</p> <pre><code>java Main Nacho 20\n</code></pre> <p>Then <code>args[0]</code> will be Nacho and <code>args[1]</code> will be 20.</p> <p>Exercise 5</p> <p>Repeat exercise 3 in another program called CountDigitsMain in which the number to be checked will be passed from the command line.</p>"},{"location":"04b.html","title":"Useful Java functions","text":"<p>In this document we are going to learn some useful functions provided by Java core, that we can use in our programs.</p>"},{"location":"04b.html#1-math-functions","title":"1. Math functions","text":"<p><code>Math</code> element from Java JDK provides a set of useful functions to do some mathematical operations. Here you can see some of the most useful ones:</p> <ul> <li><code>Math.sqrt(n)</code> returns the square root of the parameter n provided. It returns a <code>double</code> value.</li> <li><code>Math.pow(b, e)</code> returns the value of the first argument b raised to the power of the second argument e. It also returns a <code>double</code> value.</li> <li><code>Math.abs(n)</code> returns the absolute value of the number n, in the same data type of n.</li> <li><code>Math.log(n)</code> returns the natural logarithm (base e) of a double value.</li> <li>...</li> </ul> <p>You can check all the functions available in the official documentation of this element.</p> <p>Exercise 1</p> <p>Create a program called Equation.java that tries to solve a 2nd degree equation ax^2 + bx + c = 0, given the values of a, b and c. Here you can see the general formula:</p>"},{"location":"04b.html#2-generating-random-numbers","title":"2. Generating random numbers","text":"<p>Random numbers are really useful in some particular kind of programs, such as some simple games (lottery, bingo, board games...). We can generate them in Java in two different ways.</p>"},{"location":"04b.html#21-using-mathrandom","title":"2.1. Using Math.random","text":"<p>We can use <code>Math.random()</code> function. It returns a random double value between 0 and 1 (1 is not included). So we can use it to just generate a double value in this range:</p> <pre><code>double randomValue = Math.random();\n</code></pre> <p>If we want to generate a random number for a wider range, we can just multiply the result by this range, and even typecast the result. This code generates a random integer between 0 and 10 (excluding 10):</p> <pre><code>int randomValue = (int)(Math.random() * 10);\n</code></pre> <p>Finally, if we want to move the range to another interval, we just need to sum or substract an initial value. This example generates a number between 20 and 30 (excluding 30):</p> <pre><code>int randomValue = 20 + (int)(Math.random() * 10);\n</code></pre>"},{"location":"04b.html#22-using-random","title":"2.2. Using Random","text":"<p>Alternatively, we can use <code>Random</code> data type to generate random values. First of all, we need to import this class (<code>java.util.Random</code>). Then, we need to initialize a Random variable (this step must be done only ONCE in the program execution), and then we can generate as many random values as we need. To do this, we can use methods such as <code>nextInt</code> inside the random variable, defining the interval for the number to be generated.</p> <p>This example generates a random number between 0 and 5 (5 is not included):</p> <pre><code>import java.util.Random;\n...\nRandom r = new Random();\nint randomValue = r.nextInt(5);\n</code></pre> <p>This example generates a random integer between 10 and 20 (20 is not included):</p> <pre><code>import java.util.Random;\n...\nRandom r = new Random();\nint randomValue = 10 + r.nextInt(10);\n</code></pre> <p>You can learn more about Random elementos in the official API.</p> <p>Exercise 2</p> <p>Create a program called NumberGuess.java that generates a random number between 1 and 50 (both included) and give the user 5 attempts to guess the number. After each attempt, the program must inform the user if the secret number is greater or lower than the one specified by the user.</p>"},{"location":"04c.html","title":"Exception management","text":"<p>Along the development of a Java program we can find two types of errors: compilation errors and runtime errors. The first ones are detected by the compiler as we type the code, whereas runtime errors are difficult to predict (in general): network errors, dividing by zero, file not found... Most of these runtime errors can be handled by exceptions.</p>"},{"location":"04c.html#1-what-is-an-exception","title":"1. What is an exception?","text":"<p>An exception is an event that happens during the execution of a program and makes it exit from its normal instruction flow. This way, we can deal with the error in a smart way, by separating the \"normal\" code from the error itself. Whenever an exception occurs, we say that it has been thrown, and we can choose among propagating it (throwing it again) or catching it and process the error. We will see these two options in a few minutes.</p>"},{"location":"04c.html#11-exception-types","title":"1.1. Exception types","text":"<p>Runtime errors can be of two main types:</p> <ul> <li>Errors: in this case, we talk about fatal errors that happen during the execution of a program, such as hardware errors, memory errors... These errors can't be managed from within a Java application.</li> <li>Exceptions: they are non-critical errors that can be managed (files not found, parsing errors...). Inside this type of errors, we can talk about:<ul> <li>Runtime exceptions: they don't need to be catched, and they are difficult to predict, in general. For instance, assigning null to a variable, or going beyond the boundaries of an array.</li> <li>Checked exceptions: these exceptions need to be catched, or declared to be thrown. In other words, if we use a function that can throw these type of exceptions, the compiler will complain if we don't catch the exception or throw it again. For instance, whenever we call the <code>Thread.sleep</code> instruction, we need to catch or throw an <code>InterruptedException</code>.</li> </ul> </li> </ul> <p>However, every type of exception is a subtype of the <code>Exception</code> main type. This generic type stores the error message produced by the exception. There are some other subtypes that store more specific information. For instance, <code>ParseException</code> is a subtype of <code>Exception</code> that is thrown whenever data can't be properly parsed. It stores the error message along with the position where the error was found.</p>"},{"location":"04c.html#12-types-of-exception-management","title":"1.2. Types of exception management","text":"<p>Whenever an exception is caused in a program, we can decide how to treat it. Basically, we have two options in our code:</p> <ul> <li>Catch the exception. This means that exception is \"destroyed\" and we can show a controlled, customized error message instead.</li> <li>Throw the exception. In this case, we don't want to care about the exception, and we delegate in another piece of code to treat it.</li> </ul> <p>In next sections of this document we will learn how to manage these two options.</p>"},{"location":"04c.html#2-catching-exceptions","title":"2. Catching exceptions","text":"<p>Whenever a piece of code can throw an exception, we can catch it by using a <code>try..catch</code> block. We put inside the <code>try</code> clause the code of our program that may produce an exception, and we use the <code>catch</code> clause to respond to the specified error. We can just output an error message, or return a given value, among other possible options.</p> <p>This example tries to convert a string into an integer value. If the conversion can't be done because the input is not valid, then a <code>NumberFormatException</code> will be thrown, and we can produce an appropriate error message in the <code>catch</code> clause.</p> <pre><code>int number;\nstring text = ... // Whatever value\n\ntry\n{\n    number = Integer.parseInt(text);\n} catch (NumberFormatException e) {\n    System.err.println(\"Error parsing text: \" + e.getMessage());\n}\n</code></pre> <p>The <code>getMessage</code> method gets the error message produced by the exception. See that we are using <code>System.err</code> instead of <code>System.in</code> because we are printing an error, and then we should use the default error output instead of the default \"normal\" output.</p> <p>We can also use <code>printStackTrace</code> method to print a complete stack trace of the error, so that we can see the call stack that have produced the error (this is, methods that have been called until the error was produced).</p> <pre><code>int number;\nstring text = ... // Whatever value\n\ntry\n{\n    number = Integer.parseInt(text);\n} catch (NumberFormatException e) {\n    e.printStackTrace();\n}\n</code></pre> <p>We can add as many <code>catch</code> clauses as we need, and each one can represent a specific exception type:</p> <pre><code>try\n{\n    // Code that may fail\n} catch (NumberFormatException e1) {\n    // Error message for number format\n} catch (ArithmeticException e2) {\n    // Error message for dividing by zero\n...\n} catch (Exception eN) {\n    // Error message for any other error\n}\n</code></pre> <p>However, we must put these <code>catch</code> clauses in order, so that the most generic ones are placed at the end, because the program will enter at the first <code>catch</code> clause that matches the exception produced. In other words, if we put the <code>catch(Exception)</code> clause at the beginning, the rest of clauses will have no effect, since any of them are subtypes of <code>Exception</code> and thus, they will be catched by the first clause.</p> <p>There are some instructions that force us to deal with a specific type of exception. For instance, if we call <code>Thread.sleep</code> instruction, the compiler will ask us to deal with an <code>InterruptedException</code>. We can do it this way:</p> <pre><code>try\n{\n    Thread.sleep(5000);\n} catch (InterruptedException e) {\n    System.err.println(\"Interruption during sleep: \" + e.getMessage());\n}\n</code></pre> <p>However, we can also use a generic <code>Exception</code> element in the <code>catch</code> clause to deal with any type of exception. We only need to specify concrete types of exceptions if we want to manage different <code>catch</code> clauses, and then, produce different error messages depending on the exception produced.</p>"},{"location":"04c.html#3-throwing-exceptions","title":"3. Throwing exceptions","text":"<p>The second way of managing an exception is throwing it. This way, we pass it to the next function in the stack call... until we reach the main function (in this function we should no longer throw exceptions, we must catch them). </p> <p>For instance, this function receives two numbers and returns the division n1 / n2. But if n2 is 0, we can't divide them, so in this case we can throw a new exception to indicate that data is not correct:</p> <pre><code>public static int divide (int n1, int n2)\n{\n    if (n2 == 0)\n        throw new ArithmeticException(\"Can't divide by zero\");\n    else\n        return n1 / n2;\n}\n</code></pre> <p>So, if we try to use this method in our program, we must be aware that an exception can be thrown, and catch it:</p> <pre><code>public static void anotherFunction()\n{\n    int number1, number2;\n\n    // ... Ask user to fill number1 and number2\n\n    try\n    {\n        int result = divide(number1, number2);\n    }\n    catch (ArithmeticException e)\n    {\n        System.err.println(\"Error: \" + e.getMessage());\n    }\n}\n</code></pre> <p>Now, let's have a look at this example:</p> <pre><code>public static void a() throws InterruptedException\n{\n    throw new InterruptedException (\"Exception in a\");\n}\n\npublic static void b() throws InterruptedException\n{\n    a();\n}\n\npublic static void c() throws InterruptedException\n{\n    b();\n}\n\npublic static void d() throws InterruptedException\n{\n    c();\n}\n\npublic static void main(String[] args)\n{\n    try\n    {\n        d();\n    } catch (InterruptedException e) {\n        System.err.println(\"Exception: \" + e.getMessage());\n    }\n}\n</code></pre> <p>This example produces an <code>InterruptedException</code> in function <code>a</code> (we can produce exceptions by throwing new exception elements of any type). Then, as <code>b</code> function calls <code>a</code> function, it is asked to either catch the exception or throw it. By adding the <code>throws</code> clause in the function definition, we explicitly say that this function can throw <code>InterruptedException</code> exceptions. This chain goes on with functions <code>c</code> and <code>d</code>. Finally, main function calls function <code>d</code>, and as this function can throw InterruptedExceptions, we need to catch the possible exception in main.</p> <p>All this chain of exception throwing have been originated from <code>a</code> function, since it throws a checked exception that needs to be catched or thrown. If this function had thrown a runtime exception (such as <code>NullPointerException</code>), then none of the <code>throws</code> clauses would have been necessary, since it is a non checked exception. The example would have been like this:</p> <pre><code>public static void a()\n{\n    throw new NullPointerException (\"Null pointer exception in a\");\n}\n\npublic static void b()\n{\n    a();\n}\n\npublic static void c()\n{\n    b();\n}\n\npublic static void d()\n{\n    c();\n}\n\npublic static void main(String[] args)\n{\n    d();\n}\n</code></pre> <p>However, if we try to run this last example, a <code>NullPointerException</code> exception will be produced in our console. As this is a non checked exception, we don't need to catch it but, as soon as it is produced, we should, to avoid these huge error messages in the console as we run the program:</p> <pre><code>Exception in thread \"main\" java.lang.NullPointerException: \nNull pointer exception in a\n    at Pruebas.a(Pruebas.java:6)\n    at Pruebas.b(Pruebas.java:11)\n    at Pruebas.c(Pruebas.java:16)\n    at Pruebas.d(Pruebas.java:21)\n    at Pruebas.main(Pruebas.java:26)\n</code></pre> <p>We can even throw (or declare to be thrown) as many exception types as we want, separated by commas in the <code>throws</code> clause. Then, we will need to catch all of them sooner or later:</p> <pre><code>public static void multipleExceptionsFunction()\nthrows IOException, InterruptedException\n{\n    ...\n    if (...)\n        throw new IOException(\"IOException produced\");\n    ...\n    if (...)\n        throw new InterruptedException(\"Interrupted!!\");\n}\n\n...\n\npublic static void anotherFunction()\n{\n    try\n    {\n        multipleExceptionsFunction();\n    } catch (IOException e1) {\n        System.err.println(...);\n    } catch (InterruptedException e2) {\n        System.err.println(...);\n    }\n}\n</code></pre> <p>Exercise 1</p> <p>Create a program called CalculateDensity that asks the user to type a weight (in grams) and a volume (in liters). Then, the program must output the density, which is calculated by dividing weight / volume. The program must catch every type of possible exception: <code>NumberFormatException</code> and <code>ArithmeticException</code> whenever they can be thrown. You can only use <code>Scanner.nextLine</code> method to get the user input in this exercise.</p> <p>Exercise 2</p> <p>Create a program called WaitApp with a function called waitSeconds that will receive a number of seconds (integer) as a parameter. Internally, this function will call <code>Thread.sleep</code> method to pause the program the given number of seconds (this function works with milliseconds, so you must convert seconds to milliseconds when calling it). As the <code>sleep</code> method can throw an <code>InterruptedException</code> element, you will need to deal with it. In this case, you are asked to throw the exception from waitSeconds method, and catch it in the main method, that will call waitSeconds with the number of seconds specified as a main parameter (inside the <code>String[] args</code> parameter). After waiting the specified number of secods, the program will prompt a \"Finish\" message before exiting.</p>"},{"location":"05_overview.html","title":"Object oriented programming","text":""},{"location":"05_overview.html#classes-and-objects-in-java-additional-exercises","title":"Classes and objects in Java - Additional exercises","text":"<p>Exercise 1</p> <p>Create a project named Stores, and implement the following classes:</p> <ul> <li>An abstract class called <code>Store</code>. It will have an abstract method called <code>welcome</code>, two private fields (<code>cash</code> and <code>drinkPrice</code>, both double) and a constructor that will receive the <code>drinkPrice</code> and initialize <code>cash</code> to 0.0. It will also implement a method called <code>payDrinks(int numOfDrinks)</code> that will add to the <code>cash</code> variable the payment (number of drinks * price).</li> <li>A class called <code>LiquorStore</code> that will extend <code>Store</code> class. It will implement the <code>welcome</code> method to show the message \"Welcome to the liquor store\", and it will have a new private field called <code>tax</code> (an integer). Its constructor will receive the <code>drinkPrice</code> and <code>tax</code> values, calling the parent's constructor when necessary. This class will also override <code>payDrinks(int)</code> calling first the parent's method (pay without tax), and then adding the tax value to the cash field.</li> <li>A <code>Main</code> class with the <code>main</code> method. This method will:</li> <li>Create a <code>LiquorStore</code> object with drinkPrice = 8.95\u20ac and tax = 20%. Pay for 10 drinks and print the cash to see if its value is 107.40\u20ac (print 2 decimal numbers).</li> <li>Instantiate a <code>Store</code> using an anonymous class. The drink price will be 8.95\u20ac and the <code>welcome</code> method will say \u201cWelcome to anonymous store! Our drink price is XX\u20ac\u201d (where XX will be the value of drinkPrice attribute, with 2 decimals). Call the <code>welcome</code> method and also pay for 10 drinks. Show the resulting cash (should be 89.50\u20ac). </li> <li>Implement getters and setters when needed</li> </ul> <p>Exercise 2</p> <p>Create a project named KillEnemies, and implement the following classes:</p> <ul> <li>Interface <code>Character</code>: With a method called <code>isEnemy()</code> that returns a boolean.</li> <li>Class <code>Friend</code>: Implements <code>Character</code>. <code>isEnemy()</code> returns false.</li> <li>Class <code>Enemy</code>: Implements <code>Character</code>. <code>isEnemy()</code> returns true. Also implements a method called <code>kill()</code> that shows this message: \"Ahhhggg, you killed me, bastard!\".</li> <li>Class <code>Main</code> containing the <code>main</code> method. You must create a list (<code>ArrayList</code>) of 10 <code>Character</code> objects (5 friends and 5 enemies), then, using <code>Collections.shuffle(List)</code>, randomize the order of the items. You have to travel through all characters checking if they are enemies, and if they are, you kill them (call <code>kill()</code> method). </li> </ul> <p>An example of execution message would be:</p> <pre><code>Character 0 is a friend! :-)\nCharacter 1 is a friend! :-)\nCharacter 2 is an enemy! kill it!\nAhhhggg, you killed me, bastard!\n...\n</code></pre>"},{"location":"05a.html","title":"Classes and objects in Java","text":"<p>When we talk about Object Oriented Programming (OOP), we are talking about a new approach to face software projects, in which we don't focus on what the program must do, but in which elements are part of the system, and how they interact. These elements are categorized in classes, and from each class we create objects in the program. In this document we will explain what a class is, and how to define them in Java to create objects.</p>"},{"location":"05a.html#1-classes-and-objects","title":"1. Classes and objects","text":"<p>Let's suppose that we are going to implement an application for bookshop management. In this library there are many books, and each one has an author, and some basic information about the book (title, number of pages, price...). The library has many registered users or customers that want to buy some books.</p> <p>If we start thinking how to implement this application with the elements that we have learnt so far, we would define some variables to store the information: maybe a string array to store book titles, another string array to store customer names... and so on. And then, we would define the functions to search for a book in the array, to look for user data to login...</p> <p>Object oriented programming changes the starting point of view of this project. Instead of thinking about functionality (book search, user login...) we just think about the different elements that will be part of the project. In this case, our application will have books, authors, customers... these elements will be the classes of our project. In other words, classes are templates that categorize the different elements of the application. </p> <p>For each class, we need to store some useful information. For instance, for every book we need to know the title, number of pages and price. This information are the attributes of each class. Once we know the attributes of a class, we can create objects of this class. An object is a concrete instance or representation of a class. We could create a book with a concrete title (e.g. \"Ender's game\"), a concrete number of pages (e.g. 321), and so on. And there can be many objects of a class when our application is running (in our case, we could have many books created in our bookshop). In the same way, we could define the attributes of the rest of classes (customers, authors...) and instantiate objects of each class.</p> <p>Every object in the application may need to do some operations. For instance, we may need to print the information of a book in the screen, and customers may need to search for books, or buy them. These operations are called methods of this class.</p> <p>So with object oriented programming we need to identify these elements of the application, and define the classes to represent them. Later, we will be able to create or instantiate objects of each class. Let's see how to do this in Java.</p>"},{"location":"05a.html#2-defining-classes-in-java","title":"2. Defining classes in Java","text":"<p>As you have seen before, every piece of code in Java is encapsulated in a class. We define classes in Java through the <code>class</code> word, asigning each class a name (usually in upper case). We usually place every class in its own source file, and this class must be public.</p> <p>Inside the class code, we can place the attributes of the class, also called instance variables. These variables are part of the class. For instance, this way we could define a <code>Book</code> class for our bookshop, with its own attributes:</p> <pre><code>class Book\n{\n    String title;\n    int numPages;\n    double price;\n}\n</code></pre>"},{"location":"05a.html#21-creating-objects","title":"2.1. Creating objects","text":"<p>Once we have defined our class(es), we can create objects of them. In order to do this, we need to declare a variable of the same type of the class, and use the <code>new</code> operator to create the object:</p> <pre><code>Book myBook = new Book();\n</code></pre> <p>At this point, <code>myBook</code> becomes an object of class <code>Book</code>, and it contains every attribute defined in this class. We can access each attribute using the <code>.</code> operator, and then check or modify its value:</p> <pre><code>Book myBook = new Book();\nmyBook.title = \"Ender's game\";\nmyBook.numPages = 321;\nmyBook.price = 11.95;\n</code></pre> <p>We can place this code in another class and do some more things with this object:</p> <pre><code>class BookExample\n{\n    public static void main(String[] args)\n    {\n        Book myBook = new Book();\n        myBook.title = \"Ender's game\";\n        myBook.numPages = 321;\n        myBook.price = 11.95;\n\n        System.out.println(\"Book information:\");\n        System.out.println(\"Title: \" + myBook.title);\n        System.out.println(\"Pages: \" + myBook.numPages);\n        System.out.println(\"Price: \" + myBook.price);\n    }\n}\n</code></pre> <p>Note</p> <p><code>main</code> method is usually defined in another class apart from the elements of the program. It makes sense, since this method does not belong to any of these classes.</p> <p>Note</p> <p>In Java, every source file must have a public class with the same name than the source file. In other words, if we create a source file called <code>MyClass.java</code>, there must be a public class called <code>MyClass</code> in this source file. There can be also other (non public) classes there, although this is not usual, unless we just want one source file in our project. In this case, the class with the main function must be the public class in the file.</p>"},{"location":"05a.html#3-defining-more-class-elements","title":"3. Defining more class elements","text":""},{"location":"05a.html#31-using-methods","title":"3.1. Using methods","text":"<p>If we think a little bit about previous example, what if we want to print the information of many books? We could either:</p> <ul> <li>Repeat the <code>System.out.println</code> instructions for every book</li> <li>Define a function in <code>BookExample</code> class to be called whenever we want to print the information of a book. In this case, we should pass the book as a parameter to this function in order to print the information.</li> </ul> <p>But there's one more option that we have not used by now. What if every book is in charge of printing its own information? This way, we could define a function inside <code>Book</code> class, and access directly to the information of each book:</p> <pre><code>class Book\n{\n    String title;\n    int numPages;\n    double price;\n\n    void printInformation()\n    {\n        System.out.println(\"Book information:\");\n        System.out.println(\"Title: \" + title);\n        System.out.println(\"Pages: \" + numPages);\n        System.out.println(\"Price: \" + price);\n    }\n}\n</code></pre> <p>Now, our main class just needs to call this function (which is a method of <code>Book</code> class) to invoke this behavior:</p> <pre><code>class BookExample\n{\n    public static void main(String[] args)\n    {\n        Book myBook = new Book();\n        myBook.title = \"Ender's game\";\n        myBook.numPages = 321;\n        myBook.price = 11.95;\n\n        myBook.printInformation();\n\n        Book myBook2 = new Book();\n        myBook2.title = \"The never ending story\";\n        myBook2.numPages = 525;\n        myBook2.price = 14.15;\n\n        myBook2.printInformation();        \n    }\n}\n</code></pre> <p>Note that methods are just functions belonging to a class. In this case, we don't need to use the <code>static</code> modifier (we will see in later documents what static really means). This is an instance method, this is, every object or instance of the class has its own method and this method access current object's information.</p>"},{"location":"05a.html#32-constructors","title":"3.2. Constructors","text":"<p>Let's go back to previous example. What if our book had 10 o 20 attributes? Do we have to manually set every attribute every time we instantiate an object? Fortunately, the answer to this question is NO. We can use constructors to initialize the objects when we create them. They have the same name than the class to which they belong, and they are defined like a method, but they don't have any return type.</p> <p>Inside the code of a constructor, we typically assign initial values to instance variables or attributes, and call any other method that may be useful at the beginning of the object's lifetime.</p> <p>Let's go on with our <code>Book</code> class. In this case, we are going to add a constructor with no parameters, also known as default constructor. We will use it whenever we need to create an object of this class.</p> <pre><code>class Book\n{\n    String title;\n    int numPages;\n    double price;\n\n    // Default constructor\n    Book()\n    {\n        title = \"\";\n        numPages = 0;\n        price = 0;\n    }\n\n    void printInformation()\n    {\n        System.out.println(\"Book information:\");\n        System.out.println(\"Title: \" + title);\n        System.out.println(\"Pages: \" + numPages);\n        System.out.println(\"Price: \" + price);\n    }\n}\n\nclass BookExample\n{\n    public static void main(String[] args)\n    {\n        Book myBook = new Book();\n        myBook.printInformation();\n\n        Book myBook2 = new Book();\n        myBook2.printInformation();        \n    }\n}\n</code></pre> <p>The output that we would get in this case is different, since we have not set the instance variables manually, but through the default constructor, so all of them are empty strings or 0.</p> <p>In some cases, we may need to assign some non-default values to the instance variables, so we use a constructor with parameters. Typically, each parameter corresponds to an instance variable or attribute.</p> <pre><code>class Book\n{\n    String title;\n    int numPages;\n    double price;\n\n    // Default constructor\n    Book()\n    {\n        title = \"\";\n        numPages = 0;\n        price = 0;\n    }\n\n    // Parameterized constructor\n    Book(String t, int n, float p)\n    {\n        title = t;\n        numPages = n;\n        price = p;\n    }\n\n    void printInformation()\n    {\n        System.out.println(\"Book information:\");\n        System.out.println(\"Title: \" + title);\n        System.out.println(\"Pages: \" + numPages);\n        System.out.println(\"Price: \" + price);\n    }\n}\n</code></pre> <p>Using this constructor, we would create a <code>Book</code> object as follows:</p> <pre><code>Book myBook = new Book(\"Ender's game\", 321, 11.95);\n</code></pre> <p>We can have as many constructors as we need. All of them will have the same name (the class name), but they will have different parameters.</p>"},{"location":"05a.html#33-visibility-and-encapsulation","title":"3.3. Visibility and encapsulation","text":"<p>Visibility is something essential in object oriented programming. It establishes which elements are visible from which other classes of our code. This is managed through access modifiers, special words that we can place before any attribute or method of our class (including constructors) to determine their visibility. To begin with, there are two main types of visibility:</p> <ul> <li>public: we will be able to access this member directly from any part of the code, including any other class.</li> <li>private modifier, we would only be able to access this member from other members of the same class. Out of this class, this member is not visible.</li> </ul> <p>Additionally, there are two more modifiers that we can use in Java applications:</p> <ul> <li>protected: we will use this modifier later, when we talk about inheritance.</li> <li>package: this is the default modifier if we don't use any. It means that every class from the same package can access this element. If we place many classes in the same source file, they belong to the same package, so we can access any package element of any of these classes.</li> </ul> <p>In general, class attributes should be defined as private, so that they can't be modified accidentally from other classes. However, class methods are usually public, so they can be called from any other class. Our <code>Book</code> class should be defined like this:</p> <pre><code>class Book\n{\n    private String title;\n    private int numPages;\n    private double price;\n\n    // Default constructor\n    public Book()\n    {\n        title = \"\";\n        numPages = 0;\n        price = 0;\n    }\n\n    // Parameterized constructor\n    public Book(String t, int n, float p)\n    {\n        title = t;\n        numPages = n;\n        price = p;\n    }\n\n    public void printInformation()\n    {\n        System.out.println(\"Book information:\");\n        System.out.println(\"Title: \" + title);\n        System.out.println(\"Pages: \" + numPages);\n        System.out.println(\"Price: \" + price);\n    }\n}\n</code></pre> <p>Now, lets try to modify our main function. If we try to do something like this now, we will get a compilation error:</p> <pre><code>class BookExample\n{\n    public static void main(String[] args)\n    {\n        Book myBook = new Book(\"Ender's game\", 321, 11.95);\n        System.out.println(\"This book is \" + myBook.title);\n    }\n}\n</code></pre> <p>The problem is that <code>title</code> attribute is private, so we can't access it from <code>BookExample</code> class. We need a way to access object's information from outer classes.</p>"},{"location":"05a.html#331-getters-and-setters","title":"3.3.1. Getters and setters","text":"<p>There's a specific set of methods that we can implement to access information. These methods are called getters and setters and we can use them to either get or modify each attribute. In general, getters are defined with get prefix followed by the attribute name to which they refer. These would be the getters for our <code>Book</code> class:</p> <pre><code>class Book\n{\n    private String title;\n    private int numPages;\n    private double price;\n\n    // Default constructor\n    public Book()\n    {\n        title = \"\";\n        numPages = 0;\n        price = 0;\n    }\n\n    // Parameterized constructor\n    public Book(String t, int n, float p)\n    {\n        title = t;\n        numPages = n;\n        price = p;\n    }\n\n    public void printInformation()\n    {\n        System.out.println(\"Book information:\");\n        System.out.println(\"Title: \" + title);\n        System.out.println(\"Pages: \" + numPages);\n        System.out.println(\"Price: \" + price);\n    }\n\n    // Getters\n    public String getTitle()\n    {\n        return title;\n    }\n\n    public int getNumPages()\n    {\n        return numPages;\n    }\n\n    public double getPrice()\n    {\n        return price;\n    }\n}\n</code></pre> <p>As you can see, each getter method just returns the associated attribute. We can use them in previous example to access book information:</p> <pre><code>class BookExample\n{\n    public static void main(String[] args)\n    {\n        Book myBook = new Book(\"Ender's game\", 321, 11.95);\n        System.out.println(\"This book is \" + myBook.getTitle());\n    }\n}\n</code></pre> <p>In the same way, setters let us modify the values of the attributes in a safe way. What if we try to assign a negative number of pages? Setter method can take care of this, and make sure that the value we are assigning is correct:</p> <pre><code>class Book\n{\n    private String title;\n    private int numPages;\n    private double price;\n\n    // Default constructor\n    public Book()\n    {\n        title = \"\";\n        numPages = 0;\n        price = 0;\n    }\n\n    // Parameterized constructor\n    public Book(String t, int n, float p)\n    {\n        title = t;\n        numPages = n;\n        price = p;\n    }\n\n    public void printInformation()\n    {\n        System.out.println(\"Book information:\");\n        System.out.println(\"Title: \" + title);\n        System.out.println(\"Pages: \" + numPages);\n        System.out.println(\"Price: \" + price);\n    }\n\n    // Getters\n\n    public String getTitle()\n    {\n        return title;\n    }\n\n    public int getNumPages()\n    {\n        return numPages;\n    }\n\n    public double getPrice()\n    {\n        return price;\n    }\n\n    // Setters\n\n    public void setTitle(String t)\n    {\n        title = t;\n    }\n\n    public void setNumPages(int n)\n    {\n        if (n &gt; 0)\n            numPages = n;\n    }\n\n    public void setPrice(double p)\n    {\n        if (p &gt;= 0)\n            price = p;\n    }\n}\n</code></pre> <p>Note that, for numPages and price attributes, we check if new value to be assigned (which is passed as a parameter to the method) is correct. This way, we protect the attribute from wrong values. This is called encapsulation (hide private attribute and only allow the access through getters and setters). We can even use these setters from the constructors, to make sure we also assign correct values there:</p> <pre><code>public Book(String t, int n, float p)\n{\n    title = t;\n    setNumPages(n);\n    setPrice(p);\n}\n</code></pre> <p>Exercise 1</p> <p>Create a source file called TeamsExample.java. Define a class called <code>Team</code> with some specific information about the teams, such as the team name and the foundation year. Add a constructor to this class to specify both attributes, and the corresponding getters and setters. Then, define a main class called <code>TeamsExample</code> with a main function that creates a Team object with the values of your choice, and prints the information in the screen.</p>"},{"location":"05a.html#4-other-aspects-regarding-classes-and-objects","title":"4. Other aspects regarding classes and objects","text":"<p>To finish with this introduction to class management in Java, let's check some additional concepts related with class definition and object instantiation.</p>"},{"location":"05a.html#41-more-about-constructors-and-attributes","title":"4.1. More about constructors and attributes","text":"<p>If we don't define any constructor in our class, Java automatically adds a default constructor (with no code nor parameters), so that we can instantiate objects of our class anyway. For instance, if we have this simple class:</p> <pre><code>public class Person \n{\n    String name;\n    int age;\n}\n</code></pre> <p>We can create a <code>Person</code> object like this, even if we have not specified such constructor:</p> <pre><code>Person p = new Person();\n</code></pre> <p>However, if we set any constructor in our class, then this default constructor that has been automatically added is no longer available. In other words, if we add this constructor to previous class:</p> <pre><code>public class Person \n{\n\n    String name;\n    int age;\n\n    public Person(String n, int a) \n    {\n        name = n;\n        age = a;\n    }\n}\n</code></pre> <p>Then we are forced to instantiate objects of our class with this constructor (or any other constructor that we have explicitly declared):</p> <pre><code>Person p = new Person(\"Nacho\", 40);   // OK\nPerson p2 = new Person();             // ERROR!\n</code></pre>"},{"location":"05a.html#411-default-values-for-attributes","title":"4.1.1. Default values for attributes","text":"<p>If we don't assign any value to a class attribute, it gets a default value depending on the data type. For numeric values (integers or real numbers), this value is <code>0</code>. Regarding characters, this value is the first character code <code>'\\u0000'</code>. Strings get <code>null</code> as its default value, and boolean variables are <code>false</code> by default. </p> <p>However, it is not a good practice to rely on these default values in our programs. It is better to assign an initial value to our variables instead.</p> <p>Note</p> <p>These default values are NOT applied to local variables. In other words, if we declare an integer variable inside a function or method, it will not be assigned a default value, and we will get a compilation error if we don't assign it an appropriate one. But, if we declare an array of integer values, they will all be set to 0 initially, even if the array is local to a method.</p>"},{"location":"05a.html#42-using-this","title":"4.2. Using this","text":"<p>In every class that we are implementing, we can use the reserved word this to refer to any internal element of the class, either an attribute, a method or a constructor. Its main typical use relies on constructors, to distinguish between the attributes and the constructor parameter(s) when they have the same name:</p> <pre><code>class Book\n{\n    private String title;\n    private int numPages;\n    private double price;\n\n    public Book(String title, int numPages, float price)\n    {\n        this.title = title;\n        this.numPages = numPages;\n        this.price = price;\n    }\n</code></pre> <p>But we can also use <code>this</code> in any other part of our code:</p> <pre><code>class Book \n{\n\n    ...\n\n    public void setPrice(double price) \n    {\n        if (price &gt;= 0)\n            this.price = price;\n    }\n}\n</code></pre> <p>Keep in mind that the usage of this is (usually) optional, but many IDEs generate code templates using this pattern, so you should get used to it.</p>"},{"location":"05a.html#43-arrays-of-objects","title":"4.3. Arrays of objects","text":"<p>We can define an array of objects of a class, like we did with primitive data in previous sections. For instance, this is how we would create an array to store up to 10 books:</p> <pre><code>Book[] books = new Book[10];\n</code></pre> <p>However, we need to instantiate (create) a new object for every position of the array in order to add it to this position:</p> <pre><code>books[0] = new Book(\"Ender's game\", 321, 11.95);\nbooks[1] = new Book(\"The never ending story\", 525, 14.15);\n...\n\n// Or with a loop:\nfor (int i = 0; i &lt; books.length; i++)\n{\n    books[i] = new Book(...);\n}\n</code></pre> <p>Exercise 2</p> <p>Create a program called VideoGameList.java to store objects of a class called <code>VideoGame</code> that you must define. For each videogame, we are going to store its title, genre and price. Add also the corresponding getters, setters and constructor to set these values. Define a main, public class called <code>VideoGameList</code> in the same source file. Then, in the main method of this class, create an array of 5 video games, ask the user to fill de information of each videogame, and then show the title of the cheapest and the most expensive video game of the array.</p>"},{"location":"05a.html#5-class-diagrams-in-java","title":"5. Class diagrams in Java","text":"<p>Class diagrams are a powerful tool in software engineering in order to graphically represent the classes of a project and their relationships. You can learn more about class diagrams here. As you can see, classes in these diagrams are represented by a box divided in 3 sections: one to specify the class name, another one for the attributes, and the last one for the methods (including constructors).</p> <p>Regarding Java, we also need to specify the data type of each attribute, along with the type of every method (including parameters and return type). This is an example of our <code>Book</code> class represented in a class diagram:</p> <p>Exercise 3</p> <p>Complete the class diagrams proposed along this document, including Java data types for every attribute, constructor or method.</p>"},{"location":"05b.html","title":"Class relatioships","text":"<p>Classes are not isolated elements in a program, usually. Objects of a class need to interact with objects of another class in many different ways, and that's how relationship between classes are formalized. In this document we are going to see the main relationships that we can establish between classes: association, inheritance and dependency.</p>"},{"location":"05b.html#1-class-associations","title":"1. Class associations","text":"<p>Association is a relationship between two classes, in which one of them is part of the elements of the other one, this is, an object of one of the classes is an attribute or instance variable of the other class. It is usually represented in the code with a reference to the contained object or a collection or array of those objects. If we take back our example of a bookshop, we could say that a book has an author. Then, we can define a new class called <code>Author</code> with some attributes, such as the name and year of birth:</p> <pre><code>class Author \n{\n    private String name;\n    private int yearBirth;\n\n    public Author(String name, int yearBirth) \n    {\n        this.name = name;\n        this.yearBirth = yearBirth;\n    }\n\n    public String getName() \n    {\n        return name;\n    }\n\n    public void setName(String name) \n    {\n        this.name = name;\n    }\n\n    public int getYearBirth() {\n        return yearBirth;\n    }\n\n    public void setYearBirth(int yearBirth) {\n        this.yearBirth = yearBirth;\n    }\n}\n</code></pre> <p>We can establish a Has-A relationship between these two classes (a book has an author), so we define an association between them. To do this, our <code>Book</code> class will have an additional attribute to store the author of this book (we assume that every book has one, and only one, author). We need to add a new parameter to set the author from the constructor, and the corresponding getter and setter for this new attribute.</p> <pre><code>class Book \n{    \n    private String title;\n    private int numPages;\n    private double price;\n    private Author author;\n\n    public Book(String title, int numPages, double price, Author author) \n    {\n        this.title = title;\n        this.numPages = numPages;\n        this.price = price;\n        this.author = author;\n    }\n\n    ...\n\n    public Author getAuthor() \n    {\n        return author;\n    }\n\n    public void setAuthor(Author author) \n    {\n        this.author = author;\n    }\n}\n</code></pre> <p>Regarding our main program, we can define an <code>Author</code> object and associate it to a given book. Then, we can print the typical information of the book... but also author's information, such as author's name:</p> <pre><code>public class BookExample \n{    \n    public static void main(String[] args) \n    {\n        Author a = new Author(\"J.R.R. Tolkien\", 1892);\n\n        // The lord of the Rings, 850 pages, 13.50 eur, Tolkien\n        Book b = new Book(\"The lord of the Rings\", 850, 13.50, a);\n\n        // Print book title and author's name\n        System.out.println(b.getTitle());\n        System.out.println(b.getAuthor().getName());\n    }\n}\n</code></pre> <p>Note that, if we want to associate the same author to more than one book, we just need to use the same object, instead of creating/repeating the object again for every new book.</p> <pre><code>Author a1 = new Author(\"J.R.R. Tolkien\", 1892);\nAuthor a2 = new Author(\"J.R.R. Tolkien\", 1892);  \n// a2 is not the same than a1 (different objects in memory)\n\nBook b1 = new Book(\"The lord of the Rings\", 850, 13.50, a1);\nBook b2 = new Book(\"The hobbit\", 345, 8.76, a2);  // Different author\nBook b3 = new Book(\"The hobbit\", 345, 8.76, a1);  // Same author\n</code></pre> <p>Exercise 1</p> <p>Improve exercise TeamsExample.java from previous document in another source file called TeamsExample2.java. Now every team will have an array of 5 players. Add a new class called <code>Player</code> to the source file. For each player, we need to define his/her name, age and back number. Add the corresponding constructor and getters/setters. Then, modify <code>Team</code> class to store 5 Player objects, and adapt your main function to create a team with all the players inside it. Print the information of the team, including the players that belong to it.</p> <p>Exercise 2</p> <p>Improve exercise VideoGameList.java from previous document in another source file called VideoGameList2.java. Now, every video game has a Company that created it. For every company, we need to store its name and the foundation year. Associate a company to each video game, so that some video games can share the same company object. Then, modify the main application to specify the company information for every videogame (besides video game initial data). Make sure that you share the same Company object among all the video games belonging to the same company.</p>"},{"location":"05b.html#11-association-navigability","title":"1.1. Association navigability","text":"<p>Associations are (or can be) bi-directional. In a class diagram, they are represented by a continuous line joining both clases involved, including the cardinality of each one in the relationship. In our case, a Book has one author, and an author can have many books. This can be represented like this:</p> <p>However, if we don't specify it, associations are (by default) bi-directional. This means that we can retrieve the author of a book from the book object (we can do this, already), but we can also retrieve the list of books of an author from the author object. This last part of the relationship is not implemented in our example, so, unless we want to implement it, we need to represent this association as unidirectional, by adding an arrow pointing to <code>Author</code> class. This means that we can get the author from a book object, but not the opposite. The arrow can be placed at either the line or the association name.</p> <p>The programmer can decide if an association needs to be bi-directional or not, so only one of the classes (or both) will be related with the other one.</p> <p>Let's have a look at this example: we have a <code>House</code> class to represent houses. From each class, we want to know the address, and the total number of rooms. Each house has a living room, so we use a <code>LivingRoom</code> class to represent it. We store the total area of the living room. We can establish a one-to-one relationship between these classes (a house has one living room, and a living room belongs to one house):</p> <p>Now, we are going to represent this bi-directional relationship in Java. First of all, we add a <code>LivingRoom</code> object as attribute in <code>House</code> class, and we assign it in the constructor:</p> <pre><code>class House\n{\n    private String address;\n    private int rooms;\n    private LivingRoom livingRoom;\n\n    public House(String address, int rooms, LivingRoom livingRoom)\n    {\n        this.address = address;\n        this.rooms = rooms;\n        this.livingRoom = livingRoom;\n    }\n\n    public String getAddress()\n    {\n        return address;\n    }\n\n    public void setAddress(String address)\n    {\n        this.address = address;\n    }\n\n    public int getRooms()\n    {\n        return rooms;\n    }\n\n    public void setRooms(int rooms)\n    {\n        this.rooms = rooms;\n    }\n\n    public LivingRoom getLivingRoom()\n    {\n        return livingRoom;\n    }\n\n    public void setLivingRoom(LivingRoom livingRoom)\n    {\n        this.livingRoom = livingRoom;\n    }\n}\n</code></pre> <p>Next, we try to do the same with <code>LivingRoom</code> class (we add a <code>House</code> object and try to assign it in the constructor):</p> <pre><code>class LivingRoom\n{\n    private int area;\n    private House house;\n\n    public LivingRoom(int area, House house)\n    {\n        this.area = area;\n        this.house = house;\n    }\n\n    public int getArea()\n    {\n        return area;\n    }\n\n    public void setArea(int area)\n    {\n        this.area = area;\n    }\n\n    public House getHouse()\n    {\n        return house;\n    }\n\n    public void setHouse(House house)\n    {\n        this.house = house;\n    }\n}\n</code></pre> <p>But let's try to create both objects from a main program:</p> <pre><code>LivingRoom lr = new LivingRoom(40, ???);    // Where's the house??\nHouse h = new House(\"Java Street\", 3, lr);  // LivingRoom is OK\n</code></pre> <p>As you can see, one of the constructors is missing some information. When we want to establish a bi-directional association between two classes, one of them can be set in the constructor, but the other one (the first object that we create) must wait. So the constructor of <code>LivingRoom</code> class does not need a <code>House</code> parameter:</p> <pre><code>public LivingRoom(int area)\n{\n    this.area = area;\n    // House remains unassigned\n}\n</code></pre> <p>Then, we have two options to assign the house to a living room:</p> <ul> <li>We call the setter from <code>LivingRoom</code> once the house has been created:</li> </ul> <pre><code>LivingRoom lr = new LivingRoom(40);\nHouse h = new House(\"Java Street\", 3, lr);\nlr.setHouse(h);\n</code></pre> <ul> <li>We can do this automatically in the house constructor, as soon as we assign the living room to it:</li> </ul> <pre><code>public House(String address, int rooms, LivingRoom livingRoom)\n{\n    this.address = address;\n    this.rooms = rooms;\n    this.livingRoom = livingRoom;\n    // Assign the livingRoom to this house\n    this.livingRoom.setHouse(this);\n}\n</code></pre> <p>If we use this last way, we don't need any additional outer code. As soon as we instantiate both objects, they are automatically associated:</p> <pre><code>LivingRoom lr = new LivingRoom(40);\nHouse h = new House(\"Java Street\", 3, lr);\n// At this point, association is already bi-directional\n</code></pre> <p>Exercise 3</p> <p>Create a source file called BookAssociation.java. Add the <code>Book</code> and <code>Author</code> class that we have already implemented in previous example, and try to make this association bi-directional. In this case, you need to add a <code>Book</code> array as an attribute in <code>Author</code> class, and add the corresponding code to add books to each author's array.</p>"},{"location":"05b.html#12-aggregations-and-compositions","title":"1.2. Aggregations and compositions","text":"<p>There are two special types of associations: compositions and aggregations. In both, one of the classes is considered as a whole thing, and the other one is a part of this whole thing. But... how to distinguish between composition and aggregation? Let's see it with some simple examples:</p> <ul> <li>Composition: we use it when an object is an indivisible part of another object. For example, a <code>Room</code> is part of a <code>House</code> (and only of that house), a <code>Square</code> is part of a <code>Chessboard</code>, and so on. The main characteristic of this type of relationship is that when we destroy the main object (the whole thing), all objects that are part of it are also destroyed.</li> <li>Aggregation: we use it when an object is part of another object (or maybe part of two or more objects) and it can exist without the object that contains it. An example of this would be a <code>Player</code>, who is part of a <code>Team</code> (or maybe more), or a <code>Student</code>, who belongs to a <code>Classrom</code> (or more). In these cases when the <code>Team</code> or the <code>Classroom</code> no longer exists, players and students continue to exist, and they can join other team/classroom.</li> </ul> <p>Composition and aggregation in practice</p> <p>In practice, the way we define the aggregation or composition depends on the programming language that we are using. But, in general, if the internal attribute or instance variable that makes the composition or aggregation can't be accessed from out of the containing class, then we have a composition. Otherwise, we have an aggregation. Let's see this with the following example: we define a <code>Car</code> class that has an object of type <code>Engine</code>. If we want to define a composition between these classes, we would do it this way:</p> <pre><code>class Car \n{\n    private final Engine engine;\n\n    public Car(EngineParams params) \n    {\n        engine = new Engine(params);\n    }\n}\n</code></pre> <p>Note that we create the <code>Engine</code> object inside the <code>Car</code> class, by using some parameters specified in the <code>EngineParams</code> object. This object may contain some simple data about the engine, such as power, or fuel consumption. In this case, if the <code>Car</code> object is destroyed, then the <code>Engine</code> object will be destroyed as well. There's no way to access the engine beyond this class. So, this is a composition.</p> <p>However, if we need to define an aggregation between <code>Car</code> class and <code>Engine</code> class, then we do it like this:</p> <pre><code>class Car \n{\n    private Engine engine;\n\n    public Car(Engine engine) \n    {\n        this.engine = engine;\n    }\n\n    public Engine getEngine()\n    {\n        return engine;\n    }\n\n    ...\n}\n</code></pre> <p>In this case, we are using an external object of type <code>Engine</code> to create the internal <code>Engine</code> object of the car (we pass this external object as a parameter to the constructor), so the engine can exist without the car: if we destroy the car, the external engine that we used in the constructor will keep on existing. This can be useful if we want to use the engine in another car, once the old one is destroyed.</p> <p>Note that aggregations and simple associations are implemented in the same way in Java programs. Compositions are more tricky and, unless we have a good reason to implement them, they can also act as aggregations.</p>"},{"location":"05b.html#2-class-inheritance","title":"2. Class inheritance","text":"<p>We use inheritance when we want to create a new class that takes all the features of another one, adding its particular ones. For instance, if we have an <code>Animal</code> class with a set of attributes (name, weight...) and methods, we can inherit from it to create a new class called <code>Dog</code> that will also have all these features, and we can add some additional ones, such as a <code>bark()</code> method.</p> <p>We have seen in previous sections of this document how to identify an association, by finding a Has-A relationship between the classes involved. When talking about inheritance, we identify it with an Is-A relationship, so that one class is a subtype of another class. In other words, it shares the features of the ancestor and introduces some new ones. One example of this is a <code>Car</code>, which is a subtype of <code>Vehicle</code>. Another could be a <code>ComputerClassroom</code>, which is a subtype of <code>Classroom</code> that also has computers in it. </p> <p>When we want a class to inherit the features from another class in Java we use the reserved word <code>extends</code> in the new class (also called child class or subclass), referring to the class from which we want to extend (also called parent class or superclass). </p> <pre><code>class Dog extends Animal\n{\n    ...\n}\n</code></pre> <pre><code>class Car extends Vehicle\n{\n    ...\n}\n</code></pre> <p>Let's go back to our bookshop example. What if we want to add information for a specific type of book, such as comics? We can add, for instance, if they are in color or not (grayscale), and also the volume number for a comic series. We could create a brand new class with all the information, like this one:</p> <pre><code>class Comic\n{\n    private String title;\n    private int numPages;\n    private double price;\n    private boolean color;\n    private int volumeNumber;\n\n    // Constructors, getters, setters and so on...\n}\n</code></pre> <p>But, as a comic is a subtype of book, we can inherit from <code>Book</code> class and automatically include all the elements of this class (this is, the title, number of pages, price, getters, setters...). Then, we only need to care about the new, specific information for comic elements:</p> <pre><code>class Comic extends Book\n{\n    private boolean color;\n    private int volumeNumber;\n\n    public Comic(String title, int numPages, double price,\n        boolean color, int volumeNumber)\n    {\n        this.title = title;\n        this.numPages = numPages;\n        this.price = price;\n        this.color = color;\n        this.volumeNumber = volumeNumber;\n    }\n\n    public boolean getColor()\n    {\n        return color;\n    }\n\n    public void setColor(boolean color)\n    {\n        this.color = color;\n    }\n\n    public int getVolumeNumber()\n    {\n        return volumeNumber;\n    }\n\n    public void setVolumeNumber(int volumeNumber)\n    {\n        this.volumeNumber = volumeNumber;\n    }\n}\n</code></pre>"},{"location":"05b.html#21-visibility-and-inheritance","title":"2.1. Visibility and inheritance","text":"<p>Note that, in the constructor, we need to specify EVERY attribute for the object that we are creating. As comic extends book functionality, we need to provide the title, number of pages and price, along with the color and volume number. However, there's a problem if we try to compile and run previous code: title, number of pages and price are private members of <code>Book</code> class, so they can't be accessed from outer classes. We should not declare them public, since it's not recommended. Fortunately, there's an additional, intermediate access level that we can use, which is protected.</p> <p>We use the <code>protected</code> access modifier to let child classes access parent information. It's generally used in attributes of a parent class, such as our <code>Book</code> class. We change the visibility this way:</p> <pre><code>class Book\n{\n    protected String title;\n    protected int numPages;\n    protected double price;\n\n    // The rest of code does not change\n}\n</code></pre> <p>So, to sum up, now that we have learnt what inheritance means, there are four different visibility levels in Java. Here you can see them from higher to lower:</p> <ul> <li>public elements can be accessed from any other part of the code (including other classes and packages)</li> <li>protected elements can only be accessed from any subclass of current class, or any class from the same package than current class</li> <li>package (default): elements are only accessible from the same package.</li> <li>private elements can only be accessed from current class</li> </ul> <p>Let's see all these modifiers in an example:</p> <pre><code>public class MyClass\n{\n    // Accessible everywhere\n    public int number;\n    // Accessible from subclasses or same package\n    protected String name;\n    // Only accessible from this class\n    private float average;\n    // Package level, accessible from same package\n    char symbol;\n</code></pre>"},{"location":"05b.html#22-overriding-parents-behavior-using-super","title":"2.2. Overriding parent's behavior. Using super","text":"<p>When we define a class that is a subtype of another class using inheritance, we can modify or override the behavior of parent methods in child class. For instance, <code>printInformation</code> method in <code>Book</code> class just prints the basic information (title, pages and price):</p> <pre><code>public void printInformation()\n{\n    System.out.println(\"Book information:\");\n    System.out.println(\"Title: \" + title);\n    System.out.println(\"Pages: \" + numPages);\n    System.out.println(\"Price: \" + price);\n}\n</code></pre> <p>But, in this new class, we need to add specific information about the comic. So we can write again this method in <code>Comic</code> class, and add an annotation called <code>@Override</code> to specify that this method belongs to parent class, but we are changing its behavior in child class:</p> <pre><code>class Comic extends Book\n{\n    ...\n\n    @Override\n    public void printInformation()\n    {\n        System.out.println(\"Book information:\");\n        System.out.println(\"Title: \" + title);\n        System.out.println(\"Pages: \" + numPages);\n        System.out.println(\"Price: \" + price);\n        System.out.println(\"Color/Grayscale: \" + \n            (color?\"Color\":\"Grayscale\"));\n        System.out.println(\"Volume: \" + volumeNumber);\n    }\n}\n</code></pre> <p>Moreover, we can make use of a specific reserved word called <code>super</code> to get to a parent's element. In this case, we are repeating the same code of parent's <code>printInformation</code> method, so we can just call this parent's method using <code>super</code>:</p> <pre><code>class Comic extends Book\n{\n    ...\n\n    @Override\n    public void printInformation()\n    {\n        super.printInformation();\n        System.out.println(\"Color/Grayscale: \" + \n            (color?\"Color\":\"Grayscale\"));\n        System.out.println(\"Volume: \" + volumeNumber);\n    }\n}\n</code></pre> <p>Note</p> <p><code>@Override</code> annotation is NOT compulsory for the program to compile, but you should use it in terms of code cleanliness, since you are specifying that this method does not belong to current class, it's just another version of an existing method in parent class.</p> <p>Constructors and inheritance</p> <p>Let's take a look again at <code>Comic</code> constructor in previous example:</p> <pre><code>public Comic(String title, int numPages, double price,\n    boolean color, int volumeNumber)\n{\n    this.title = title;\n    this.numPages = numPages;\n    this.price = price;\n    this.color = color;\n    this.volumeNumber = volumeNumber;\n}\n</code></pre> <p>Whenever we call a constructor from a subclass, the default constructor (i.e. the one with no parameters) of the superclass is automatically called (unless we use <code>super</code> to choose another constructor). So the code above will work as long as <code>Book</code> has a default constructor. Otherwise, we should:</p> <ul> <li>Define a default (even empty) constructor in <code>Book</code> class</li> <li>Choose with <code>super</code> another different parent constructor from <code>Comic</code> class. In this case, we can make use of the parameterized constructor of <code>Book</code> class and avoid assigning book's attributes from child class:</li> </ul> <pre><code>public Comic(String title, int numPages, double price,\n    boolean color, int volumeNumber)\n{\n    super(title, numPages, price);\n    this.color = color;\n    this.volumeNumber = volumeNumber;\n}\n</code></pre> <p>NOTE: if you use <code>super</code> instruction in a child constructor to invoke a specific constructor from parent class, this instruction MUST be the first in child constructor.</p>"},{"location":"05b.html#23-extending-object-class","title":"2.3. Extending Object class","text":"<p>We must take into account that, unless we specify another inheritance, every class in Java inherits from a global, parent class called <code>Object</code>. So, if our class does not inherit from any other class, it will automatically be a child of <code>Object</code> class, and thus, it can use or override methods from this class, such as <code>equals</code> or <code>toString</code>.</p> <p>If we override <code>toString</code> method, we can then convert our objects to strings, and then print them easily. Let's suppose that we override this method in a <code>Person</code> class, so that we return a string with the person's name and age between parentheses:</p> <pre><code>public class Person \n{\n    private String name;\n    private int age;\n\n    public Person(String n, int a) \n    {\n        name = n;\n        age = a;\n    }\n\n    @Override\n    public String toString() \n    {\n        return name + \" (\" + age + \" years)\";\n    }\n}\n</code></pre> <p>Then, we can easily print any <code>Person</code> object by simply calling <code>System.out.println</code> sentence:</p> <pre><code>Person p = new Person(\"Nacho\", 40);\nSystem.out.println(p); // Prints \"Nacho (40 years)\"\n</code></pre> <p>In the same way, we can also override <code>equals</code> method to determine if two <code>Person</code> objects are equal or not. In this example, we say that they are equal if they have the same name and age:</p> <pre><code>public class Person \n{\n    private String name;\n    private int age;\n\n    public Person(String n, int a) \n    {\n        name = n;\n        age = a;\n    }\n\n    @Override\n    public String toString() \n    {\n        return name + \" (\" + age + \" years)\";\n    }\n\n    @Override\n    public boolean equals(Object p) \n    {\n        Person p2 = (Person) p;\n        return this.name.equals(p.name) &amp;&amp; this.age == p.age;\n    }\n}\n</code></pre> <p>Then, we can compare two <code>Person</code> objects and determine if they are equal or not:</p> <pre><code>Person p1 = new Person(\"Nacho\", 40);\nPerson p2 = new Person(\"Nacho\", 39);\n\nif (p1.equals(p2)) \n{\n    System.out.println(\"They are equal!\");\n} else {\n    System.out.println(\"They are different\");\n}\n</code></pre>"},{"location":"05b.html#24-polymorphism","title":"2.4. Polymorphism","text":"<p>The term polymorphism refers to the ability of an element to have multiple shapes or appearances. For instance, a class can have many methods with the same name and different number or types of parameters. This is a kind of polymorphism which is also called method overload. We can call any of these method versions depending on our needs.</p> <p>Regarding object oriented programming, polymorphism is the ability of an object to behave like another object. This term is commonly used in inheritance to show that an object of any class can behave like any of its subclasses. For instance, a <code>Vehicle</code> object of previous examples could behave like a <code>Car</code> object, so we can, for instance:</p> <ul> <li>Instantiate a <code>Car</code> object from a <code>Vehicle</code> variable:</li> </ul> <pre><code>Vehicle myCar = new Car(...);\n</code></pre> <ul> <li>Use a <code>Car</code> object as a parameter to a method which gets a <code>Vehicle</code> object.</li> </ul> <pre><code>public void aMethod(Vehicle v) \n{\n    ...\n}\n\n...\nCar anotherCar = new Car(...);\naMethod(anotherCar);\n</code></pre> <ul> <li>Fill an array of <code>Vehicle</code> objects with any subtype of <code>Vehicle</code> in each position:</li> </ul> <pre><code>Vehicle[] vehicles = new Vehicle[10];\n\nvehicles[0] = new Vehicle(...);\nvehicles[1] = new Car(...);\nvehicles[2] = new Van(...);\n...\n</code></pre> <p>However, we must take into account that, when using polymorphism, the polymorphic variable can only access the methods of the type to which it belongs. In other words, if we create a <code>Car</code> object and store it in a <code>Vehicle</code> variable, then we will only be able to call methods or public elements from <code>Vehicle</code> class (not from <code>Car</code> class).</p> <pre><code>Vehicle myCar = new Car(...);\nmyCar.vehicleData();                          // OK\nSystem.out.println(myCar.getNumberOfDoors()); // ERROR\n</code></pre> <p>If we want to detect the concrete type of an object in order to access its own methods (and not only those inherited from parent class), then we can use <code>instanceof</code> operator, and then make a typecast to the concrete type:</p> <pre><code>Vehicle[] vehicles = new Vehicle[10];\n... // Fill the array with many vehicle types\nfor (int i = 0; i &lt; vehicles.length; i++)\n{\n    if (vehicles[i] instanceof Car)\n    {\n        System.out.println(((Car)vehicles[i]).getNumberOfDoors());\n    } else if (vehicles[i] instanceof Van) {\n        ...\n    } ...\n}\n</code></pre> <p>Exercise 4</p> <p>Improve previous exercise TeamsExample2.java in another source file called TeamsExample3.java. Add a new class called <code>Captain</code> which inherits from <code>Player</code> class. It will have an additional attribute specifying the years of experience of the captain. Define the corresponding constructor (using <code>super</code> to fill parent's data) and modify the main function to include a Captain object in the team.</p> <p>Exercise 5</p> <p>Improve previous exercise VideoGameList2.java in another source file called VideoGameList3.java. Add a new class called <code>PCVideoGame</code> which inherits from <code>VideoGame</code> class. It will have two new attributes called minimumRAM and minimumHD to store the minimum amount of RAM memory and hard disk space required to play the game (both integers). Define the corresponding constructor to set these values (and use <code>super</code> to call parent's constructor to set the inherited values). Then, add some PC video games to the array and repeat the same steps than in previous exercise.</p> <p>Also override <code>toString</code> method in VideoGame class so that we can print a video game in the screen with its information by symply calling <code>System.out.println</code>.</p>"},{"location":"05b.html#25-exceptions-and-inheritance","title":"2.5. Exceptions and inheritance","text":"<p>We can create our own exceptions by creating classes that inherit from <code>Exception</code> class. We can then throw a custom exception whenever we want and manage it in the method that throws it or send it up to the method it will return to.</p> <pre><code>public class CustomException extends Exception \n{\n    public CustomException(String msg) \n    {\n        super(msg);\n    }\n}\n\npublic class Store \n{\n    public void welcome() throws CustomException \n    {\n        throw new CustomException(\"Error, nobody can pass!\");\n    }\n}\n\npublic static void main(String[] args) \n{\n    Store store = new Store();\n    try \n    {\n        // This method can throw a CustomException\n        store.welcome(); \n    } catch (CustomException e) {\n        System.err.println(e.getMessage());\n    }\n}\n</code></pre> <p>Exercise 6</p> <p>Create a new source file called CustomException.java. In this source file you're going to implement:</p> <ul> <li>A class called <code>NegativeSubtractException</code>. This class will inherit from <code>Exception</code> and will be created when a subtraction result is negative. The constructor will receive 2 parameters (the two numbers that caused a negative subtraction result in order). The message generated will be: \"NegativeSubstractException: 'N1 - N2' result is negative\".</li> <li>In the main class create a static function that throws this type of custom exception. This method will be called <code>static int positiveSubtract(int n1, int n2)</code>, and will generate and throw this kind of exception if the result is negative. Within the main method call this method with parameters that would give a negative result and catch the corresponding exception, showing its message on console.</li> </ul>"},{"location":"05b.html#3-class-dependency","title":"3. Class dependency","text":"<p>Dependency relationship establishes a connection between two classes when one of them uses an object of the other one in some part of its code, BUT there's no association between them (this is, there's no attribute of one class in the other class).</p> <p>If we take a look at this example, there's a dependency between <code>Application</code> and <code>Window</code> class. This can be due to a method in <code>Application</code> class that receives a <code>Window</code> parameter, for instance. But there's no <code>Window</code> attribute in <code>Application</code> class:</p> <pre><code>class Application\n{\n    ...\n\n    public void aMethod(Window w)\n    {\n        ...\n    }\n}\n</code></pre> <p>Also, there could be a piece of code inside a method that instantiates a Window object. In this case, there would also be a dependency relationship between these classes:</p> <pre><code>class Application\n{\n    ...\n\n    public void aMethod()\n    {\n        Window w = new Window(...);\n        ...\n    }\n}\n</code></pre>"},{"location":"05c.html","title":"Managing complex projects in IntelliJ","text":"<p>Now that you have learnt what a class is and the main relationships that we can establish between classes, you may think that a real life project will usually consist of several classes, with their corresponding source files... and you are right.</p> <p>As soon as our Java application has more than one class, then simple IDEs such as Geany can have some problems to deal with all the classes: whenever we compile a class, we need to take into account the rest of the classes related with it, and this can be a tough job.</p> <p>Fortunately, advanced IDEs such as IntelliJ, Eclipse or NetBeans (among others) lets us handle complex projects easily. We just need to create a new project from those IDEs (typically a new Java project), and choose the project name.</p>"},{"location":"05c.html#1-project-management-in-intellij","title":"1. Project management in IntelliJ","text":"<p>Regarding IntelliJ, here you can find a quick overview on how to install it and create your first projects. In this section we are going to go deeply into how to use this IDE to develop projects easily.</p>"},{"location":"05c.html#11-arranging-classes-in-packages","title":"1.1. Arranging classes in packages","text":"<p>Packages are a way to arrange our classes in a project or library, so that each one (or a group of them) belongs to a given package. In other programming languages, such as C#, packages are called namespaces, but the purpose of these terms is equivalent.</p> <p>A package name consists of one or more words, separated by points. Each point establishes a new package sublevel. So, if we define the package <code>javatest</code>, then this is a first level package, but if we define a package called <code>mypackage.utils</code>, then there is a first level package called <code>mypackage</code>, and inside this package there is a second level package called <code>utils</code>. </p> <p>Whenever we create a package in Java, a new folder is physically created in the hard drive, with the same name than the package. If the package has more than one word (more than one level), then every subpackage will have its own subfolder. According to previous example, if we define <code>mypackage.utils</code> package, then a folder called <code>mypackage</code> will be created, and then a subfolder called <code>utils</code> inside <code>mypackage</code> will be created as well.</p> <p>We can add packages to our IntelliJ project by right clicking on the <code>src</code> folder, where all our source code will be placed. Then, we choose New &gt; Package context menu, and specify the package name:</p>"},{"location":"05c.html#12-adding-classes-and-elements","title":"1.2. Adding classes and elements","text":"<p>We can add classes to a package by right clicking on the package name and choosing New &gt; Java Class context menu. Then, a dialog will be shown to specify the class name and type (by default, IntelliJ considers that it will be a class, but it can also be an interface, or a JavaFX application, among other options).</p> <p>Finally the new class will be visible in the Project panel on the left, and we can edit it in the code editor:</p> <p>It is important to always assign a class to a package. Otherwise, they will belong to a default package and it may be difficult to find it in order to compile it with the rest of classes.</p>"},{"location":"05c.html#2-code-generation","title":"2. Code generation","text":"<p>If we use IDEs such as IntelliJ or other similar ones, they can help us add some code automatically to our classes. For instance, if we define the class name and its instance variables or attributes, we can auto-generate the constructor(s), or the getters and setters, or override some methods from parent class, if we want to. Regarding IntelliJ, we need to choose Code &gt; Generate option from the upper menu. Then, we can choose which piece of code we want to generate: a constructor, getters and setters... and then, we can even choose which attributes are involved in this constructor, getter/setter and so on.</p> <p>For the following exercises, you have to keep in mind the class diagrams proposed in the exercises of this document.</p> <p>Exercise 1</p> <p>Create a new Java Project in IntelliJ called VideoGames and place the code of Exercise 5 of previous document in this project, separating each class in its own source file, and following these rules:</p> <ul> <li>Create a package called <code>videogames.main</code> for the main class</li> <li>Create a package called <code>videogames.data</code> for <code>VideoGame</code>, <code>Company</code> and <code>PCVideoGame</code> classes</li> </ul> <p>Exercise 2</p> <p>Create a new Java Project in IntelliJ called Ships, and write the code to represent the class diagram defined in the Exercise 1 of the specified document.</p> <p>Exercise 3</p> <p>Create a new Java Project in IntelliJ called VideoGameCharacters, and write the code to represent the class diagram defined in the Exercise 2 of the specified document.</p> <p>Exercise 4</p> <p>Create a new Java Project in IntelliJ called Blog, and write the code to represent the class diagram defined in the Exercise 3 of the specified document.</p> <p>Exercise 5</p> <p>Create a new Java Project in IntelliJ called CulturalOrganization, and write the code to represent the class diagram defined in the Exercise 4 of the specified document.</p>"},{"location":"05d.html","title":"Using static and final","text":"<p>Along previous sections, we've been using static and final words in some parts of our code. It's now time to explain what they exactly mean.</p>"},{"location":"05d.html#1-static-elements","title":"1. Static elements","text":"<p>static modifier defines elements that belong to the class itself, and not to any specific object of the class. For instance, if we define a static attribute:</p> <pre><code>public class MyClass \n{\n    static int count = 0;\n}\n</code></pre> <p>Then every object that we create of that class will share this attribute with the rest of the objects of that class. So a static attribute is something like a shared variable.</p> <p>Regarding methods, a static method is a method that can be called without creating any object of the class:</p> <pre><code>public class MyClass \n{\n    ...\n    public static void myMethod() \n    {\n        ...\n    }\n\n    public void myOtherMethod() \n    {\n        ...\n    }\n}\n...\nMyClass.myMethod();         // OK\nMyClass.myOtherMethod();    // ERROR\n\nMyClass mc = new MyClass();\nmc.myMethod();              // OK (but not necessary)\nmc.myOtherMethod();         // OK\n</code></pre> <p>Keep in mind that in a static method you can only use other static elements (attributes or methods), but not any non-static method existing outside of the method. For instance, this could not be done, since <code>myOtherMethod</code> is not static:</p> <pre><code>public static void myMethod() \n{\n    myOtherMethod();\n}\n\npublic void myOtherMethod() \n{\n    ...\n}\n</code></pre> <p>If we want to use this method, then we need to instantiate a <code>MyClass</code> object inside the static method, and then call this other method:</p> <pre><code>public static void myMethod() \n{\n    MyClass mc = new MyClass();\n    mc.myOtherMethod();\n}\n\npublic void myOtherMethod() \n{\n    ...\n}\n</code></pre> <p>You can use many other static methods existing in Java. For instance, <code>Math</code> class has a lot of them, such as <code>Math.pow(...)</code>, or <code>Math.sqrt(...)</code>.</p>"},{"location":"05d.html#11-instance-elements-vs-class-elements","title":"1.1. Instance elements vs class elements","text":"<p>At the beginning of this unit we've talked about instance variables referring to attributes. We can talk about instance elements to refer to any element in a class (either an attribute or a method) that belongs to a given object, this is, we need to instantiate an object to use or access this element.</p> <p>On the other hand, we have class elements (either class attributes or methods), this is, elements that don't belong to a particular object, so we don't need to instantiate any object to use them. This is what we get when we use static in our classes.</p>"},{"location":"05d.html#2-final-elements","title":"2. Final elements","text":"<p>final modifier lets us define elements that can't be modified. If we apply this modifier to an attribute or variable, we are defining a constant: the element can't be re-assigned to any other value:</p> <pre><code>final int number = 3;\n\n// ERROR\nnumber = 6;\n</code></pre> <p>We can also apply this modifier to methods, or even classes. If we apply the modifier to a method, we are indicating that this method can't be overriden by any possible child class. Regarding classes, a final class can't be inherited.</p>"},{"location":"05e.html","title":"Object oriented programming","text":""},{"location":"05e.html#abstract-classes-and-interfaces","title":"Abstract classes and interfaces","text":"<p>In this unit we are going to have an overview of two important concepts closely related with inheritance: abstract classes and interfaces, and some practical examples about how to apply them to real life problems.</p>"},{"location":"05e.html#1-abstract-classes","title":"1. Abstract classes","text":"<p>An abstract class is a class that can't be instantiated directly (this is, we can't create objects of this class), because its code or functionality is not completely defined. For instance, let's suppose that we have a class called <code>Animal</code>,  in which we specify some attributes of every animal (such as color, or number of legs). However, there are some other attributes or operations, such as <code>talk</code> that can't be specified unless we know the concrete type of animal that we are talking about. In this case, we could (should) define <code>Animal</code> class as an abstract class.</p> <p>If we want to define an abstract class in Java, we just add the reserved word <code>abstract</code> before <code>class</code> element. We can specify its attributes, constructors and other methods if we want to:</p> <pre><code>public abstract class Animal\n{\n    protected String color;\n    protected int numberOfLegs;\n\n    public Animal(String color, int numberOfLegs)\n    {\n        this.color = color;\n        this.numberOfLegs = numberOfLegs;\n    }\n\n    public String getColor()\n    {\n        return color;\n    }\n\n    public void setColor(String color)\n    {\n        this.color = color;\n    }\n\n    ...\n}\n</code></pre> <p>We can also add as many abstract methods as we want to. An abstract method is a method that is not implemented, so we set it as <code>abstract</code> and with no code. For instance, we could add an abstract method to previous class called <code>talk</code>:</p> <pre><code>public abstract class Animal\n{\n    protected String color;\n    protected int numberOfLegs;\n\n    ...\n\n    public abstract void talk();\n}\n</code></pre> <p>Keep in mind that an abstract class does NOT need to have abstract methods in order to be abstract, so we just add them if we need them. In this case, we can't make an animal talk unless we know the concrete type of animal, but we want every animal to talk as soon as they are created, so let's define this abstract method to be implemented later.</p>"},{"location":"05e.html#11-inheriting-from-an-abstract-class","title":"1.1. Inheriting from an abstract class","text":"<p>In order to create subtypes of an abstract class, we just inherit from it. These subtypes can be:</p> <ul> <li>abstract, so that we keep on adding the <code>abstract</code> modifier to the class, and we can even add more abstract methods if we want to. For instance, we could define a subclass called <code>Bird</code> with an abstract method called <code>fly</code>:</li> </ul> <pre><code>public abstract class Bird extends Animal\n{\n    public abstract void fly();\n}\n</code></pre> <ul> <li>concrete, so that we MUST implement (override) every abstract method defined in parent class(es). In our case, we could define an <code>Animal</code> subclass called <code>Dog</code> that needs to implement <code>talk</code> method, or a <code>Duck</code> subclass that inherits from <code>Bird</code> and then needs to implement both abstract methods (<code>talk</code> and <code>fly</code>).</li> </ul> <pre><code>public class Dog extends Animal\n{\n    public Dog(String color, int numberOfLegs)\n    {\n        super(color, numberOfLegs);\n    }\n\n    @Override\n    public void talk()\n    {\n        System.out.println(\"Woof woof!!\");\n    }\n}\n\npublic class Duck extends Bird\n{\n    public Duck(String color, int numberOfLegs)\n    {\n        super(color, numberOfLegs);\n    }\n\n    @Override\n    public void talk()\n    {\n        System.out.println(\"Quack quack!!\");\n    }\n\n    @Override\n    public void fly()\n    {\n        System.out.println(\"I'm flying like a duck!\");\n    }\n}\n</code></pre>"},{"location":"05e.html#12-abstract-classes-and-polymorphism","title":"1.2. Abstract classes and polymorphism","text":"<p>We have just said that we can't instantiate objects of an abstract class. However, we can define an object of an abstract class from any of its concrete subclasses. This way, we can assign a variable of an abstract type any object of a subtype. For instance, if we look at previous example, we can't create an <code>Animal</code> object, since this class is abstract; but we can create a <code>Dog</code> object and assign it to an <code>Animal</code> variable, because of polymorphism.</p> <pre><code>Animal a1 = new Animal(\"red\", 2);   // Error!!\nAnimal a2 = new Dog (\"white\", 4);   // OK\n</code></pre> <p>Exercise 1:</p> <p>Create a project called Animals, with a main class called <code>AnimalsMain</code> within a package called <code>animals.main</code>. Then, add the classes seen before in a package called <code>animals.types</code>. Define the abstract classes <code>Animal</code> and <code>Bird</code> with their corresponding subclasses <code>Dog</code> and <code>Duck</code> and any other class that you may want to add (such as <code>Cat</code> or <code>Lion</code>, for instance). Then, define an array of 5 animals (type Animal) and fill it with some information (you don't need to ask it to the user if you don't want to). Then, explore the array and make each animal talk.</p> <p>Exercise 2:</p> <p>Go back to Exercise 5 of this document and make these changes to it (create a backup of the original project before making these changes):</p> <ul> <li>Define <code>CulturalObject</code> class as abstract</li> <li>In the main application, define an array of 6 <code>CulturalObject</code> objects and then add three books and three music discs to it. Then, print the whole array in the screen.</li> </ul>"},{"location":"05e.html#2-interfaces","title":"2. Interfaces","text":"<p>An interface can be considered as a special type of class with no code implemented (actually, we could add some code inside them, but this is not the aim of this section). So, they can't be directly instantiated either. We use interfaces to define a bunch of methods that need to be implemented by any class that wants to \"inherit\" from that interface.</p> <p>For instance, let's suppose that we have an interface called <code>Shape</code> to represent any type of shape, such as circles, squares and so on. We don't want to store any specific information about a shape, but we want every shape to calculate its own area, and get drawn. So we can define an interface like this one:</p> <pre><code>public interface Shape\n{\n    public float calculateArea();\n    public void draw();\n}\n</code></pre> <p>So, any class that wants to \"inherit\" from that interface must implement these two methods. Actually, we are not inheriting from the interface, but implementing it, so we don't use extends, but <code>implements</code> reserved word. </p> <pre><code>public class Circle implements Shape\n{\n    float radius;\n\n    public Circle(float radius)\n    {\n        this.radius = radius;\n    }\n\n    @Override\n    public float calculateArea()\n    {\n        return Math.PI * radius * radius;\n    }\n\n    @Override\n    public void draw()\n    {\n        System.out.println(\"Drawing a circle!\");\n    }\n}\n</code></pre>"},{"location":"05e.html#21-extending-vs-implementing","title":"2.1. Extending vs implementing","text":"<p>We have just read about abstract classes and interfaces. None of them can be instantiated, and both can have some parts of unimplemented code. But... how to decide which one we must use in a given program?</p> <ul> <li>Abstract classes are inherited, so whenever we are wondering if we should create an abstract class, we need to be sure that:<ul> <li>The subclasses that we will define later are subtypes of the abstract class</li> <li>We don't need to inherit from anything else (Java only lets us inherit from one class)</li> </ul> </li> <li>Interfaces are implemented, and a class can implement as many interfaces as it needs, and also inherit from any other (single) class</li> </ul> <pre><code>public class MyShape extends AnotherClass \n                     implements Shape, Comparable\n{\n    ...\n}\n</code></pre> <p>The only drawback that interfaces have is the (almost) total lack of code: we can't define attributes, constructors or other methods. We can implement some static methods and other special code, and leave unimplemented a set of methods, so that any implementing class can fill them and act as the interface. In our previous example, a Circle is not considered a Shape (since it does not inherit from it), but we can say that a Circle acts as a Shape, because it implements the corresponding interface. Also, we can define an array of an interface object and fill it with concrete objects implementing this interface:</p> <pre><code>Shape[] shapes = new Shape[10];\nshapes[0] = new Circle(...);\nshapes[1] = new Square(...);\n...\nshapes[0].draw();\n</code></pre> <p>Exercise 3:</p> <p>Create a project called Shapes, with a main class called <code>ShapesMain</code> within a package called <code>shapes</code>. Then, add the <code>Shape</code> interface to that same package, and all the implementing classes (such as <code>Circle</code>, <code>Rectangle</code> or <code>Square</code>) in a subpackage called <code>shapes.types</code>. Implement both methods <code>calculateArea</code> and <code>draw</code> in all of them (just print a message in the <code>draw</code> method of each shape). Then, define an array of 5 shapes (type <code>Shape</code>) and fill it with some information (you don't need to ask it to the user if you don't want to). Finally, explore the array and calculate the area of each shape.</p>"},{"location":"05e.html#22-example-sorting-complex-objects","title":"2.2. Example: sorting complex objects","text":"<p>You may be wondering how interfaces can be useful in your day to day work. Let's suppose that you are managing a list or array of complex objects, such as <code>Person</code> objects with their names and ages:</p> <pre><code>class Person \n{\n    private String name;\n    private int age;\n\n    public Person(String name, int age) \n    {\n        this.name = name;\n        this.age = age;\n    }\n\n    ...\n}\n\n...\n\npublic static void main(String[] args) \n{\n    Person[] people = new Person[50];\n\n    people[0] = new Person(\"Nacho\", 40);\n    people[1] = new Person(\"Juan\", 70);\n    ...\n}\n</code></pre> <p>What if we want to sort this array by people's age, in descendant order? We may define a method to manually sort the array, by applying some of the well-known algorithms (such as bubblesort algorithm):</p> <pre><code>for (int i = 0; i &lt; people.length - 1; i++) \n{\n    for (int j = i + 1; j &lt; people.length; j++) \n    {\n        if (people[i].getAge() &lt; people[j].getAge()) \n        {\n            People aux = people[i];\n            people[i] = people[j];\n            people[j] = aux;\n        }\n    }\n}\n</code></pre> <p>However, there is a faster way (in terms of efficiency) to get this result, although we may type some more code than in previous example. There are a couple of interfaces available in the Java core that lets us sort any kind of object. These interfaces are Comparator and Comparable. They both have one method to be implemented:</p> <ul> <li>If we choose <code>Comparable</code> interface, we must implement a method called <code>compareTo</code>, which receives a single object as a parameter, and compares it with current object (<code>this</code>). It also returns an integer indicating which one will go first in the array: current object (negative number), the object received as a parameter (positive number), or zero if they are equal. As we are working with <code>this</code>, we will use this interface applied to the class whose objects need to be sorted.</li> <li>Regarding <code>Comparator</code> interface, we need to implement a method called <code>compare</code>. It receives two objects as parameters, and returns an integer indicating which will go first in the array: the first one (negative number), the second one (positive number) or zero if both are equal. We usually define an additional class to implement this interface, and sort objects of another different class.</li> </ul> <p>Let's see how to use them with our <code>Person</code> class. First of all, we need to implement the chosen interface for our class. If we choose <code>Comparable</code> interface, this class needs to be <code>Person</code> class, and in the code of <code>compareTo</code> method we just return a number depending on which age is greater: remember, we need to sort people by age in descendant order, so we need to return a negative number if this object is older than the parameter: </p> <pre><code>class Person implements Comparable&lt;Person&gt; \n{\n    private String name;\n    private int age;\n\n    public Person(String name, int age) \n    {\n        this.name = name;\n        this.age = age;\n    }\n\n    ... // Getters and setters\n\n    @Override\n    public int compareTo(Person p) \n    {\n        if (this.getAge() &gt; p.getAge())\n            return -1;\n        else if (p.getAge() &gt; this.getAge())\n            return 1;\n        else\n            return 0;\n    }\n}\n</code></pre> <p>If you take a look at Integer API, there's an static method called <code>compare</code> that gets two integers as parameters and returns an integer determining which one is lower or greater (negative if the first one is lower, positive if the first one is greater). So, we can take advantage of this static method in order to sort persons by age. If we want to sort them in ascending order, we can do this:</p> <pre><code>@Override\npublic int compareTo(Person p) \n{\n    return Integer.compare(this.getAge(), p.getAge());\n}\n</code></pre> <p>But, if we want to sort the array in descending order, we just swap the order of the parameters:</p> <pre><code>@Override\npublic int compareTo(Person p) \n{\n    return Integer.compare(p.getAge(), this.getAge());\n}\n</code></pre> <p>There are similar methods in classes such as <code>Float</code>, <code>Character</code>, <code>Double</code>, etc, that let us compare primitive data types.</p> <p>Then, in our main method, we just need to call <code>Arrays.sort</code> method from <code>Arrays</code> class (we need to import <code>java.util.Arrays</code> class in our code), and then our array will be automatically sorted:</p> <pre><code>import java.util.Arrays;\n...\npublic static void main(String[] args) \n{\n    Person[] people = new Person[50];\n    ... // Fill array\n    Arrays.sort(people);\n    // Here our array is already sorted by age (descending)\n}\n</code></pre> <p>If we choose <code>Comparator</code> interface instead of previous one, we usually define an external class that implements it (other than <code>Person</code> class)...</p> <pre><code>public class PersonComparator implements Comparator&lt;Person&gt; \n{\n    @Override\n    public int compare(Person p1, Person p2) \n    {\n        return Integer.compare(p2.getAge(), p1.getAge());\n    }\n}\n</code></pre> <p>Then, we just need to call <code>Arrays.sort</code> method with two arguments: the array to be sorted (our <code>people</code> array), and a comparator object that we will use to sort it (an instance of <code>PersonComparator</code> class):</p> <pre><code>import java.util.Arrays;\n...\npublic static void main(String[] args) \n{\n    Person[] people = new Person[50];\n    ... // Fill array\n    Arrays.sort(people, new PersonComparator());\n    // Here our array is already sorted by age\n}\n</code></pre> <p>This way, we can leave the original class <code>Person</code> unchanged, and use another class to compare <code>Person</code> objects. This is particularly useful when we have no access to the code of the original class to modify it, or if we want to use an anonymous class, as we will see in next section.</p> <p>Exercise 4:</p> <p>Go back to Exercise 1 of this document, and create a copy of it called SortedVideoGameList. Then, use either <code>Comparable</code> or <code>Comparator</code> interfaces to sort the video game array by price (in ascending order) and print the sorted array in the screen.</p>"},{"location":"05e.html#3-anonymous-classes","title":"3. Anonymous classes","text":"<p>As abstract classes and interfaces can't be instantiated, we always need to define a subclass that extends or implements the given abstract class or interface, and then instantiate this subclass. From Java 7, there is a shortcut to define these subclasses without having to define a new source file and/or a new <code>class</code> element. We are talking about anonymous classes.</p> <p>An anonymous class is a class without name that is created at the point where we need to implement a given interface, or extend from a given abstract class, so that we don't need to define an additional class for it.</p> <p>Let's see how anonymous classes work with a couple of examples. The first one creates a new instance of an <code>Animal</code>, to define a new type of animal that is not defined in previous classes (<code>Dog</code> or <code>Duck</code>, for instance).</p> <pre><code>Animal strangeAnimal = new Animal(\"yellow\", 2) \n{\n    @Override\n    public void talk() \n    {\n        System.out.println(\"Vote for Quimby!\");\n    }\n};\n\nstrangeAnimal.talk();\n</code></pre> <p>Notice that we just define an instance of <code>Animal</code> class and, inside the curly braces, we need to override and implement every pending abstract method (<code>talk</code>, in this case). We can also define any additional attribute or method that we need:</p> <pre><code>Animal strangeAnimal = new Animal(\"yellow\", 2) \n{\n    String name = \"Joe Quimby\"\n\n    @Override\n    public void talk() \n    {\n        anotherMethod();\n        System.out.println(\"Vote for Quimby!\");\n    }\n\n    private void anotherMethod()\n    {\n        System.out.println (\"My name is \" + name);\n    }\n};\n\nstrangeAnimal.talk();\n</code></pre> <p>What we are defining, anyway, is an object which is a subtype of <code>Animal</code> in this case. So we can`t re-use this code to define another animal later (we would need to duplicate the code).</p> <p>Regarding interfaces, we can also instantiate them and implement its methods in an anonymous class. This example shows how to define a new subtype of shape with its own implemented methods (and any additional one that we may add):</p> <pre><code>Shape irregularShape = new Shape()\n{\n    @Override\n    public float calculateArea()\n    {\n        return 0.5f;\n    }\n\n    @Override\n    public void draw()\n    {\n        System.out.println(\"Drawing this particular shape!\");\n    }\n};\n\nirregularShape.draw();\nSystem.out.println(irregularShape.calculateArea());\n</code></pre> <p>We can use anonymous classes in many situations. For instance, we can define \"on the fly\" the sorting method for an array of <code>Person</code> objects like the one seen in previous examples:</p> <pre><code>import java.util.Arrays;\n...\npublic static void main(String[] args) \n{\n    Person[] people = new Person[50];\n    ... // Fill array\n    Arrays.sort(people, new Comparator&lt;Person&gt;()\n    {\n        @Override\n        public int compare(Person p1, Person p2)\n        {\n            return Integer.compare(p2.getAge(), p1.getAge());\n        }\n    });\n    // Here our array is already sorted by age\n}\n</code></pre>"},{"location":"05e.html#31-when-can-we-use-anonymous-classes","title":"3.1. When can we use anonymous classes?","text":"<p>Anonymous classes are particularly useful when we need to define a particular instance of an abstract class or interface at a given point of our code (and nowhere else). This way, we avoid defining a new class element with its associated code. However, if we are planning to use this class definition in more than one place, then a \"normal\" class is recommended, so that we don't duplicate the code.</p> <p>Exercise 5:</p> <p>Update Exercise 3 by adding a new shape through an anonymous class. This shape will act as a diamond and it will have two internal attributes: the short axis and the long axis. Calculate its area by applying the corresponding formula, and implement the <code>draw</code> method by printing in the screen the message \"I'm a diamond!\". Then, add an object of this type to the shapes array to use its methods.</p> <p>Exercise 6:</p> <p>Define a <code>Comparator</code> in previous exercise to compare shapes by their area, in descending order. You must use an anonymous class to implement the comparator. Then, sort the array with this comparator and print it in the screen.</p>"},{"location":"05f.html","title":"Object oriented programming","text":""},{"location":"05f.html#refactoring-and-software-patterns","title":"Refactoring and software patterns","text":""},{"location":"05f.html#1-code-refactoring","title":"1. Code refactoring","text":"<p>In software engineering, refactoring often refers to a code update that does not affect its behavior, which is also known as cleaning the code. Refactoring is used as part of the software development process: developers sometimes add new functionalities and test cases, and sometimes refactor their code to make it clearer and more robust. In this case, running the tests again may prove that refactoring has not changed the behavior of the application.</p> <p>So refactoring is a part of software maintenance that does not fix any bug nor add any new feature. The main target is to improve code comprehension or change its structure to ease its future maintenance. Sometimes it is difficult to add new functionalities to a program with its current code structure, so a developer can refactor it before adding more new code.</p>"},{"location":"05f.html#11-why-to-refactor","title":"1.1. Why to refactor?","text":"<p>There are many reasons why we should use this technique:</p> <ul> <li>Quality. It is the main reason. Refactoring is a continuous thinking over our code in an environment where we don't have too much time to look back. Good code is simple and well structured, and anyone can read it and understand it without being part of the development team. We should not come back to those programs written in a single line, where conciseness was better than readability.</li> <li>Efficiency. Keeping a good design and a structured code is the most efficient way to develop a program. The effort that we put into avoiding duplicated code and simplifying the design will be retrieved when we need to make later modifications, either to fix some bugs or to add new features. </li> <li>Evolutive Design. Instead of an initial Big Design, sometimes the requirements are not clearly specified at the beginning, so we must face the design gradually. New functionalities can be added as we are implementing the project, so the initial design can become useless. Refactoring lets us make the design evolve as new functionalities join the old ones. This often implies important changes in the architecture of the project.</li> <li>Avoid rewriting code. In most cases, refactoring is better than rewriting. It is not easy to face a code that is not ours, and does not follow our own standards, but this is not a good reason to start from scratch. Especially in an environment where cost savings make it impossible. Anyway, updating our code is not always necessary. There must be a good reason, and we only need to make an update if there is a bad design that difficults future developments. Whenever we notice that our code is difficult to understand, or there is duplicated code, then we need to refactor it. Sometimes we may need to step back and rethink some aspects, so that we can move on quickly and easily.</li> </ul>"},{"location":"05f.html#12-when-to-refactor","title":"1.2. When to refactor?","text":"<p>Refactoring code is not due to aesthetic reason. We must pay attention to some situations in which it is better to stop and rearrange our code. The elements that warn us that our code is in trouble are known as Bad Smells. An experienced programmer can determine that his/her program is starting to \"stink\" when there are:</p> <ul> <li>Ambiguous identifiers. They can be either variable, class or method names. We will need to rename them to clarify our code. For instance, we can rename a variable called <code>t</code> with another one called <code>waitTime</code>.</li> <li>Duplicated code. This is the main reason to refactor our code. If we detect the same piece of code in more than one place, we need to unify it. </li> <li>Long method. This is a very usual feature of structured programming, but in object oriented programming, the shorter a method is, the easier we can use it. So we can divide the main program in sub-programs.</li> <li>Large class. If a single class tries to solve too many problems, it may also have too many instance variables, which can lead to duplicated code.</li> <li>Long parameter list. We should not pass too many parameters to our methods. We should only use those really needed for the method to complete its task. Those methods who get too many input parameters change their behavior very often, and become very difficult to understand.</li> <li>Feature envy. It happens when a method uses more elements of another class than from its own class. This problem is usually solved by moving this method to the other class.</li> </ul> <p>Therefore, we must take into account these factors as we are implementing the program, so that we can refactor it and avoid these situations. Let's have a look at this example:</p> <pre><code>public class NoRefactor\n{\n    public static void main(String[] args) \n    {\n        int sum1 = 0, sum2 = 0, result = 0;\n        int array1[] = {1,2,3,4}, array2[] = {5,6,7,8};\n\n        for(int i = 0; i &lt; array1.length; i++)\n        {\n            sum1 += array1[i];\n        }\n        result += sum1/array1.length;\n\n        for(int i = 0; i &lt; array2.length; i++)\n        {\n            sum2 += array2[i];\n        }\n        result += sum2/array2.length;\n\n        System.out.println(\"The result is: \" + result);\n    }\n}\n</code></pre> <p>We can easily find duplicated code in this example, so we can refactor it like this:</p> <pre><code>public class Refactor \n{\n    public static int calculateResult(int []array) \n    {\n        int sum = 0;\n        for(int i = 0; i &lt; array.length; i++) \n        {\n            sum += array[i];\n        }\n        return sum/array.length;\n    }\n\n    public static void main(String args) \n    {\n        int array1[] = {1,2,3,4}, array2[] = {5,6,7,8};\n        int result = 0;\n\n        result = calculateResult(array1);\n        result += calculateResult(array2);\n\n        System.out.println(\"The result is: \" + result);\n    }\n}\n</code></pre> <p>Now let's have a look at this code:</p> <pre><code>import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class LongMethod \n{\n    public static void main(String args[])\n    {\n        int array[] = new int[10];\n        BufferedReader input = new BufferedReader(\n            new InputStreamReader(System.in));\n        int result = 0;\n\n        // Array initialization\n        for(int i = 0; i &lt; array.length; i++)\n        {\n            System.out.printf(\"Enter value for array[%d]\", i);\n            try \n            {\n                array[i] = Integer.valueOf(input.readLine());\n            } catch (IOException e) {\n                err.println(\"Error: \" + e.getMessage());\n            }\n        }\n\n        // Sum of the array\n        System.out.println(\"Sum: \");\n        for(int i = 0; i &lt; array.length; i++)\n        {\n            result = result + array[i];\n            System.out.print(array[i] + \" \" + \n                (i==array.length-1?\" \":\"+ \"));\n        }\n        System.out.println(\"= \" + result);\n    }\n}\n</code></pre> <p><code>main</code> method is too large, and we can divide it into functions.</p> <pre><code>import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class NoLongMethod \n{\n    public static int[] initialize()\n    {\n        int array[] = new int[10];\n\n        BufferedReader input = new BufferedReader(\n            new InputStreamReader(System.in));\n\n        for(int i = 0; i &lt; array.length; i++)\n        {\n            System.out.printf(\"Enter value for array[%d]\", i);\n            try \n            {\n                array[i] = Integer.valueOf(input.readLine());\n            } catch (IOException e) {\n                err.println(\"Error: \" + e.getMessage());\n            }\n        }\n\n        return array;\n    }\n\n    public static void sumArray(int[] array)\n    {\n        int result = 0;\n\n        System.out.println(\"Sum: \");\n\n        // Sum of the array\n        for(int i = 0; i &lt; array.length; i++)\n        {\n            result = result + array[i];\n            System.out.print(array[i] + \" \" + \n                (i==array.length-1?\" \":\"+ \"));\n        }\n        System.out.println(\"= \" + result);\n    }\n\n    public static void main(String args[])\n    {\n        int[] array = initialize();\n        sumArray(array);\n    }\n}\n</code></pre>"},{"location":"05f.html#13-refactoring-in-intellij","title":"1.3. Refactoring in IntelliJ","text":"<p>In IntelliJ, we can find a Refactor main menu with some options to refactor our code. Also, we can right click over any element of the code (variable, method, class name...) and choose Refactor option. With these options we can:</p> <ul> <li>Refactor &gt; Rename: Rename variables, classes, methods... and apply these changes to the whole code</li> <li>Refactor &gt; Move: Move classes/members from one package/class to another.</li> <li>Refactor &gt; Introduce constant: Convert a number or literal string into a constant.</li> <li>Refactor &gt; Introduce field: Transform a local variable into a private attribute of the class.</li> <li>Refactor &gt; Extract interface: Extract an interface from the methods of a class.</li> <li>Refactor &gt; Extract superclass: Extract a superclass with methods that will belong to this superclass.</li> <li>...</li> </ul>"},{"location":"05f.html#2-design-patterns","title":"2. Design patterns","text":"<p>There are some useful techniques that we can apply when we need to refactor our code: the design patterns. They are a repeteable solution for a problem in software design.</p> <p>The main advantages in using design patterns are:</p> <ul> <li>They constitute a wide catalog of solutions to problems</li> <li>They standardize how to resolve some given problems</li> <li>They simplify the learning of good programming practices</li> <li>They provide a common vocabulary among developers</li> <li>They avoid reinventing the wheel</li> </ul>"},{"location":"05f.html#21-types-of-design-patterns","title":"2.1. Types of design patterns","text":"<p>According to the purpose, we can divide design patterns into these categories:</p> <ul> <li>Creational patterns: They encapsulate the logic of the object instantiation, hiding the concrete details of every object. This way, we can just work with abstractions.</li> <li>Structural patterns: They help us define how objects are composed.</li> <li>Behavioral patterns: They help us define how objects interact between them.</li> </ul>"},{"location":"05f.html#22-factory-pattern","title":"2.2. Factory Pattern","text":"<p>Factory pattern is one of the most used patterns in Java. It is a creational pattern that provides one of the best ways of creating objects. Using this pattern lets us create objects without showing the logic of the creation to the user. We just use a common interface.</p> <p>For instance, let's go back to the Shapes example of previous documents. We had a Shape interface that was implemented by some classes, such as Circle, Square or Rectangle. Whenever we wanted to create an object, we had to call a concrete constructor:</p> <pre><code>Shape myShape = new Circle(3);\n...\nShape myShape2 = new Square(5);\n...\nmyShape.draw();\n...\n</code></pre> <p>Therefore, developer must know the name of every class implementing Shape interface. But, if we use Factory pattern, we can encapsulate all the possible ways of creating a shape, so that we just need to specify which shape do we need, and the pattern will provide an instance of the concrete shape.</p> <p>First step is to define the shape factory. This typically consists in creating a new class with a static method which is in charge of creating the objects of a given class or class hierarchy. In our case, we define a static method to create Shape subtypes:</p> <pre><code>public class ShapeFactory \n{\n    public static Shape getShape(ShapeType type, float param1, float param2)\n    {\n        if(type == ShapeType.CIRCLE){\n            return new Circle(param1);            \n        } else if(type == ShapeType.RECTANGLE){\n            return new Rectangle(param1,param2);\n        } else if(type == ShapeType.SQUARE){\n            return new Square(param1);\n        }\n\n        return null;\n    }\n}\n</code></pre> <p>This way, if we want to create an instance of any shape, we just need to call this factory with the name of the shape we want to create, and its parameters</p> <pre><code>Shape shape1 = ShapeFactory.getShape(ShapeType.CIRCLE,3, 0);\nshape1.draw();\nSystem.out.println(shape1.calculateArea());\n</code></pre> <p>Regarding <code>ShapeType</code>, it's just an enum where we can specify all the subtypes that we want to manage:</p> <pre><code>public enum ShapeType { CIRCLE, SQUARE, RECTANGLE }\n</code></pre> <p>From the developer's point of view, there's only one class (or interface, in this case), which is \"Shape\", and he doesn't need to know anything about the rest of implementing classes. This design pattern is really useful when there is a complex class hierarchy with a common instantiation pattern (similar parameters), or a huge bunch of classes which are really similar and implement the same parent interface or abstract class, as we can see in the following example.</p> <p>We have a company that sells some products. We must apply the general VAT to some products, and a reduced VAT to some others. So we start by defining an abstract class called <code>Invoice</code> with two subclasses to represent these two types of VAT.</p> <pre><code>public abstract class Invoice \n{\n    private int id;\n    private double amount;\n\n    public int getId() \n    {\n        return id;\n    }\n\n    public void setId(int id)\n    {\n        this.id = id;\n    }\n\n    public double getAmount() \n    {\n        return amount;\n    }\n\n    public void setAmount(double amount)    \n    {\n        this.amount = amount;\n    }\n\n    public abstract double getAmountVAT();\n}\n</code></pre> <p>These are the subclasses:</p> <pre><code>public class InvoiceVAT extends Invoice\n{\n    @Override\n    public double getAmountVAT() \n    {\n        return getAmount()*1.21;\n    }\n}\n\npublic class InvoiceVATReduced extends Invoice\n{\n    @Override\n    public double getAmountVAT()\n    {\n        return getAmount()*1.10;\n    }\n}\n</code></pre> <p>This way, we can define an <code>InvoiceType</code> enum to identify the enum types:</p> <pre><code>public enum InvoiceType { NORMAL, REDUCED }\n</code></pre> <p>And also an <code>InvoiceFactory</code> class to create one of the invoice types depending on the parameters:</p> <pre><code>public class InvoiceFactory \n{\n    public static Invoice getInvoice(InvoiceType type)\n    {\n        if (type == InvoiceType.NORMAL)\n        {\n            return new InvoiceVAT();\n        } else if (type == InvoiceType.REDUCED) {\n            return new InvoiceVATReduced();\n        } else {\n            return null;\n        }\n    }\n}\n</code></pre> <p>Finally, we can use this factory to create the invoices:</p> <pre><code>Invoice myInvoice = FactoryInvoice.getInvoice(InvoiceType.NORMAL);\nInvoice myInvoiceRed = FactoryInvoice.getInvoice(InvoiceType.REDUCED);\n\nmyInvoice.setId(1);\nmyInvoice.setAmount(1000);\n\nmyInvoiceRed.setId(2);\nmyInvoiceRed.setAmount(500);\n\nSystem.out.println(myInvoice.getAmountVAT());\nSystem.out.println(myInvoiceRed.getAmountVAT());\n</code></pre> <p>Exercise 1:</p> <p>Implement the Factory pattern in the Exercise 6 of this document as we have shown in previous example and test it.</p> <p>Exercise 2:</p> <p>Create a new project called Invoices with the packages <code>invoices.types</code>  for the invoice types, and  <code>invoices.main</code> with the main class. Implement the classes of the invoices example above, and add a new type of invoice with a super-reduced VAT (4%).</p> <p>Exercise 3:</p> <p>Update the Animals project of Exercise 1 of this document and add an animal factory so that we no longer use the constructor of each animal type. </p>"},{"location":"05f.html#23-singleton-pattern","title":"2.3. Singleton pattern","text":"<p>This pattern is also a creational pattern that lets us manage just one single object of a given class. It is commonly used in classes that store configuration parameters for a given application, so that there should only be one object of this type for the whole application, and this object must be shared among all the components of the application.</p> <p>Singleton pattern consists in having a static instance of the class itself, which will be returned every time we ask for a new instance from every part of the code. There will also be a private constructor that will be called only once to create the static attribute the first time it is needed.</p> <p>For instance, if we have a class to count the total number of invoices:</p> <pre><code>public class InvoiceCounter\n{\n    private int counter;\n\n    public void increaseCounter()\n    {\n        counter++;\n    }\n\n    public int getCounter()\n    {\n        return counter;\n    }\n}\n</code></pre> <p>We can add a (private) static attribute that points to the same class:</p> <pre><code>private static InvoiceCounter myCounter;\n</code></pre> <p>And a private constructor:</p> <pre><code>private InvoiceCounter()\n{\n    this.counter = 0;\n}\n</code></pre> <p>In order to have an instance of this class, we need to add a public, static method, such as getInstance or, in this case, getCounter:</p> <pre><code>public static InvoiceCounter getInvoiceCounter()\n{\n    if(myCounter == null)\n    {\n        myCounter = new InvoiceCounter();\n    }\n    return myCounter;\n}\n</code></pre> <p>Then, there will only be one single instance of this object in the system. If we want to use it to deal with some invoices, we can do it like this:</p> <pre><code>public static void main(String[] args) \n{\n    InvoiceCounter counter = InvoiceCounter.getCounter();\n    Invoice myInvoice = \n        InvoiceFactory.getInvoice(InvoiceType.NORMAL);\n    Invoice myInvoiceRed = \n        InvoiceFactory.getInvoice(InvoiceType.REDUCED);\n\n    counter.increaseCounter();\n    myInvoice.setId(counter.getCounter());\n    myInvoice.setAmount(1000);\n\n    counter.increaseCounter();\n    myInvoiceRed.setId(counter.getCounter());\n    myInvoiceRed.setAmount(500);\n\n    System.out.println(myInvoice.getAmountVAT());\n    System.out.println(myInvoiceRed.getAmountVAT());\n}\n</code></pre> <p>Exercise 4:</p> <p>Add the <code>InvoiceCounter</code> class to the Invoices project started in previous exercises. Make the appropriate changes to automatically increase the invoice counter as soon as we instantiate a new invoice from <code>InvoiceFactory</code>, so we don't need to increase it manually from the main method, as we did in previous example.</p>"}]}