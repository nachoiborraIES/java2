{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Java programming","text":"<p>This website is (or will be) a complete course for the Java programming language. Along the different blocks of contents, we will navigate through the most important parts of this language, including Java basics (data types, user interaction...), conditions, loops, static and dynamic structures (arrays, lists...), functions, classes and objects... and also some advanced features, such as file management, dates, regular expressions, unit testing, JavaFX applications and much more.</p> <p>The use of these materials is subject to a Creative Commons License CC BY-NC.</p>"},{"location":"01.html","title":"Getting started","text":"<p>Before starting with Java programming language, you should have some knowledge about what a programming language is, which are the most important programming languages nowadays and how to compile and run a Java program. Here you have some external links to read about it (you may open them in new tabs or windows):</p> <ul> <li>Programs, languages and compilers, in which you'll learn what programs and programming languages are, and how to run them using language translators.</li> <li>First steps with Java, in which you'll see how to install Java and create your first program.</li> <li>Using Geany, a simple tool to create and run programs in many languages.</li> <li>Using IntelliJ, an advanced tool to manage Java projects.</li> </ul>"},{"location":"01a.html","title":"Structure of a Java program","text":"<p>Java is an object-oriented programming language, and this implies that we need to work with classes and objects. We'll see later what a class is, but, for now, we only need to know that every piece of code in Java needs to be placed inside a <code>class</code> clause.</p>"},{"location":"01a.html#1-our-first-java-program","title":"1. Our first Java program","text":"<p>Let's see how to start with Java, by creating a simple Java program that prints \"Hello\" in the screen.</p> <pre><code>public class MyClass\n{\n    public static void main(String[] args)\n    {\n        System.out.println(\"Hello\");\n    }\n}\n</code></pre> <p>Let's explain this code:</p> <ul> <li>First line initializes the class in which we are going to place the code. We are creating a class called MyClass.</li> <li>Every code inside this class must be enclosed in curly braces <code>{</code> ... <code>}</code></li> <li>Next, we start another piece of code called main, which is the main piece of code that will be launched when we run the program. In Java, this main block must always be public, static and void, and it must have a String[] set of parameters. We'll learn later what all this stuff means. Again, all the code belonging this main block must be enclosed in their corresponding curly braces.</li> <li>Finally, inside the curly braces of the main block, we add every instruction that we want to run. In this case, we are adding a System.out.println instruction, that is in charge of printing in the screen the text that we specify (Hello, in this case). Also, it's important to finish every instruction with a semicolon <code>;</code>. This tells the compiler that the instruction has finished, and we can start evaluating the next one. We could, this way, write more than one instruction per line, although this way of writing programs is not very usual.</li> </ul>"},{"location":"01a.html#2-more-about-this-example","title":"2. More about this example","text":"<p>The structure of this program is very similar to the same program written in C#: we always need to define a class, even if we only need a <code>main</code> block. This <code>main</code> block is written in lower case in Java.</p> <p>Besides, every public class must have the same name as the source file that contains it, so we need to store the source code of the example above in a file called <code>MyClass.java</code> (Java source files have <code>.java</code> extension). If we want to compile this code, we use <code>javac</code> tool from our JDK installation. We can do it through any IDE, such as Geany, or IntelliJ, as long as we have Java JDK properly installed. </p> <pre><code>javac MyClass.java\n</code></pre> <p>Then, a new file called <code>MyClass.class</code> will be generated. This is the compiled file that can be run under the Java Virtual Machine (JVM), using the <code>java</code> command. This last step can also be done under any IDE.</p> <pre><code>java MyClass\n</code></pre> <p>After running this program, we will see a \"Hello\" message in the screen.</p>"},{"location":"01b.html","title":"Variables and operators","text":""},{"location":"01b.html#1-using-variables","title":"1. Using variables","text":"<p>Variables are essential elements in every program, since they let us store values in them, so that we can operate with them, or modify them along the program execution. Every variable has a type which lets us know what kind of information we can store in it. For instanec, there are integer variables, that lets us store integer numbers, or string variables to manage texts. We'll learn about data types in other sections.</p> <p>Whenever we want to use a variable we must declare it. This step consists in:</p> <ul> <li>Specifying the data type of the variable (integer, text...)</li> <li>Specifying the name of the variable, which is also known as the variable identifier. </li> </ul> <p>For instance, this way we declare a variable to store integer values, using the word <code>int</code> to specify the data type:</p> <pre><code>int myVariable;\n</code></pre> <p>Additionally, we can also assign a value to the variable. This step can be done either when we declare it, or later in the code:</p> <pre><code>int myVariable = 3;\nint myOtherVariable;\n...\nmyOtherVariable = 5;\n</code></pre> <p>Also, variables can change their values in later sentences.</p> <pre><code>int myVariable = 3;\n...\nmyVariable = 5;\n</code></pre> <p>We can also declare multiple variables of the same type in the same line, separated by commas, and we can decide for each one if we want to assign an initial value or not:</p> <pre><code>int number1 = 0, number2, result = 1;\n</code></pre> <p>Regarding the identifier, it can contain letters (in either lower or upper case), digits, and the underscore symbol <code>_</code>, but it can't start with a digit. These are examples of valid identifiers (they usually start with a lower case letter in Java, but this is not compulsory)</p> <pre><code>int aNumber;\nint another_number;\nint number1;\nint _one_more_number;\n</code></pre> <p>Whereas these are examples of non-valid identifiers:</p> <pre><code>int 1number;\nint another number;\n</code></pre> <p>We can use the <code>System.out.println</code> instruction to show the value of a variable in the screen:</p> <pre><code>public class MyClass\n{\n    public static void main(String[] args)    \n    {\n        int myVariable = 3;\n        System.out.println(myVariable);\n    }\n}\n</code></pre>"},{"location":"01b.html#2-some-basic-java-operators","title":"2. Some basic Java operators","text":"<p>Operators let us evaluate expressions and produce a given result. For instance, if we use the addition operator <code>+</code> we can sum a couple of numbers and get the final result. This final result can either be assigned to a variable or shown in the screen.</p> <pre><code>int result = 3 + 4;\nSystem.out.println(32 + 52);\n</code></pre>"},{"location":"01b.html#21-arithmetic-operators","title":"2.1. Arithmetic operators","text":"<p>Arithmetic operators let us do some basic, mathematical operations with numbers. This is the list of basic arithmetic operators in Java:</p> Operator Meaning <code>+</code> Addition <code>-</code> Substraction <code>*</code> Multiplication <code>/</code> Division <code>%</code> Division module <p>Regarding the division operator, we must take into account that it produces a result of the same type that the numbers involved. In other words, if we divide two integer numbers, such as 5 / 2, then the result will be integer (2), not real. The module operator gets the module of an integer division. In previous example, 5 % 2 gets the module of dividing 5 by 2, which is 1.</p> <p>Operator precedence</p> <p>The order in which operators are evaluated in an arithmetic expression is important. For instance, if we set an expression like this one:</p> <pre><code>int result = 4 + 2 / 2;\n</code></pre> <p>Then <code>result</code> variable gets a final value of 5, because the division <code>2 / 2</code> is evaluated BEFORE the addition. This is the precedence order for arithmetic operators:</p> <ol> <li>Multiplications, divisions and modules</li> <li>Additions and substractions</li> </ol> <p>If there are more than one operator of the same range in an operation, then they are evaluated from left to right. For instance, in this case, we first apply the multiplication, and then the division, and the final result is 2:</p> <pre><code>int result = 4 * 3 / 6;\n</code></pre> <p>However, we can alter the order in which operations are evaluated in an expression, putting between parentheses the operations that we want to evaluate in first places. This expression has a result of 0, because we are forcing to evaluate the division 3 / 6 = 0 in first place.</p> <pre><code>int result = 4 * (3 / 6);\n</code></pre> <p>This other expression has a reuslt of 3, because we are forcing to evaluate the addition before the division:</p> <pre><code>int result = (4 + 2) / 2;\n</code></pre> <p>Exercise 1</p> <p>Try to determine the final value stored in <code>result</code> variable in each one of these expressions. You can write a small Java program later to check your answers.</p> <ul> <li><code>int result = 4 + 8 * 2 / 4</code></li> <li><code>int result = (4 + 8) * 2 / 4</code></li> <li><code>int result = (4 + 8) * 3 % 5</code></li> </ul>"},{"location":"01b.html#22-assignment-operators","title":"2.2. Assignment operators","text":"<p>We have already used the <code>=</code> operator to assign a value to a variable. But there are some other assignment operators that we can use if we want to include some arithmetic operation in the process. For instance, <code>+=</code> operator, which is also known as auto-addition operator, automatically adds the specified value to variable's current value. In this example, the final value of <code>result</code> variable is 5:</p> <pre><code>int result = 3;\nresult += 2;\n</code></pre> <p>This is the list of the assignment operators available:</p> Operator Meaning <code>=</code> Simple assignment <code>+=</code> Auto-addition <code>-=</code> Auto-substraction <code>*=</code> Auto-multiplication <code>/=</code> Auto-division <code>%=</code> Auto-module <p>Auto increment and auto decrement operators</p> <p>Java also provides two additional operators, which are a mix of arithmetic and assignment operators. These operators are the auto-increment <code>++</code> and auto-decrement <code>--</code> operators. They apply to a single variable, and automatically increase or decrease its value in 1 unit, respectively. </p> <p>For instance, final value of <code>result</code> variable in the following code is 4:</p> <pre><code>int result = 3;\nresult++;\n</code></pre> <p>These operators can be placed either before or after the affected variable. There is an important difference that you must take into account regarding the operator placement:</p> <ul> <li>If we place the operator BEFORE the variable in a complex expression, then we first increase/decrease the affected variable, and then we complete the expression. For instance, in this code, the final value of <code>b</code> variable is 6, because we first increase <code>a</code> value (to 4), and then we auto-sum this value to <code>b</code>.</li> </ul> <pre><code>int a = 3, b = 2;\nb += ++a;\n</code></pre> <ul> <li>If we place the operator AFTER the variable in a complex expression, we first evaluate the whole expression, assign the value, and then, we increase/decrease the affected variable. The same code of previous example gets a result of 5 for <code>b</code> variable if we type it like this, although <code>a</code> variable will end with the same final result, which is 4.</li> </ul> <pre><code>int a = 3, b = 2;\nb += a++;\n</code></pre> <p>Note that these rules don't apply if we use the auto-increment or decrement operator in a single line. These two lines have the same effect over variable <code>a</code>:</p> <pre><code>a++;\n++a;\n</code></pre> <p>Exercise 2</p> <p>Determine the final value of <code>result</code> variable after running all these instructions:</p> <pre><code>int result = 4;\nresult += 3;\nresult *= 2;\nresult--;\nresult %= 4;\n</code></pre>"},{"location":"01b.html#3-constants-declaration","title":"3. Constants declaration","text":"<p>Constants are values that never change. We declare constants in Java by declaring the data as <code>final</code> and <code>static</code> (we will learn later the meaning of these terms). Typically these constants are placed at the beginning of the class.</p> <pre><code>class MyClass\n{\n    static final int MAX_USERS = 10;\n    ...\n}\n</code></pre>"},{"location":"01b.html#4-comments","title":"4. Comments","text":"<p>Comments help us clarify some parts of our code, by adding some \"human\" text. This text is ignored by the compiler, but helps the developer understand or find some parts of the code.</p> <p>In Java, there are two types of comments:</p> <ul> <li>Single line comments, which are preceded by a double slash <code>//</code>:</li> </ul> <pre><code>// We declare an integer variable\nint variable = 3;\n</code></pre> <ul> <li>Multiple line comments, which are started by <code>/*</code> and finished by <code>*/</code>. Everything in between makes up the comment, and it's ignored by the compiler:</li> </ul> <pre><code>/* This is a comment of\n   multiple lines before\n   declaring a variable */\nint variable = 3;\n</code></pre>"},{"location":"01c.html","title":"Basic data types","text":"<p>In previous sections we have talked about variables. We have learnt that we can use them to store values, and these values can be of different types. In this section we are going to learn about the basic data types provided by Java, and how we can use them to store values in our programs.</p>"},{"location":"01c.html#1-numeric-types","title":"1. Numeric types","text":"<p>There are two main numeric types in Java:</p> <ul> <li>Integer values, which can be represented by <code>byte</code>, <code>short</code>, <code>int</code> or <code>long</code> data types</li> <li>Real value, which can be represented by <code>float</code> or <code>double</code> data types.</li> </ul>"},{"location":"01c.html#11-integer-data-types","title":"1.1. Integer data types","text":"<p>As we have said before, we can choose among 4 different data types to represent integer values. The choice can be determined by the range of values that we need to deal with. In this table you can see the range of values allowe by each data type:</p> Data type Memory (bytes) Range allowed <code>byte</code> 1 -128 to 127 <code>short</code> 2 -32768 to 32767 <code>int</code> 4 -2.147.483.648 to 2.147.483.647\u200b <code>long</code> 8 up to 18-19 digit numbers <p>For instance, if we want to manage the age of a person, we could use an <code>int</code> variable, but we would waste some memory, since this age is usually lower than 100, and we would just need a single byte to store it. We could use a <code>byte</code> variable instead:</p> <pre><code>byte age = 34;\n</code></pre> <p>However, if we want to store the price of an object, we should use a <code>short</code> or even an <code>int</code> variable:</p> <pre><code>short price = 4200;\nint higherPrice = 2223424;\n</code></pre>"},{"location":"01c.html#12-real-data-types","title":"1.2. Real data types","text":"<p>If we want to deal with real numbers, Java provides two different data types, each one with its own memory space and range:</p> <ul> <li><code>float</code> data type needs 4 bytes of memory, and lets us manage numbers with up to 6-7 significant numbers. For instance, if we want to store PI value in a float variable with just 4 or 5 fraction digits (i.e. 3.14159), we can use a <code>float</code> variable. </li> </ul> <pre><code>float pi = 3.14159;\n</code></pre> <ul> <li><code>double</code> data type needs 8 bytes of memory, and lets us manage numbers with up to 15 significant numbers. This way we can store more fraction digits, if we want to: </li> </ul> <pre><code>double pi = 3.14159265359;\n</code></pre> <p>Regarding <code>float</code> variables, if we want to assign them a direct value, we must specify an <code>f</code> symbol at the end of this value. So the example given before should be written like this (otherwise we'll get a compilation error): </p> <pre><code>float pi = 3.14159f;\n</code></pre>"},{"location":"01c.html#13-the-overflow-problem","title":"1.3. The overflow problem","text":"<p>When we are working with numbers, we may need to do some operations that exceed the maximum range allowed by a data type. For instance, if we are working with two <code>byte</code> values and we add them, we may exceed the maximum range allowed by <code>byte</code> data type, which is 127. This situation is called overflow.</p> <p>So, we must take care of the data types that we choose for each situation, taking into account the different operations that we expect to do with these variables.</p>"},{"location":"01c.html#2-text-types","title":"2. Text types","text":"<p>In order to deal with texts, Java provides two data types:</p> <ul> <li><code>char</code> data type if we want to use single characters or symbols</li> <li><code>String</code> data type if we want to manage complex texts (with more than one character or symbol).</li> </ul> <p>Regarding <code>char</code> data type, it is 2 bytes length, so that we can represent any possible character or symbol. We just declare the corresponding variable, and assign the character represented between single quotes:</p> <pre><code>char symbol = 'a';\n</code></pre> <p>If we want to work with longer texts, then we use <code>String</code> variables, specifying the text between double quotes:</p> <pre><code>String text = \"Hello world\";\n</code></pre>"},{"location":"01c.html#21-escape-sequences","title":"2.1. Escape sequences","text":"<p>There are some special characters that can't be represented easily with the keyboard in a source file. For instance, the new line character, or even the quotes inside a quoted text. For this purpose, we can use escape sequences, this is, special symbols that represent these unwritable elements. This is a list of the most popular escape characters or sequences:</p> Sequence Meaning <code>\\n</code> New line <code>\\t</code> Tabulation <code>\\\"</code> Double quotes <code>\\'</code> Single quotes <code>\\\\</code> Backslash <code>\\</code> <p>These escape sequences can be placed inside a char or string value:</p> <pre><code>char newLine = '\\n';\nString message = \"Hello world.\\n\\\"Quoted text\\\"\";\n</code></pre>"},{"location":"01c.html#22-character-operations","title":"2.2. Character operations","text":"<p>We can do some basic operations with characters. You need to take into account that Java internally treats characters as numeric values, assigning each character a numeric code. For instance, alphabet characters are represented by consecutive numeric values, from <code>a</code> to <code>z</code>. This way, if we add 3 to <code>a</code> value, we will get <code>d</code> value:</p> <pre><code>char symbol = 'a';\nsymbol += 3;\n</code></pre> <p>We can also use <code>+</code> operator in texts (strings), but in this case we are not doing any addition, we are just concatenating texts or expressions. This expressions produces the text \"Hello3\":</p> <pre><code>String text = \"Hello\" + 3;\n</code></pre> <p>Keep in mind that you can't mix arithmetic and text operations in a single line directly. The following expression produces a result of \"Hello32\":</p> <pre><code>String text = \"Hello\" + 3 + 2;\n</code></pre> <p>If you want to calculate the addition and then concatenate the result, then you must prioritize the addition using parentheses. This expression produces a result of \"Hello5\":</p> <pre><code>String text = \"Hello\" + (3 + 2);\n</code></pre>"},{"location":"01c.html#3-conversion-between-data-types","title":"3. Conversion between data types","text":"<p>Sometimes we need to convert a value of some type into another different type. The way we do this step depends on the types involved.</p>"},{"location":"01c.html#31-some-basic-conversions-typecasting","title":"3.1. Some basic conversions. Typecasting","text":"<p>The conversions between numeric values are quite straightforward. We just need to do a typecast, this is, specify between parentheses the data type to which we want to convert the expression. In this example, we are converting <code>pi</code> real value to an integer (so we get 3 as final result):</p> <pre><code>float pi = 3.1416f;\nint piInteger = (int)pi;\n</code></pre> <p>The opposite step can also be done. In this case, we are converting an integer value into a double one (the final value will be 5.0):</p> <pre><code>int number = 5;\ndouble realNumber = (double)number;\n</code></pre> <p>However, this step is NOT necessary if the source type is smaller than the destination type. For instance, a <code>byte</code> doesn't need to be converted into <code>int</code>:</p> <pre><code>byte value = 3;\nint number = value;\n</code></pre> <p>Typecast can be useful, for instance, to convert integer divisions into real ones. This example divides two integer values, but, as we are converting one of them into <code>float</code>, then the final result will be a real number, with the corresponding fraction digits, and can be stored in a <code>float</code> variable:</p> <pre><code>float result = (float) 3 / 2;\n</code></pre> <p>In general, every arithmetic operation tries to produce a result of the same type of its operands (if we divide two integers, we get an integer result, for instance). However, in certain operations, such as additions or multiplications, Java tries to convert the result to a higher type, and we need to typecast it. In this example, we try to add two byte values, but Java tries to convert the result to <code>int</code>, so we need to specify that we want to keep using a <code>byte</code> as a result (even though we could cause an overflow):</p> <pre><code>byte a = 3, b = 2;\nbyte result = (byte)(a + b);\n</code></pre> <p>If we mix two different types in an arithmetic operation, then Java converts the result to the highest of them. This multiplication gets a <code>float</code> number because one of the operands is <code>float</code>:</p> <pre><code>float a = 3.5f;\nint b = 4;\nfloat result = a * b;\n</code></pre>"},{"location":"01c.html#32-converting-from-to-string","title":"3.2. Converting from / to string","text":"<p>In some situations, we may read numeric values from textual sources, such as text file, or user input. In this case, we need to convert the text into the corresponding numeric value. To do this, Java provides some useful instructions. Here you can see the most useful ones:</p> <ul> <li><code>Integer.parseInt</code> converts a text value into <code>int</code>:</li> </ul> <pre><code>int value = Integer.parseInt(\"23\");\n</code></pre> <ul> <li><code>Float.parseFloat</code>, <code>Double.parseDouble</code>, <code>Byte.parseByte</code>, <code>Short.parseShort</code> and <code>Long.parseLong</code> do the same with their corresponding data types:</li> </ul> <pre><code>float value = Float.parseFloat(\"3.1416\");\n</code></pre> <p>If we want to convert a numeric value into a string, we can choose one of these solutions:</p> <ul> <li>Concatenate the numeric value with an empty string <code>\"\"</code>:</li> </ul> <pre><code>int number = 23;\nString text = \"\" + number;\n</code></pre> <ul> <li>Use <code>String.valueOf</code> instruction to convert the specified value to string:</li> </ul> <pre><code>int number = 23;\nString text = String.valueOf(number);\n</code></pre> <p>Exercise 1</p> <p>Create a program called Ages.java that:</p> <ul> <li>Defines two <code>byte</code> variables to store your age and the age of a friend</li> <li>Defines another <code>byte</code> variable to store the addition of both ages (you may need to typecast the result)</li> <li>Defines a <code>float</code> variable to store the average of these ages, including fraction digits</li> <li>Prints the message \"The age average is \" followed by the average calculated in previous step</li> </ul>"},{"location":"01d.html","title":"Basic input and output","text":"<p>In this document we are going to learn how to interact with final user. First of all, we will see how to print values in the screen using different instructions, and then we will see how to gather information from the keyboard and convert it to the appropriate data type.</p>"},{"location":"01d.html#1-program-output","title":"1. Program output","text":"<p>You can use the <code>System.out.print</code> or <code>System.out.println</code> instruction (depending on whether you want a new line at the end or not) to print messages to the screen. You can join multiple values by using the link operator (<code>+</code>):</p> <pre><code>int result = 12;\nSystem.out.println(\"The result is \" + result);\nSystem.out.print(\"Have a nice day!\");\n</code></pre>"},{"location":"01d.html#11-formatted-output","title":"1.1. Formatted output","text":"<p>Apart from traditional <code>System.out.println</code> instruction to print data, we can use some other options if we want this data to have a given output format. To do this, we can use <code>System.out.printf</code> instruction instead of the previous one. This instruction behaves in a similar way than the original <code>printf</code> function from C language. It has a variable number of parameters, and the first of all is the string to be printed out. Then, this string can have some special characters inside it, which determine the data types that must replace these characters. For instance, if we use this instruction:</p> <pre><code>System.out.printf(\"The number is %d\", number);\n</code></pre> <p>then the symbol <code>%d</code> will be replaced by the variable <code>number</code>, and this variable must be an integer (this is what <code>%d</code> means).</p> <p>There are some other symbols to represent different data types. Here are some of them:</p> <ul> <li><code>%d</code> for integer types (<code>long</code>, <code>int</code>)</li> <li><code>%f</code> for real types (<code>float</code> and <code>double</code>)</li> <li><code>%s</code> for strings</li> <li><code>%c</code> for characters</li> <li><code>%n</code> to represent a new line (similar to <code>\\n</code>, but platform independent). In this case, we don't need to add a parameter at the end of <code>printf</code>.</li> </ul> <p>We can place as many symbols as we want inside the output string, and then we will need to add the corresponding number of parameters at the end of the <code>printf</code> instruction. For instance:</p> <pre><code>System.out.printf(\"The average of %d and %d is %f\", \n    number1, number2, average);\n</code></pre> <p>Besides the primary symbols <code>%d</code> and <code>%f</code>, we can add some other information between the '%' and the letter, that specify some format information. </p> <p>Specifying integer digits</p> <p>For instance, if we want to output an integer with a given number of digits, we can do it this way:</p> <pre><code>System.out.printf(\"The number is %05d\", number);\n</code></pre> <p>where <code>05</code> means that the integer is going to have, at least, 5 digits, and if there are not enough digits in the number, then it will be filled with zeros. The output of this instruction if number is <code>33</code> would be <code>The number is 00033</code>. If we don't put the <code>0</code>, then the number will be filled with whitespaces. So this instruction:</p> <pre><code>System.out.printf(\"The number is %10d\", number);\n</code></pre> <p>if number is <code>33</code>, it would produce the following output: <code>The number is \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a033</code>.</p> <p>Specifying fraction digits</p> <p>In the same way that we format integer numbers, we can format real numbers. We can use the same pattern seen before to specify the total number of integer digits:</p> <pre><code>System.out.printf(\"The number is %3f\", number);\n</code></pre> <p>But, besides, we can specify the total number of fraction digits by adding a point and the total number desired, this way:</p> <pre><code>System.out.printf(\"The number is %3.3f\", number);\n</code></pre> <p>Then, if number is <code>3.14159</code>, the output would be  <code>The number is \u00a0\u00a03.142</code>.</p>"},{"location":"01d.html#2-getting-user-input","title":"2. Getting user input","text":"<p>In order to get the user input, the easiest way may be through the <code>Scanner</code> object. We need to import <code>java.util.Scanner</code> in order to use it, and then we create a <code>Scanner</code> element and call some of its methods to read data from the user. Some of them are <code>nextLine</code> (to read a whole line of text until the user presses Enter) and <code>nextInt</code> (to read an integer explicitly):</p> <pre><code>import java.util.Scanner;\n...\npublic class ClassName\n{ \n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int number = sc.nextInt();\n        String text = sc.nextLine();    \n        sc.close();\n    }\n</code></pre> <p>There are some other methods, such as <code>nextFloat</code>, <code>nextBoolean</code>... but they are very similar to <code>nextInt</code>, and they help us read specific data types from the input, instead of reading texts and then converting them into the corresponding type (as <code>Console.ReadLine</code> does in C#). You can introduce this data separated by whitespaces or new lines (Intro).</p> <pre><code>int number1, number2;\nnumber1 = sc.nextInt();\nnumber2 = sc.nextInt();\n</code></pre> <p>Be careful when combining data types</p> <p>Let's suppose that you have to read this information from the input:</p> <pre><code>23 43\nHello world\n</code></pre> <p>You may think that you need to use <code>nextInt</code> method twice, and then <code>nextLine</code> method to read the last string, but this approach is NOT correct: when you use <code>nextInt</code> to read the integer values, you don't read the end of line that exists beyond number 43, so, when you use <code>nextLine</code> method once, you just read this new line, but not the second line. The correct sequence would be this one:</p> <pre><code>int number1 = sc.nextInt();\nint number2 = sc.nextInt();\nsc.nextLine(); \nString text = sc.nextLine();\n</code></pre> <p>Third line reads and discards the new line after number 43.</p>"},{"location":"01d.html#21-using-systemconsolereadline","title":"2.1. Using System.console().readLine()","text":"<p>There's an additional way of reading data from user input. It consists in using <code>System.console().readLine()</code> method, which is similar to Scanner's <code>newLine</code> method: it reads the whole line until user presses Intro, so we ALWAYS read a string with this instruction, and we need to convert it to its corresponding data type later:</p> <pre><code>System.out.println(\"Write a number:\");\nString text = System.console().readLine();\nint number = Integer.parseInt(text);\n</code></pre> <p>The main drawback of this instruction is that it doesn't work well in the terminal of some IDEs, since the terminal of this IDE is not a system terminal, so you can't rely on it in certain situations.</p> <p>Exercise 1</p> <p>Create a program called FormattedDate with a class with the same name inside. The program will ask the user to enter the day, month and year of birth (all values are integers). Then, it will print his birth date with the format d/m/y. For instance, if the user types day = 7, month = 11, year = 1990, the program will output 7/11/1990.</p> <p>Exercise 2</p> <p>Create a program called GramOunceConverter that converts from grams to ounces. The program will ask the user to enter a weight in grams (an integer number), and then it will show the corresponding weight in ounces (a real number), taking into account that 1 ounce = 28.3495 grams.</p> <p>Exercise 3</p> <p>Create a program called NumbersStrings. This program must ask the user to enter 4 numbers, that will be stored in 4 <code>String</code> variables. Then, the program will join the first pair of numbers into a single integer value, and the second pair of numbers into another integer value, and then add these values. For instance, if the user types the numbers 23, 11, 45 and 112, then the program will create a first integer value of 2311 and a second integer value of 45112. Then, it will add these two values and get a final result of 47423.</p> <p>Exercise 4</p> <p>Create a program called CircleArea that defines a float constant called <code>PI</code> with the value <code>3.14159</code>. Then, the program will ask the user to enter the radius of a circle, and it will output the area of the circle (<code>PI</code> * radius * radius). This area will be printed with two decimal digits.</p>"},{"location":"01e.html","title":"Writing clean code","text":""},{"location":"01e.html#1-introduction-to-clean-code","title":"1. Introduction to clean code","text":"<p>When we are writing a program, we should not only think about what the program needs to do. We should also ask some other questions to ourselves, such as:</p> <ul> <li>What if I have to take this project back in two years? Will I understand the code?</li> <li>What if anyone else has to take this project in the future? Will he/she understand the code?</li> </ul> <p>After these questions, you should think of a way to write your code so that it will be easy to read and understand. This is where clean code rules come into play.</p>"},{"location":"01e.html#11-what-is-clean-code","title":"1.1. What is clean code?","text":"<p>You can find many examples and good explanations to this question in the book Clean Code, by Robert C. Martin. Here we just summarize some of these ideas:</p> <ul> <li>Code must be elegant and easy to read, simple and direct. Clean code reads like well-written prose (Grady Booch).</li> <li>Logic should be straightforward to make it hard for bugs to hide.</li> <li>Performance should be close to optimal so as not to tempt people to make further changes.</li> <li>Keep in mind the Boy Scout rule: Leave the campground cleaner than you found it</li> </ul>"},{"location":"01e.html#12-the-importance-of-practice","title":"1.2. The importance of practice","text":"<p>Writing clean code not only consists in reading documents like this one to keep in mind some rules. It also consists in putting into practice these rules continuously. For instance, you can read how to ride a bike, but you won't learn how to do it until you practice.</p> <p>Besides, if we don't start writing clean code from the beginning of a project, there may be some terrible consequences later: projects can grow too much, and then it may be hard to apply clean code rules to the whole code: the time we spend fixing the code in the future may affect deadlines, maintenance, future versions...</p>"},{"location":"01e.html#13-why-bad-code-exists","title":"1.3. Why bad code exists?","text":"<p>Although everyone should apply clean code rules in their programs, and we can easily see the benefits of working this way, there are many reasons why bad code exists:</p> <ul> <li>Too tight schedules</li> <li>Unexperienced project managers</li> <li>Programmer's docility (he/she doesn't want to get fired)</li> <li>Boredom (always doing the same kind of projects)</li> <li>...</li> </ul>"},{"location":"01e.html#14-whats-coming-next","title":"1.4. What's coming next?","text":"<p>In this document we are going to focus on some basic aspects of clean code rules, such as how to assign variable names and how to place comments in our code.</p>"},{"location":"01e.html#2-dealing-with-variable-names","title":"2. Dealing with variable names","text":"<p>Names are essential in programming, since we will assign a name to (almost) everything we include in our program. At this point you should already know what a variable is and its main purpose (store values that can be modified along the program execution). But you should not assign a variable name carelessly. You should use meaningful names for your variables. </p> <p>When reading the name of a variable (or any other element in the code), it must answer some basic questions, such as why it exists, what it does and how it is used. If a name requires a comment to explain its meaning, then it is not a suitable name. For instance, if we want to store in a variable the age average of a list of people, we should NOT do this:</p> <pre><code>int a;          // Age average\n</code></pre> <p>We could do this instead:</p> <pre><code>int ageAverage;\n</code></pre> <p>Some other aspects that we should take into account when dealing with variable names:</p> <ul> <li>Try not to use too similar names. Variables like <code>totalRegisteredUsers</code> and <code>totalUnregisteredUsers</code> only differ in two letters, and you could use the wrong one in a given piece of code. It's better to call them <code>registered</code> and <code>anonymous</code>.</li> <li>Add meaningful context when it's necessary. For instance, if a variable is named <code>account</code>, what does it mean? A user account? a bank account? It's better to be more specific, and call it <code>bankAccount</code>, for instance</li> <li>Choose one word per concept: if you declare many variables in many parts of your code to refer to a user login, you should always call them in the same way: <code>user</code>, or <code>login</code>, for instance, but don't change the name in each situation.</li> <li>Don't use short names, such as <code>n</code>, or <code>e</code>, because it will be difficult to find your variable among other similar words in the text.</li> <li>Try to use readable names. It's better to use a name like <code>birthDate</code> than <code>ddmmyyyy</code>, because you can pronounce this name in a conversation.</li> </ul>"},{"location":"01e.html#21-uppercase-or-lowercase","title":"2.1. Uppercase or lowercase?","text":"<p>The use of uppercase and lowercase letters in names depend on the programming language itself. There are mainly four naming standards:</p> <ul> <li>Camel Case: it is used in languages such as Java or Javascript. Every word in the variable name starts with upper case, apart from the first word. For instance:</li> </ul> <pre><code>String personName;\n</code></pre> <ul> <li>There is a subset of camel case standard, called Pascal Case in which the first word of the name also starts with uppercase. This subset is employed by C# to define public elements (private elements are named using camel case). For instance:</li> </ul> <pre><code>string personName;\npublic int PersonAge;\n</code></pre> <ul> <li>Snake Case: it is used in languages such as PHP or Python. Variable words are separated by underscores:</li> </ul> <pre><code>$person_name = \"Nacho\";\n</code></pre> <ul> <li>Kebab Case: variable words are separated by hyphens. It is not very popular among programming languages, since many of them don't allow the hyphen as part of the variable name (so as not to mix it up with the substraction operator). There are some few examples, such as Lisp or Clojure.</li> </ul> <pre><code>(def person-name \"Nacho\")\n</code></pre> <ul> <li>Upper case: it is used in many languages to define constants. The words of the name are usually separated by underscores, as in snake case standard:</li> </ul> <pre><code>static final int MAXIMUM_SIZE = 100;\n</code></pre>"},{"location":"01e.html#3-placing-comments","title":"3. Placing comments","text":"<p>Well-placed comments help us understand the code around them, whereas misplaced comments can damage the understanding of the code. Some programmers think that comments are failures, and should be avoided as much as possible. One of the reasons argued is that they are hard to maintain. If we change the code after writing a comment, we may forget to update the comment, and thus it would talk about something that is no longer present in the code.</p> <p>Another reason to avoid comments is that they are tightly linked to bad code. When we write bad code, we often think that we can write some comments to make it understandable, instead of cleaning the code itself.</p> <p>In this section we will learn where to put comments. Firstly, we will see what type of comments are necessary (what we call good comments), and then we will see what comments are avoidable (bad comments).</p>"},{"location":"01e.html#31-good-comments","title":"3.1. Good comments","text":"<p>The following comments are considered necessary:</p> <ul> <li>Legal comments, such as copyright or authorship, according to the company standards. This type of comments are normally placed at the beginning of each source file that belongs to the author or company.</li> <li>Introduction comments, a short comment at the beginning of each source file (typically classes) that explains the main purpose of this source file or class. This comment is usually placed along with a legal comment at the beginning of a source file:</li> </ul> <pre><code>/*\n This class stores information about a user account\n\n Created by Nacho Iborra\n */\n\npublic class User\n{\n    ...\n}\n</code></pre> <ul> <li>Explanation of intent. These comments are used when:</li> <li>We tried to get a better solution to the problem but we could not, and then we explain that a part of the code could be improvable.</li> <li>There is a part of the code that does not follow the same pattern than the code around it (for instance, an integer variable among a bunch of floats), and we want to explain why we have used this instruction or data type.</li> <li>TODO comments, which are placed in incomplete parts. They help us remember all the pending tasks. This type of comments have become so popular that a lot of IDEs automatically detect and highlight them.</li> <li>API documentation. Some programming languages, such as Java or C#, let us add some comments in some parts of the code so that these comments are exported to HTML or XML format, and become part of the documentation. </li> </ul>"},{"location":"01e.html#32-bad-comments","title":"3.2. Bad comments","text":"<p>The following are examples of bad comments that we can avoid...</p> <p>Some type of information comments can be avoided by changing the name of the element that they are explaining. For instance, if we have this comment with this variable:</p> <pre><code>// Total number of customers\nint total;\n</code></pre> <p>We can avoid the comment by renaming the variable this way:</p> <pre><code>int totalCustomers;\n</code></pre> <p>Redundant comments, i.e. comments that are longer to read than the code they are trying to explain, or they are just unnecessary, because the code is self-explanatory. For instance, the following comment is redundant, since the code it is explaining is quite understandable:</p> <pre><code>/* We ask the user two numbers and add them */\nScanner sc = new Scanner(System.in);\nSystem.out.println(\"Enter two numbers\");\nint number1 = sc.nextInt();\nint number2 = sc.nextInt();\nSystem.out.println(number1 + number2);\n</code></pre> <p>Comments without context, i.e. comments that are not followed by the corresponding code. For instance, the following comment is not completed with appropriate code. We say we are writing data into a file, but nothing is executed after that. Maybe there was some piece of code, but it was removed.</p> <pre><code>/* We ask the user two numbers and add them */\nScanner sc = new Scanner(System.in);\nSystem.out.println(\"Enter two numbers\");\nint number1 = sc.nextInt();\nint number2 = sc.nextInt();\nSystem.out.println(number1 + number2);\n// We print the result in a text file\n</code></pre> <p>There should be no mandated comments. Some people think that every variable, for instance, must have a comment explaining its purpose. But that is not a good decision, since we can avoid most of these comments by using appropriate variable names.</p> <p>Also, there should be no journal comments: sometimes an edit registry is placed at the beginning of a source file. It contains all the changes made to the code, including the date and the reason of the change. But nowadays, we can use version control applications, such as GitHub, to keep this registry out of the code itself.</p> <p>Some time ago, some programmers used to place some position markers and/or code dividers,  to quickly find a place in the code, or to separate some code blocks that are quite long. Both types of comments are not recommended if code is properly formatted.</p> <pre><code>// =================== VARIABLES ====================\nint age;\nString name;\n...\n// =================== MAIN =========================\npublic static void main(String[] args)\n{\n    ...\n    ////// FINAL RESULT\n}\n</code></pre> <p>Closing brace comments are also not recommended. They are placed at every closing brace to explain which element is this brace closing. These comments can be avoided, since most of current IDEs highlight each pair of braces when we click on them, so that we can match each pair automatically. </p> <pre><code>public static void main(String[] args)\n{\n    ...\n} // end main\n</code></pre> <p>Warnings are used when we have some code that may cause problems in certain situations, because it needs to be reviewed. It is very usual to find some code blocks completely commented, and a warning message explaining the problem with it. These comments should be turned into \"TODO\" comments, in order to warn the programmer that this code needs to be reviewed in the future, instead of just removing the comments.</p> <p>Exercise 1</p> <p>This program asks the user to introduce three numbers and gets the average of them. Discuss in class which parts of the code are not clean or could be improved, regarding variable names and comments.</p> <pre><code>import java.util.Scanner;\n\npublic class AverageNumbers\n{\n    public static void main(String[] args)\n    {\n        // Variables to store the three numbers and the average\n        int n1, n2, n3;\n        int Result;\n        Scanner sc = new Scanner(System.in);\n\n        // We ask the user to enter three numbers\n        System.out.println(\"Introduce three numbers:\");\n        n1 = sc.nextInt();\n        n2 = sc.nextInt();\n        n3 = sc.nextInt();\n        // The result is the average of these numbers\n        /* We could have used a float number instead, \n            but we decided to keep this program as \n            simple as we could */\n        Result = (n1+n2+n3)/3;\n        System.out.println(\"The average is \" + Result);\n    }\n}\n</code></pre>"},{"location":"02a.html","title":"Boolean type and operators","text":"<p>In this section we are going to talk about the basics of structured programming using logical information. So, we are going to introduce the boolean data types that lets us check some conditions and decide which piece of code we should run next. This way, we can choose among different results depending on a given input condition, or even repeat the execution of a given piece of code many times without having to re-type it again.</p>"},{"location":"02a.html#1-boolean-data-type","title":"1. Boolean data type","text":"<p>Boolean data type is another basic data type (just like integers, characters or floating point numbers) that lets us represent two opposite values: true and false. In Java, this data type is represented by the word <code>boolean</code>. We can declare variables of this type, and also assign an initial value to them (from the range <code>true</code> and <code>false</code>):</p> <pre><code>boolean b = true;\n</code></pre> <p>We can even read boolean values from user input, using <code>nextBoolean</code> method from the Scanner variable. In this case, user must type true or false in the keyboard, which is not very intuitive.</p> <pre><code>Scanner sc = new Scanner(System.in);\nboolean b = sc.nextBoolean();\n</code></pre>"},{"location":"02a.html#2-some-additional-operators","title":"2. Some additional operators","text":"<p>Related with this boolean data type, there are some Java operators that we can use. In this section we are going to talk about relational and logical operators.</p>"},{"location":"02a.html#21-relational-operators","title":"2.1. Relational operators","text":"<p>Relational operators let us compare two different values, and check if one of them is greater, or lower, or equal than the other. This is the complete list of relational operators:</p> Operator Meaning <code>&gt;</code> Greater than <code>&gt;=</code> Greater or equal than <code>&lt;</code> Lower than <code>&lt;=</code> Lower or equal than <code>==</code> Equal to <code>!=</code> Not equal to <p>Note that, if we want to check if two values are equal, we use <code>==</code> comparator instead of just <code>=</code>, which is used for assignment purposes. We can join these operators with boolean values to determine if some comparisons are true or false:</p> <pre><code>int n = 10;\nboolean check1 = n &gt; 5;     // true\nboolean check2 = n != 10;   // false\n</code></pre> <p>Regarding strings, we can't use these comparators, because they don't work as expected (our program compiles, but results may be unpredictable). If we want to check if two strings are the same, we use <code>equals</code> instruction instead of <code>==</code> comparator:</p> <pre><code>String s1 = \"Hello\";\n\nboolean check1 = s1 == \"Hello\";      // Does not work as expected\nboolean check2 = s1.equals(\"Hello\"); // OK\n</code></pre> <p>We'll learn more about how to deal with string values in later sections.</p>"},{"location":"02a.html#22-logical-operators","title":"2.2. Logical operators","text":"<p>Logical operators join two or more simple comparisons to build a complex one. This way we can check if every comparison in the list is true, or at least one of them. The final result of this complex expression is also a boolean value. This is the list of logical operators:</p> Operator Meaning <code>&amp;&amp;</code> AND operator <code>||</code> OR operator <code>!</code> NOT operator <p>Regarding AND operator <code>&amp;&amp;</code>, it joins two comparisons, so that the final result will be true if both comparisons are true. Otherwise it will be false:</p> <pre><code>int n = 10, m = 5;\n\nboolean c1 = n &gt; 5 &amp;&amp; m &lt; 10;   // true &amp;&amp; true = true\nboolean c2 = n &gt; 5 &amp;&amp; m &gt; 10;   // true &amp;&amp; false = false\n</code></pre> <p>OR operator <code>||</code> also joins two comparisons, but in this case the final result will be true if any of the comparisons joined (or both) are true:</p> <pre><code>int n = 10, m = 5;\n\nboolean c1 = n &gt; 5 || m &gt; 10;   // true || false = true\nboolean c2 = n &lt; 5 || m &gt; 10;   // false || false = false\n</code></pre> <p>Finally, the NOT operator <code>!</code> is a unary operator, this is, it affects only one expression (not two), and changes the value of this expression (this is, if the expression was true, the final result is false, and vice versa).</p> <pre><code>int n = 10;\n\nbool c1 = n &gt; 5;    // true\nbool c2 = !c1;      // false\n</code></pre> <p>The precedence of these operators is important:</p> <ol> <li>First of all, we evaluate every expression between parentheses</li> <li>Then, we evaluate NOT operators</li> <li>Next, we check AND operators</li> <li>Finally, we look for OR operators</li> </ol> <p>Also, you must take into account that both AND and OR operators work in short circuit mode. This means that:</p> <ul> <li>Regarding AND operator, if the first expression is false, second expression is not checked (final result will be false anyway)</li> <li>Regarding OR operator, if the first expression is true, second expression is not checked (final result will be true anyway).</li> </ul> <p>Exercise 1</p> <p>Try to guess the final result of these expressions <code>e1</code>, <code>e2</code> and <code>e3</code>. You can then write a short program to check your answers:</p> <pre><code>int a = 3, b = 5, c = 8;\n\nboolean e1 = a &lt; 2 &amp;&amp; b &gt;= 5 || c == 8;\nboolean e2 = a &lt; 2 &amp;&amp; (b &gt;= 5 || c == 8);\nboolean e3 = !(a &lt; 2) &amp;&amp; (b &gt;= 5 || c == 8);\n</code></pre>"},{"location":"02b.html","title":"Selective structures","text":"<p>Selective or conditional structures let us choose among different paths in our code depending on a given condition (or conditions) that must be checked. In this document we'll see the selective structures provided by Java.</p>"},{"location":"02b.html#1-the-if-clause","title":"1. The \"if\" clause","text":"<p>You can use the <code>if</code> basic structure to run a piece of code if a given condition is true:</p> <pre><code>if (age &gt;= 18)\n{\n    System.out.println(\"You are old enough\");\n}\n</code></pre> <p>Alternatively, you can use <code>if..else</code> structure to choose among a given path (determined by a condition) or its opposite:</p> <pre><code>if (age &gt;= 18)\n{\n    System.out.println(\"You are old enough\");\n}\nelse\n{\n    System.out.println(\"You are not adult yet\");\n}\n</code></pre> <p>Finally, if there is more than two paths to choose among, we can join <code>if .. else if .. else if .. else</code> structures to choose among several paths depending on the condition relative to each one. Only one path will be chosen.</p> <pre><code>if (number &gt; 0)\n{\n    System.out.println(\"It is positive\");\n}\nelse if (number &lt; -10)\n{\n    System.out.println(\"It is under -10\");\n}\nelse\n{\n    System.out.println(\"It is between -10 and 0\");\n}\n</code></pre> <p>The condition in each <code>if</code> or <code>else if</code> clause can be either a simple condition (like the ones shown in previous examples) or a complex condition, joined by logical operators <code>&amp;&amp;</code> and/or <code>||</code>:</p> <pre><code>if (age &gt;= 18 &amp;&amp; age &lt;= 30)\n{\n    System.out.println(\"You are between 18 and 30\");\n}\n</code></pre>"},{"location":"02b.html#2-the-switch-clause","title":"2. The \"switch\" clause","text":"<p>Besides, there's a <code>switch</code> clause that lets us evaluate the value of a simple variable or expression. Each of the possible values of this expression can be represented with a <code>case</code> clause. Finally, we can use a <code>default</code> case to represent any other possible value that has not been covered by previous case clauses. </p> <p>The data managed in the <code>switch</code> clause must be a primitive type; strings are NOT allowed in early versions of Java (Java 6 and earlier). We need to add a <code>break</code> instruction at the end of each case to exit the switch clause; otherwise, the program keeps running the instruction of next case clause. In other languages, such as C#, the break instruction is compulsory in the case clauses that are not empty, but this does not happen in Java, so we must take care of this situation.</p> <pre><code>switch(number)\n{\n    case 0: System.out.println(\"It is 0\"); break;\n    case 1: System.out.println(\"It is 1\");\n    case 2: System.out.println(\"It is 2\"); break;\n    default: System.out.println(\"Unknown number\");\n}\n</code></pre> <p>In previous example, if number is 1, it would output the messages \"It is 1\" and \"It is 2\", since there is no <code>break</code> clause at case 1.</p> <p>Exercise 1</p> <p>Create a program called MarkCheck that asks the user to enter 3 marks. The program must print one of these messages, depending on the mark values:</p> <ul> <li>All marks are greater or equal than 4</li> <li>Some marks are not greater or equal than 4</li> <li>No mark is greater or equal than 4</li> </ul> <p>Exercise 2</p> <p>Create a program called GramOunceConverter2 that will be an improved version of a previous exercise. In this case, the user will type a weight (float), and a unit (<code>g</code> for grams, <code>o</code> for ounces). Then, depending on the unit chosen, the program will convert the weight to the opposite unit. For instance, if the user types a weight of 33 and chooses <code>o</code> as unit, then the program must convert 33 ounces to grams. You must solve this program using a <code>switch</code> structure. If the unit is other than <code>g</code> or <code>o</code>, then the program must output an error message: \"Unexpected unit\", with no final result.</p>"},{"location":"02b.html#3-additional-exercises","title":"3. Additional exercises","text":"<p>Here you can find more additional exercises to practice with selective structures:</p> <p>Additional exercise 1</p> <p>Write a program that asks the user for their age. Use <code>if-else</code> statements to determine and display:</p> <ul> <li>\"Child\" if the age is less than 13.</li> <li>\"Teenager\" if the age is between 13 and 19.</li> <li>\"Adult\" if the age is 20 or older.</li> </ul> <p>Additional exercise 2</p> <p>Write a program that takes three numbers as input from the user. Use <code>if-else</code> to find and display the largest number among them.</p> <p>Additional exercise 3</p> <p>Ask the user to enter a year. Use an <code>if-else</code> statement to determine if the year is a leap year or not. A year is a leap year if it is divisible by 4 but not divisible by 100, unless it is also divisible by 400.</p> <p>Additional exercise 4</p> <p>Write a program that takes a single character input from the user. Use a <code>switch</code> statement to check whether the character is a vowel (<code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, <code>u</code>) or a consonant. Handle both uppercase and lowercase characters.</p> <p>Additional exercise 5</p> <p>Ask the user to input two numbers and an operator (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>). Use a <code>switch</code> statement to perform the corresponding arithmetic operation and display the result. Handle division by zero with an <code>if-else</code> check.</p> <p>Additional exercise 6</p> <p>Ask the user to input their grade as a percentage (0-100). Use <code>if-else</code> to determine and display:</p> <ul> <li>\"A\" for grades 90 and above.</li> <li>\"B\" for grades between 80 and 89.</li> <li>\"C\" for grades between 70 and 79.</li> <li>\"D\" for grades between 60 and 69.</li> <li>\"F\" for grades below 60.</li> </ul> <p>Additional exercise 7</p> <p>Ask the user to input a number between 1 and 12 representing a month. Use a <code>switch</code> statement to print the number of days in that month. Consider February to have 28 days.</p> <p>Additional exercise 8</p> <p>Write a program that asks the user for a number. Use an <code>if-else</code> statement to check if the number is even or odd and display the result.</p> <p>Additional exercise 9</p> <p>Ask the user to input a color (<code>red</code>, <code>yellow</code>, or <code>green</code>). Use a <code>switch</code> statement to display:</p> <ul> <li>\"Stop\" for red.</li> <li>\"Get Ready\" for yellow.</li> <li>\"Go\" for green.</li> </ul> <p>Handle invalid inputs with a default case.</p> <p>Additional exercise 10</p> <p>Ask the user for the current hour (0-23). Use <code>if-else</code> statements to determine:</p> <ul> <li>\"Morning\" if the hour is between 5 and 11.</li> <li>\"Afternoon\" if the hour is between 12 and 17.</li> <li>\"Evening\" if the hour is between 18 and 21.</li> <li>\"Night\" if the hour is between 22 and 4.</li> </ul>"},{"location":"02c.html","title":"Iterative structures","text":"<p>Iterative structures, also known as loops, can repeat a set of instructions a given number of times, or as long as a condition is true. This way, we avoid writing this set of instructions more than once if we want to repeat it. Now, we are going to see the main iterative structures provided by Java, although we will learn some more in later documents.</p>"},{"location":"02c.html#1-the-while-clause","title":"1. The \"while\" clause","text":"<p>This clause is used to repeat a given set of instructions while a given condition (or set of conditions) is true. For instance, this example counts from 1 to 10:</p> <pre><code>int n = 1;\nwhile (n &lt;= 10)\n{\n    System.out.println(n);\n    n++;\n}\n</code></pre> <p>As soon as the condition inside the while clause is false, the program exits the loop and runs next instruction beyond this loop. Take into account that this instruction can be simple or complex:</p> <pre><code>int n = 1;\nwhile (n &gt;= 1 &amp;&amp; n &lt;= 10)\n{\n    ...\n}\n</code></pre>"},{"location":"02c.html#2-the-dowhile-clause","title":"2. The \"do..while\" clause","text":"<p>This clause si similar to the previous one, but the condition is evaluated at the end of the loop, instead of the beginning. If we do the same loop than in previous example with a <code>do..while</code> structure, it would look like this.</p> <pre><code>int n = 1;\ndo\n{\n    System.out.println(n);\n    n++;\n} while (n &lt;= 10);\n</code></pre> <p>We will use this loop when we don't know how many iterations are expected, but we know that there will be (at least) one iteration. It is very usual when we ask the user to type something and then check the input and ask the user again. On the contrary, while loop is better when we don't even know if there will be one iteration.</p>"},{"location":"02c.html#3-the-for-clause","title":"3. The \"for\" clause","text":"<p>We will use this loop when we know how many iterations are expected. It has 3 parts on it:</p> <ul> <li>The declaration of a counter</li> <li>The condition to repeat the bucle (similar to while or do..while condition)</li> <li>The increment or decrement for the counter (generally to reach the end of the loop when the condition turns into false)</li> </ul> <p>The counter from 1 to 10 should be done with this structure preferably, and it would look like this:</p> <pre><code>for (int n = 1; n &lt;= 10; n++)\n{\n    System.out.println(n);\n}\n</code></pre> <p>Note that we can declare variables in <code>for</code> loops (and in the middle of other code, as in other languages such as C#).</p>"},{"location":"02c.html#31-another-for","title":"3.1. Another \"for\"","text":"<p>There is another way of using the <code>for</code> clause, applied to collections or arrays. It consists in using a variable with the same type, this way:</p> <pre><code>for (int number: numbers)\n    System.out.println(\"\" + number);\n</code></pre> <p>where <code>numbers</code> is expected to be a collection or array of integers. This structure is equivalent to the <code>foreach</code> structure of other languages such as C#, and is expected to be used in a read-only way (only to check the values, but not to modify them).</p> <p>Exercise 1</p> <p>Create a program called GroupPeople that asks the user to enter how many people is going to attend to a conference. The program must create groups of (preferably) 50 people. Whenever this is not possible, then it will attempt to create groups of 10 people, and finally it will create groups of 1 person. The program must output how many groups of each category are necessary. For instance, if 78 people are going to attend to the conference, then we need 1 group of 50 people, 2 groups of 10 people and 8 groups of 1 people.</p> <p>Exercise 2</p> <p>Create a program called SumDigits that asks the user to enter numbers (integer values) until he enters 0. The program must sum up all the numbers entered by the user and then show the final result, and how many digits it has. For instance, if the user types 12, 20, 60, 33, 99 and 0, then the program must output: \"The result is 224, and it has 3 digits\".</p>"},{"location":"02d.html","title":"Some additional concepts","text":"<p>In this document we are going to learn some additional concepts related with the control structures seen in this unit. We'll see how to work with more complex loop structures, and some additional elements that we can add to these loops. Also, we will learn some basic rules to write clean code regarding these control structures.</p>"},{"location":"02d.html#1-nested-loops","title":"1. Nested loops","text":"<p>The iterative structures that we have learnt in previous documents can be combined, so that we can place one of them inside another. This complex structure is also called nested loop. It can be a do..while inside a for, or a for inside another for, or any other combination.</p> <p>For instance, the following code prints a square filled with asterisks, whose size is determined by variable size (we assume that this variable has been previously declared and assigned):</p> <pre><code>for (int i = 1; i &lt;= size; i++)\n{\n    for (int j = 1; j &lt;= size; j++)\n    {\n        System.out.print(\"*\");\n    }\n    System.out.println();\n}\n</code></pre> <p>Exercise 1</p> <p>Write a program called Triangle in which we ask a user to enter a height (integer) and then we write a reversed triangle like the following one (assuming a height of 5):</p> <pre><code>*****\n ****\n  ***\n   **\n    *\n</code></pre> <p>Exercise 2</p> <p>Create a program called Counter that asks the user to write numbers between 1 and 100. The program must keep asking the number until it is a number in the valid range. For each valid number, it must count from this number to 1 in descending order.</p>"},{"location":"02d.html#2-using-break-and-continue","title":"2. Using \"break\" and \"continue\"","text":"<p>There are some special instructions that can be used inside loops to alter its natural behavior. These instructions are break and continue.</p> <p>The break instruction exits the loop in which it is placed. For instance, this loop only counts from 1 to 5, because the break instruction exits before completing the whole count:</p> <pre><code>for (int i = 1; i &lt;= 10; i++)\n{\n    System.out.println(i);\n    if (i == 5)\n        break;\n}\n</code></pre> <p>The continue instruction forces a new iteration of the loop, without running the instructions below it. For instance, this loop counts from 1 to 10, but it does not print number 5, because continue instruction goes back to the beginning of the loop when i is 5, without printing this value at the end of the loop:</p> <pre><code>for (int i = 1; i &lt;= 10; i++)\n{\n    if (i == 5)\n        continue;\n    System.out.println(i);\n}\n</code></pre> <p>These two instructions are NOT recommended in our programs, since they can be easily avoided in order to make our code more understandable. In the first case, if we just want to count from 1 to 5, we should just define a for loop from 1 to 5. In the second case, if we don't want to print number 5 in the screen, we can specify this condition in the if clause:</p> <pre><code>for (int i = 1; i &lt;= 10; i++)\n{\n    if (i != 5)\n        System.out.println(i);\n}\n</code></pre>"},{"location":"02d.html#3-writing-clean-code-spacing","title":"3. Writing clean code. Spacing.","text":"<p>In 01e previous documents we have seen some basic rules to write clean code, but now that we have learnt some additional concepts regarding control structures, our code can get a little bit more complex, and we need to apply some additional rules to keep it tidy.</p> <p>Appropriate code formatting and spacing tells the reader that the programmer has paid attention to every single detail of the program. However, when we find a bunch of lines of code incorrectly indented and/or spaced, we may think that the same inattention may be present in other aspects of the code.</p>"},{"location":"02d.html#31-vertical-spacing","title":"3.1. Vertical spacing","text":"<p>Let's see some simple rules to format and space your code vertically:</p> <ul> <li>As each group of lines represents a task, these groups should be separated from each other with a blank line. In a Java program, for instance, we would have something like this (pay attention to where blank lines are added):</li> </ul> <pre><code>import java.util.Scanner;\n\npublic class Program \n{\n    public static void main(String[] args) \n    {\n        int personAge;\n        String personName;\n        Scanner sc = new Scanner(System.in);\n\n        System.out.println(\"Tell me your name:\");\n        personName = sc.nextLine();\n\n        System.out.println(\"Tell me your age:\");\n        personAge = sc.nextInt();\n\n        if (personAge &gt; 18)\n            System.out.println(\"You are an adult, \" + personName);\n    }\n}\n</code></pre> <ul> <li>Concepts that are tightly related should be placed together vertically. For instance, if we declare two variables to store the name and age of a person, then we should place these declarations one after another, with no separations. This means that we should not add any comment that breaks the union:</li> </ul> <pre><code>String personName;\n/* \n * This comment should not be written here!\n */\nint personAge;\n</code></pre> <ul> <li>Opening braces are put either at the end of the lines that need them (typical in programming languages such as Java or JavaScript) or at the beginning of the following line, with the same indentation than previous line (typical in programming languages such as C or C#). In this last case, they can act as blank lines of separation between blocks</li> </ul> <pre><code>// Java style (opening brace is NOT considered a blank line)\nif (condition) {\n    ...\n}\n\n// C# style (opening brace can be considered a blank line)\npublic static void Main()\n{\n    if (condition)\n    {\n        ...\n    }\n...\n</code></pre> <p>Regarding opening braces, you can decide which of these patterns you want to apply, but you must:</p> <ul> <li>Apply always the same pattern</li> <li>Use the same pattern than all the people in your team</li> </ul>"},{"location":"02d.html#32-horizontal-formatting","title":"3.2. Horizontal formatting","text":"<p>Regarding horizontal spacing or formatting, there are also some simple rules that we can follow.</p> <ul> <li>A line of code should be short (maybe 80 or 100 characters length, as much). Some IDEs show a vertical line (typically red) that sets the \"ideal\" limit for the length of each line. If it is going to be longer, we should cut it and divide the code in multiple lines. You can also apply other rules to determine the maximum line width: you should never have to scroll to the right to see your code, and it should be printable with the same appearance in a vertical page.</li> </ul> <pre><code>if ((personAge &gt; 18 &amp;&amp; personAge &lt;= 65) ||\n    (personName.equals(\"John\")) || (personName.equals(\"Mary\"))) \n{\n    ...\n}\n</code></pre> <ul> <li>Horizontal spacing helps us associate things that are related, and disassociate things that are not. For instance, operators should be separated with a whitespace from the elements they are operating:</li> </ul> <pre><code>int average = (number1 + number2) / 2;\n</code></pre> <ul> <li>Do not align the variable names vertically. It was very typical in old programming languages, such as assembly, but it makes no sense in modern programming languages, where there are lots of different data types. If you do this, you might tend to read the variable names without paying attention to their data types:</li> </ul> <pre><code>StringBuilder longText;\nint           textSize;\nString        textToFindAndReplace;\n</code></pre> <ul> <li>The indentation is important, since it establishes a hierarchy. There are elements that belong to the whole source file, and others that are part of a concrete block. Indentation help us determine the scope of a group of instructions. In this way:</li> <li>Class name is not indented</li> <li>Functions or other elements inside a class are indented one level</li> <li>Implementation of these functions are indented two levels</li> <li>Block implementations inside function code (code of if or while clauses, for instance) are indented three levels</li> <li>... etc.</li> </ul> <pre><code>public class MyClass \n{\n    public static void main(String[] args) \n    {\n        System.out.println(\"Hello\");\n        if (...) \n        {\n            System.out.println(\"Inside an if\");\n        }\n    }\n}\n</code></pre>"},{"location":"03a.html","title":"Arrays","text":"<p>Static data types store values so that the total size of these values does not change along the program execution. In this document we are going to explain what an array is and how to use them to store many values of the same type.</p> <p>An array is a set of data of the same type (integers, texts, characters...) grouped in a single variable. Data is structured so that we can access each element by its index or position in the array, starting at 0. The total number of elements contained in the array must be known before creating the array. So the size of the array is constant, and can't be changed along the program execution.</p>"},{"location":"03a.html#1-unidimensional-arrays","title":"1. Unidimensional arrays","text":"<p>Unidimensional arrays are the simplest type of arrays. They consist in a sequence of data with a single index to access each position. We use square brackets <code>[]</code> to declare a variable as an array, and the <code>new</code> operator to determine its size (number of positions). We can declare the array variable in one line and determine its size in another, different line (once we know the size that we need for the array) or do it all in the same line:</p> <pre><code>int[] numbers = new int[10];        // Array of 10 integers\n\nfloat[] numbers;\nint n;\nScanner sc = new Scanner(System.in);\nSystem.out.println(\"Enter the array size:\");\nn = sc.nextInt();\nnumbers = new int[n];               // Array of n floats\n</code></pre> <p>Square brackets can also be placed after the variable name, although we recommend you to place them before, so we can easily see that this variable is an array:</p> <pre><code>int numbers[] ...\n</code></pre> <p>In order to access the elements of an array, we set the desired index inside the square brackets, starting at position 0. This way we can, for instance, specify a concrete value for each element in the array:</p> <pre><code>numbers[0] = 3;\nnumbers[1] = 6;\n...\n</code></pre> <p>We can also use these indexes to check the concrete value of a position:</p> <pre><code>System.out.println(numbers[1]);\nSystem.out.println(numbers[2] * numbers[4]);\n</code></pre> <p>In order to check the total number of elements of an array, we can use its <code>length</code> property. For instance, inside a <code>for</code> loop:</p> <pre><code>for (int i = 0; i &lt; numbers.length; i++)\n{\n    System.out.println(numbers[i]);\n}\n</code></pre> <p>Alternatively, we can use this <code>for</code> structure to explore the contents of the array. This structure is particularly useful if we just want to check (not change) the values of the array:</p> <pre><code>for (int n: numbers)\n{\n    System.out.println(n);\n}\n</code></pre> <p>Finally, we can set the initial values of the array when we declare it, placing these values into curly braces, separated by commas:</p> <pre><code>int[] numbers = {1, 2, 3, 4};       // Array of 4 numbers\n</code></pre>"},{"location":"03a.html#11-array-search","title":"1.1. Array search","text":"<p>If we want to search a given value inside an array, we usually explore the array from the beginning to the end, looking for that value. We may need to:</p> <ul> <li>Determine if a given value exists in the array. In this case, we can finish as soon as we find this value in the array. For instance, this code checks if number 15 exists in an integer array. Note that we use a <code>while</code> loop along with a boolean variable to stop checkin whenever we find the value:</li> </ul> <pre><code>boolean found = false;\nint i = 0;\nwhile (!found &amp;&amp; i &lt; numbers.length)\n{\n    if (numbers[i] == 15)\n    {\n        found = true;\n    }\n    else\n    {\n        i++;\n    }\n}\n\nif (found)\n{\n    System.out.println(\"Number found at position \" + i);\n}\nelse\n{\n    System.out.println(\"Number not found\";\n}\n</code></pre> <ul> <li>Check how many times a value exists in an array. In this second case, we need to explore the whole array. For instance, this code counts the occurrences of number 15 in an integer array. To do this, we can better use a <code>for</code> structure with a counter:</li> </ul> <pre><code>int counter = 0;\nfor (int i = 0; i &lt; numbers.length; i++)\n{\n    if (numbers[i] == 15)\n    {\n        counter++;\n    }\n}\n\nSystem.out.println(\"Numbe 15 has been found \" + counter + \" times\");\n</code></pre> <p>Looking for minimum / maximum</p> <p>In some situations, we may need to find the maximum or minimum value in an array. An appropriate approach for this consists in:</p> <ol> <li>Assign this minimum/maximum value to position 0. In other words, we suppose that this first number will be the minimum or maximum we are looking for.</li> <li>Explore the rest of the array (from position 1) and check if there is a number that exceeds previous minimum/maximum. If so, we need to update this minimum/maximum.</li> </ol> <p>This example finds the maximum value in an integer array called numbers:</p> <pre><code>int maximum = numbers[0];\nfor (int i = 1; i &lt; numbers.length; i++)\n{\n    if (numbers[i] &gt; maximum)\n    {\n        maximum = numbers[i];\n    }\n}\n\nSystem.out.println(\"The maximum is \" + maximum);\n</code></pre>"},{"location":"03a.html#12-array-sort","title":"1.2. Array sort","text":"<p>Sorting arrays is a task that consists in placing each value in its appropriate position, according to a sorting criteria. For instance, if we want to sort an integer array in ascending order, we need to make sure that every number is placed before the numbers that are higher.</p> <p>There are many different algorithms to face this task. One of the most common are the bubble algorithm and the direct exchange algorithm.</p> <p>Bubble algorithm it compares two consecutive numbers of the array and, if they are not ordered, it swaps their values. At the end of this process, the highest/lowest value will be placed at the end of the array (depending on whether we are sorting in ascending or descending order). We need to replace this process N times to sort the N values of the array. This is the algorithm in Java to sort an array in ascending order:</p> <pre><code>for (int i = 0; i &lt; numbers.length; i++)\n{\n    for (int j = 0; j &lt; numbers.length - i - 1; j++)\n    {\n        if (numbers[j] &gt; numbers[j+1])\n        {\n            int aux = numbers[i];\n            numbers[i] = numbers[j];\n            numbers[j] = aux;\n        }\n    }\n}\n</code></pre> <p>Note that, in every iteration of j variable, we finish one position before previous iteration, because the latest positions of the array have already been sorted in earlier iterations.</p> <p>The direct exchange algorithm explores the whole array for every position i, looking for for the lowest/highest element, and places this element in this i position. This is the algorithm in Java for ascending order:</p> <pre><code>for (int i = 0; i &lt; numbers.length - 1; i++)\n{\n    for (int j = i + 1; j &lt; numbers.length; j++)\n    {\n        if (numbers[i] &gt; numbers[j])\n        {\n            int aux = numbers[i];\n            numbers[i] = numbers[j];\n            numbers[j] = aux;\n        }\n    }\n}\n</code></pre> <p>Note that j index is always greater than i index, so if element at position i is greater than element at position j, we need to swap their values to keep the array sorted.</p> <p>All these sorting algorithms have a complexity of O(n<sup>2</sup>), which means that, for an array of size n we need to do n<sup>2</sup> iterations, approximately, to sort the whole array. There are other approaches, such as the quicksort algorithm, which are faster, but much more difficult to understand and type.</p> <p>Also, Java provides an automatic sorting method for arrays, through <code>Arrays.sort</code> instruction. If array is made of simple data (such as integers, strings or floats, for instance), this instruction automatically sorts the array in ascending order. We need to import <code>java.util</code> package in order to use this instruction.</p> <pre><code>import java.util.Arrays;\n...\nint[] numbers = { 4, 6, 2, 8, 3};\nArrays.sort(numbers);\n</code></pre>"},{"location":"03a.html#2-bidimensional-arrays","title":"2. Bidimensional arrays","text":"<p>Although we can use unidimensional arrays for most of the tasks that we can do with arrays, in some situations we may need to store the information in a table, for instance, with its rows and columns, or store different sequences of data in separate indexes. To do this, we need to use bidimensional arrays.</p> <p>In bidimensional arrays we need two indexes: one to refer to the row we are interested, and another one to point at the column inside this row. We need two pairs of square brackets when we declare a bidimensional array. Inside each pair of brackets we specify the total number of rows and columns of the array, respectively:</p> <pre><code>int[][] table = new int[3][10];     // 3 rows, 10 columns\n</code></pre> <p>We refer to each column by its row number, and then column number (both starting at 0):</p> <pre><code>table[0][2] = 2;        // 1st row, 3rd column\ntable[2][8] = 12;       // 3rd row, 9th column\n</code></pre> <p>If we want to explore bidimensional arrays, we need a nested loop: In the outer loop we can explore rows/columns, and in the inner loop we explore the opposite. We can use the <code>length</code> property of each dimension to determine its size. This example shows the contents of an array row by row:</p> <pre><code>for (int i = 0; i &lt; table.length; i++)\n{\n    for (int j = 0; j &lt; table[i].length; j++)\n    {\n        System.out.print(table[i][j] + \" \");\n    }\n    System.out.println();\n}\n</code></pre> <p>Note that <code>table.length</code> stores the number of rows, and <code>table[i].length</code> the number of columns for row i.</p> <p>Alternatively, we can also establish a different number of columns for each row. This is called an array of arrays. To do this, we need to leave empty the second pair of square brackets when we declare the array:</p> <pre><code>int[][] data = new int[3][];        // 3 rows\n</code></pre> <p>Then, we need to go row by row establishing the number of columns for this row:</p> <pre><code>data[0] = new int[3];       // 1st row: 3 columns\ndata[1] = new int[5];       // 2nd row: 5 columns\ndata[2] = new int[8];       // 3rd row: 8 columns\n</code></pre> <p>We can also establish the default values of the whole array in the same way that we did for unidimensional arrays. In this case, the data of each row is enclosed in curly braces as well:</p> <pre><code>int[][] someMoreData = {\n    {1, 2, 3},\n    {4, 5, 6, 7},\n    {8, 9}\n};\n</code></pre> <p>Exercise 1</p> <p>Create a program called MatrixAddition that asks the user to enter two bidimensional matrices or tables of 3 rows and columns, and then prints the result of adding them. In order to add two matrices, you must do it cell by cell:</p> <pre><code>result[i][j] = matrixA[i][j] + matrixB[i][j]\n</code></pre> <p>Exercise 2</p> <p>Create a program called MarkCount that asks the user to enter 10 marks (integers between 0 and 10). The program must output how many marks of each type have been typed. For instance, if the user types these marks: 1, 7, 5, 7, 2, 6, 7, 3, 5, 8, then the program must output: </p> <pre><code>Marks per category: \n0: 0 marks\n1: 1 marks\n2: 1 marks\n3: 1 marks\n4: 0 marks\n5: 2 marks\n6: 1 marks\n7: 3 marks\n8: 1 marks\n9: 0 marks\n10: 0 marks\n</code></pre>"},{"location":"03b.html","title":"Enums","text":"<p>Enum types represent a data type with a finite or concrete set of possible values. For instance, the seasons of the year, of the days of the week are good examples of enums.</p>"},{"location":"03b.html#1-basic-enum-management","title":"1. Basic enum management","text":"<p>If we want to declare an enum type, we use the word <code>enum</code> followed by a name. This will be the name that we will use to refer to this data type when we declare variables. Then, between curly braces, we specify the values that this enum can have. </p> <p>For instance, this way we can declare an enum for the days of the week:</p> <pre><code>enum dayOfWeek { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, \n    FRIDAY, SATURDAY, SUNDAY};\n</code></pre> <p>This enum should be declared out of the class, as an external data type. Then, we can declare variables of this enum in our program, this way:</p> <pre><code>dayOfWeek aDay = dayOfWeek.FRIDAY;\n</code></pre> <p>Every value inside an enum as a numeric index associated, starting at 0. This way, we can either work with the enum value or with its inner index, if we want to, using <code>ordinal()</code> instruction.</p> <pre><code>dayOfWeek aDay = dayOfWeek.FRIDAY;\nSystem.out.println(aDay);           // Prints FRIDAY\nSystem.out.println(aDay.ordinal()); // Prints 4\n</code></pre> <p>If we want to read an enum value from the keyboard, this value can be either the enum value (for instance, FRIDAY), or the ordinal number for this value (4, if we want to refer to FRIDAY). We can use <code>valueOf</code> or <code>value</code> instructions, respectively, to match the value typed by the user with the value stored in the enum:</p> <pre><code>Scanner sc = new Scanner(System.in);\nSystem.out.println(\"Enter a day of the week:\");\ndayOfWeek aDay1 = dayOfWeek.valueOf(sc.nextLine());  // If user types FRIDAY\ndayOfWeek aDay2 = dayOfWeek.values()[sc.nextInt()];  // If user types 4\n</code></pre> <p>Exercise 2</p> <p>Create a program called MonthEnum.java that defines an enum to store the months of the year. Then, ask the user to type a month and tell him/her the number of days of this month (we assume that February has 28 days).</p>"},{"location":"03c.html","title":"Strings","text":"<p>If we want to work with strings in Java, we have the <code>String</code> class, with some useful methods that we can use: convert to upper or lower case, get a substring, find a text... You can have a whole list of available methods in the String official documentation. Let's explore some of them.</p>"},{"location":"03c.html#1-basic-string-management","title":"1. Basic string management","text":"<p>We can create a string in many different ways: with a constant value, asking the user to type something...</p> <pre><code>String text = \"Hello world\";\nString name = scanner.nextLine();\n</code></pre> <p>We can also concatenate strings with the <code>+</code> operator, or in some cases with <code>+=</code> operator (if we want to add a string at the end of another).</p> <pre><code>text = text + \", how are you?\";\n</code></pre> <p>We can't treat a string as a char array (as in C++ or C#), and get to each character with the corresponding index between square brackets. If we want to get the character at a given position, we need to use the <code>charAt</code> method. We can also get the length of a string with its <code>length()</code> method.</p> <pre><code>for (int i = 0; i &lt; text.length(); i++)\n    System.out.println(text.charAt(i));\n</code></pre> <p>Regarding conversions, we can easily convert a non-string variable into a string just joining it with an empty string. Alternatively, we can also use <code>String.valueof</code> instruction for this purpose:</p> <pre><code>int number = 23;\nString text = \"\" + number;\nString text2 = String.valueOf(number);\n</code></pre>"},{"location":"03c.html#2-some-advanced-operations-with-strings","title":"2. Some advanced operations with strings","text":"<p>In this section we are going to explore some more advanced features of strings, such as comparing strings, taking substrings in a string variable, splitting a string in parts and so on.</p>"},{"location":"03c.html#21-string-comparison","title":"2.1. String comparison","text":"<p>We can compare two strings (alphabetically) in some different ways. If we want to know which is greater or lower, we can use the <code>compareTo</code> method. It returns a negative number if the string on the left is lower, 0 if both strings are equal, or a positive number if the string on the right is lower.</p> <pre><code>if (text1.compareTo(text2) &lt; 0)\n    System.out.println(\"Second text is greater\");\n</code></pre> <p>If we want to check if two strings are equal, we use the <code>equals</code> method (remember, we must NOT use the <code>==</code> comparator for this purpose). We can also use <code>equalsIgnoreCase</code> method if we want to ignore if strings are in uppercase or lowercase.</p> <pre><code>if (text1.equals(text2))\n    System.out.println(\"Texts are equal\");\n\nif (\"hello\".equalsIgnoreCase(\"HELLO\"))\n    System.out.println(\"Text are equal ignoring cases\");\n</code></pre>"},{"location":"03c.html#22-finding-texts-in-strings","title":"2.2. Finding texts in strings","text":"<p>We have a wide variety of instructions inside string elements to find texts. For instance, if we only want to know if a text contains a given subtext, we can use <code>contains</code> method, that returns a boolean:</p> <pre><code>if (text.contains(\"hello\"))\n    System.out.println(\"There is a 'hello' in the text\");\n</code></pre> <p>If we want to know the index at which a given subtext appears, we can choose among <code>indexOf</code> (gets the first occurrence of the subtext, or -1 if it does not exist) or <code>lastIndexOf</code> (gets the last occurrence of the subtext, or -1 if it does not exist)</p> <pre><code>int pos = text.indexOf(\"hello\");\nif (pos &gt;= 0)\n    System.out.println(\"There is a 'hello' at position\" + pos);\n</code></pre> <p>If we want to know if a text starts with a given prefix or ends with a given suffix, we use the <code>startsWith</code> or <code>endsWith</code> methods, which return a boolean</p> <pre><code>if (text.startsWith(\"Hello\"))\n    System.out.println(\"Text starts with 'Hello'\");\n</code></pre>"},{"location":"03c.html#23-string-conversions","title":"2.3. String conversions","text":"<p>We can convert the whole string to upper and lower case with <code>toUpperCase</code> and <code>toLowerCase</code> methods:</p> <pre><code>String text = \"Hello world\";\nString textUpper = text.toUpperCase(); // \"HELLO WORLD\"\n</code></pre> <p>We can get a substring of a given string with the <code>substring</code> method. It has two parameters: the index from which we must start getting the substring (starting at 0), and the index at which we must stop getting the string (excluded). If this second parameter is omitted, it returns the resulting string from the initial index to the end of the string. For instance, <code>\"Welcome\".substring(3, 5)</code> returns \"co\" (indexes 3 and 4 of the string).</p> <p>We can replace a substring with another one with the <code>replace</code> method. It has two arguments: the old text and the new text, and it returns the resulting string. It replaces EVERY occurrence of the old string with the new string.</p> <pre><code>String result = text.replace(\"Hello\", \"Good morning\");\n</code></pre> <p>There are some other options for this purpose, such as <code>replaceAll</code> method, which uses regular expressions to match the text to be replaced, or <code>replaceFirst</code>, which only replaces the first occurrence of the old text with the new one.</p> <p>We can split a string using a delimiter with the <code>split</code> method. It returns an array with the resulting parts.</p> <pre><code>String text = \"Hello world\";\nString[] parts = text.split(\" \"); \n// Two parts, \"Hello\" and \"world\"\n</code></pre> <p>Finally, we can also do the opposite operation, this is, joining parts of a string with a common delimiter, using <code>String.join</code> method. We need to specify the delimiter, and then the array or sequence of texts to be joined.</p> <pre><code>String[] parts = {\"One\", \"Two\", \"Three\"};\nString result = String.join(\",\", parts);   // \"One,Two,Three\"\n</code></pre> <p>Exercise 1</p> <p>Create a program called SortJoin that asks the user to enter a list of names separated by whitespaces. Then, the program must split the string, sort the names alphabetically and output them separated by commas. For instance, if the user types this name list: <code>Susan Kailey William John</code>, then the program must output <code>John, Kailey, Susan, William</code>.</p> <p>Exercise 2</p> <p>Create a program called CheckMessages that asks the user to type 10 strings. The program must store them in an array, and then replace the text \"Eclipse\" with \"IntelliJ\" in every string that contains \"Eclipse\". The program must output the updated version of the strings stored in the array, once the replacement has been done.</p> <p>Exercise 3</p> <p>Create a program called LispChecker. LISP is a programming languages where every instruction is enclosed in parentheses. This could be a set of instructions in LISP:</p> <pre><code>(let ((new (x-point a y))))\n</code></pre> <p>You must implement a program that takes a string with LISP instructions (just one string) and then check if the parentheses are correct (this is, the number of opening parentheses and closing parentheses are the same).</p>"},{"location":"03c.html#3-strings-and-static-data","title":"3. Strings and static data","text":"<p>This section is about static data types. We have seen that these types don't change their size along program execution. However, we can increase or decrease the size of a string by concatenating or removing pieces of text. So, how can we say that a string is a static data size?</p> <p>We need to take into account that Strings in Java are ALWAYS immutable, as in many other programming languages. So, every transformation that we need to do over a string needs to be assigned to a new (or old) variable. That's why methods such as <code>toUppeCase</code> or <code>substring</code> always return a new string, they never affect the original string. However, we can always re-assign the old string with this new value:</p> <pre><code>String text = \"Hello world\";\n\n// This way we don't affect original text\nString newText = text.toUpperCase();\n\n// This way we modify original variable, and it points\n// to this new text (old text is lost in memory)\ntext = text.toUpperCase();\n</code></pre> <p>Due to this, joining these instructions over strings is not very efficient, since we need to create a new string in memory for every new operation. Instead of this, we can also use StringBuilder element instead.</p>"},{"location":"03c.html#31-using-stringbuilder","title":"3.1. Using StringBuilder","text":"<p>Through <code>StringBuilder</code> element we can create editable strings. This increases the speed of certains operations, and decreases the use of memory. In order to create these elements, we just need to use <code>new</code> operator with the initial value of the string to be stored:</p> <pre><code>StringBuilder text = new StringBuilder(\"Hello\");\n</code></pre> <p>Then, we have some methods available to perform some editing tasks:</p> <ul> <li><code>append</code> method lets us add new strings at the end of the existing one, just like <code>+</code> operator does with original strings</li> <li><code>delete</code> method removes a fragment in the string, given the initial and final position to be removed.</li> <li><code>insert</code> method adds a new string in the middle of the existing one (to be more precise, at the given starting index)</li> <li><code>toString</code> method converts this StringBuilder element into a common String</li> <li>Besides, we have some other methods available, whose behavior is similar to the original methods in String: <code>charAt</code>, <code>length</code>, <code>indexOf</code>, <code>lastIndexOf</code>...</li> </ul> <p>Here you can find an example of usage:</p> <pre><code>StringBuilder text = new StringBuilder(\"Hello\");\ntext.append(\" world\");                  // text = \"Hello world\"\ntext.insert(5, \" my\");                  // text = \"Hello my world\"\nSystem.out.println(text.toString());    // \"Hello my world\"\nSystem.out.println(text.indexOf(\"my\")); // 6\ntext.delete(5, 8);                      // text = \"Hello world\"\n</code></pre>"},{"location":"03d.html","title":"Using regular expressions","text":"<p>A regular expression (or regex in its abbreviated form) is a sequence of special characters that lets us detect some patterns in texts. For instance, an id card made of 8 digits and an uppercase letter, or an e-mail containing a <code>@</code>. Using regular expressions, we can easily detect these patterns in a given text and, also, force a text to meet a given pattern when it's being entered by the user.</p>"},{"location":"03d.html#1-basic-regex-syntax","title":"1. Basic regex syntax","text":"<p>In order to work with regular expressions in Java, we need to use some classes from <code>java.util.regex</code> package. To be more precise, we are going to rely on:</p> <ul> <li><code>Pattern</code> class, that lets us define a given pattern for a regular expression</li> <li><code>Matcher</code> class, that lets us check if a givent text meets a given Pattern.</li> </ul>"},{"location":"03d.html#11-pattern-class","title":"1.1. Pattern class","text":"<p>Regarding <code>Pattern</code> class, there are a couple of interesting methods inside it that we need to manage:</p> <ul> <li><code>compile</code>: it creates a Pattern object for a given regular expression</li> <li><code>matcher</code>: it returns a Matcher object to match a pattern with a text</li> </ul>"},{"location":"03d.html#12-matcher-class","title":"1.2. Matcher class","text":"<p>Inside <code>Matcher</code> class, we can use these methods:</p> <ul> <li><code>find</code>: checks if a given pattern is found in a text</li> <li><code>matches</code>: checks if the whole text meets a pattern (not only a part of it). There is also a static method in Pattern class, <code>Pattern.matches</code> that produces the same result.</li> </ul>"},{"location":"03d.html#13-example","title":"1.3. Example","text":"<p>Let's check in the following example if a text contains a digit between 0 and 9. This digit can be represented by the symbol <code>\\d</code>, so we use it inside the pattern, this way:</p> <pre><code>String text = \"Hi, my name is Nacho and I'm 44 years old\";\nPattern p = Pattern.compile(\"\\\\d\");\nMatcher m = p.matcher(text);\n\nif (m.find())\n{\n    System.out.println(\"The text contains digit(s)\");\n}\nelse\n{\n    System.out.println(\"The text does not contain any digit\");\n}\n</code></pre> <p>Note that we need to escape the <code>\\</code> when we place it inside the string, as <code>\\\\d</code></p>"},{"location":"03d.html#14-some-basic-symbols","title":"1.4. Some basic symbols","text":"<p>In this table you can find some basic symbols that we can use inside patterns.</p> Symbol Meaning <code>x</code> 'x' character <code>\\t</code> Tabulation <code>\\n</code> New line <code>[abc]</code> Character 'a', 'b' or 'c' <code>[^abc]</code> Anything but characters 'a', 'b' or 'c' <code>[a-zA-Z]</code> Range from 'a' to 'z' or from 'A' to 'Z' <code>.</code> Any character <code>^</code> Beginning of line (there's nothing before) <code>$</code> End of line (there's nothing after) <code>\\d</code> Digit from 0 to 9 <code>\\D</code> Anything but a digit <code>\\s</code> Spacing char (white space, tab, new line...) <code>\\S</code> Anything but a spacing char <code>\\w</code> Alphanumeric char (letters, digits and underscore) <code>\\W</code> Anything but an alphanumeric char <code>(one|two)</code> Text 'one' or text 'two' <p>With these symbols, we can made expressions such as:</p> <ul> <li>Text finished with a dot (we need to escape the dot with <code>\\</code>):</li> </ul> <pre><code>Pattern p = Pattern.compile(\"\\\\.$\");\n</code></pre> <ul> <li>Text made of 4 digits</li> </ul> <pre><code>Pattern p = Pattern.compile(\"^\\\\d\\\\d\\\\d\\\\d$\");\n</code></pre> <ul> <li>The seasons of the year:</li> </ul> <pre><code>Pattern p = Pattern.compile(\"(winter|spring|summer|autumn)\");\n</code></pre> <p>Exercise 1</p> <p>Create a project called CarIDCheck that asks the user to enter a cad id, and checks if it's made of 4 digits followed by 3 uppercase letters. We are not going to check if these letters are vowels or not, we just check if they are uppercase.</p>"},{"location":"03d.html#2-some-complex-expressions","title":"2. Some complex expressions","text":"<p>In order to make some more complex expressions, we need to make use of some additional symbols in the pattern. To be more precise, we need to specify the cardinality of some parts of the expressions, in orde to shorten them. This is a list of cardinality symbols that you can use in your patterns:</p> Symbol Meaning <code>x?</code> x symbol appears 0 or 1 times <code>x+</code> x symbol appears 1 or more times <code>x*</code> x symbol appears 0 or more times <code>x{n}</code> x symbol appears n times <code>x{n,}</code> x symbol appears at least n times <code>x{n, m}</code> x symbol appears between n and m times (both included) <p>This way, we can easily check: </p> <ul> <li>If a text is made of 4 digits with this:</li> </ul> <pre><code>Pattern p = Pattern.copile(\"^\\\\d{4}$\");\n</code></pre> <ul> <li>An id card made of 8 digits and an uppercase letter:</li> </ul> <pre><code>Pattern p = Pattern.copile(\"^\\\\d{8}[A-Z]$\");\n</code></pre> <p>Exercise 2</p> <p>Repeat previous exercise using cardinality symbols</p> <p>Exercise 3</p> <p>Create a program called EmailChecker that asks the user to enter an e-mail and checks if it's valid. We will consider that a valid e-mail will be made of alphanumeric characters (at least one), followed by a <code>@</code>, one or more alphanumeric characters, a dot and one or more alphanumeric characters. So <code>myEmail@one.com</code> is a valid e-mail, but <code>myOtherMail@aaa</code> is not.</p>"},{"location":"03d.html#3-using-groups","title":"3. Using groups","text":"<p>Groups lets us isolate some parts of a text that meet a given pattern, so we can treat them later in the code. We can use <code>group</code> method inside <code>Matcher</code> class to detect groups, and each group must be defined between parentheses <code>(...)</code> in the pattern. Groups are explored from left to right.</p> <p>Let's see how groups work with the following example: we are going to get every sequence of 4 digits in a text:</p> <pre><code>String text = \"Einstein was born in 1879 and Edison in 1847\";\nPattern p = Pattern.compile(\"(\\\\d{4})\");\nMatcher m = p.Matcher(text);\n\nif (!m.find())\n{\n    System.out.println(\"The text has no sequence of 4 digits\");\n}\nelse\n{\n    do\n    {\n        String data = m.group();\n        System.out.println(\"Found \" + data);\n    }\n    while(m.find());\n}\n</code></pre> <p>As you can see, every time we call <code>group</code> method we move to next group identified in the text, until there are no more matches pending.</p>"},{"location":"03d.html#31-multiple-groups","title":"3.1. Multiple groups","text":"<p>We can define more than one group in a single expression. In this case, <code>group</code> method admits an additional parameter indicating which of the groups we are choosing (starting from 1).</p> <p>The following example identifies names and surnames in a text:</p> <pre><code>String text = \"Albert Einstein was born in 1879\" + \n    \" and Thomas Edison in 1847\";\nPattern p = Pattern.compile(\"([A-Z][a-z]+) ([A-Z][a-z]+)\");\nMatcher m = p.Matcher(text);\n\nif (!m.find())\n{\n    System.out.println(\"The text has no names\");\n}\nelse\n{\n    do\n    {\n        String name = m.group(1);\n        String surname = m.group(2);\n        System.out.println(\"Found \" + name + \" \" + surname);\n    }\n    while(m.find());\n}\n</code></pre> <p>It would output Found Albert Einstein in the first iteration and Found Thomas Edison in the second one.</p> <p>Exercise 4</p> <p>Create a program called HourIdentifier that looks for hours in a text. An hour is made of two digits, followed by <code>:</code>, and two digits. For instance, <code>08:45</code>. We are not going to check if the hour is valid or not, we just need to identify them. Then, store these hours in a list and show them in ascending order. </p>"},{"location":"04a.html","title":"Function definition","text":"<p>The programs that we have been typing so far are becoming more and more complex. It may be hard to maintain or keep clean a piece of code of some hundred lines and, besides, we may need to repeat the same piece of code in many parts of our program. In order to keep our code clean an reusable, we need to divide it into functions or modules. In this section we'll learn what a function is, how to define functions in Java and how to use them.</p>"},{"location":"04a.html#1-basic-function-management","title":"1. Basic function management","text":"<p>Functions let us arrange our code so that we can re-use a piece of code many times without having to duplicate the code. We just assign this piece of code a name (function name) and then we can call this code from other parts of our program. This paradigm is also called modular programming, since we define modules or functions to group our code in small subtasks, and call each subtask whenever we need it.</p> <p>If we want to use functions within a class, we can declare them as <code>public static</code> if we want to call them from anywhere. We will learn in next units how to declare other types of functions and how to set their visibility, but for now we are going to deal with public, static functions.</p> <p>When defining a function, we need to specify the return type (or <code>void</code> if the function does not return anything), the function name and a pair of parentheses. This function prints a welcome message in the screen:</p> <pre><code>public static void welcome()\n{\n    System.out.println(\"Hello, welcome to this program!\");\n}\n</code></pre> <p>We can call this function from any other function of the same class (including <code>main</code> function) by using the function name and the parentheses:</p> <pre><code>public static void main(String[] args)\n{\n    welcome();\n}\n</code></pre> <p>Note that function names always start in lower case in Java (in C#, they start in uppercase if they are public).</p>"},{"location":"04a.html#11-returning-values","title":"1.1. Returning values","text":"<p>Functions can return values. This values can be assigned to variables, or used in other expressions. In order to return a value from a function, its return type must be other than void, and we must use a <code>return</code> clause to specify the value returned. For instance, this function returns a welcome message:</p> <pre><code>public static string welcome()\n{\n    return \"Hello, welcome to this program!\";\n}\n</code></pre> <p>So, if we call this function from the main program, we will not see anything in the screen:</p> <pre><code>public static void main(String[] args)\n{\n    welcome();  // Nothing happens\n}\n</code></pre> <p>We need to assign the return value to a variable, or use it in another expression:</p> <pre><code>public static void main(String[] args)\n{\n    // Option 1\n    string result = welcome();\n    System.out.println(result);\n\n    // Option 2\n    System.out.println(welcome());\n}\n</code></pre>"},{"location":"04a.html#2-using-parameters","title":"2. Using parameters","text":"<p>Some functions need some additional data to do their job. These data can be passed to the function as parameters, some kind of variables that are specified within the parentheses, including the type of each parameter and its name. For instance:</p> <pre><code>public static void myOtherFunction (int a, String b)\n{\n    ...\n}\n</code></pre> <p>Then, whenever we need to call this function, we need to specify the values of these parameters, in the same order:</p> <pre><code>public static void main (String[] args)\n{\n    ...\n    myOtherFunction(3, \"Hello\");\n}\n</code></pre>"},{"location":"04a.html#21-parameters-by-value-or-by-reference","title":"2.1. Parameters by value or by reference","text":"<p>Passing a parameter by value means that we are passing a copy of the original value, so this original value can never be changed from within the function. This is the default situation for simple values, such as integers or floating point numbers:</p> <pre><code>public static void myFunction(int value)\n{\n    // This increment will have no effect after exiting the function\n    value = value + 1; \n    System.out.println(\"Inside function: \" + value);\n}\n\npublic static void main(String[] args)\n{\n    int number = 3;\n    myFunction(number);         // Inside function: 4\n    System.out.println(number); // 3\n}\n</code></pre> <p>However, complex data such as arrays are always passed by reference. This means that we are passing a reference or pointer to the original values, and we can change these values from within the function as long as we don't change the whole reference, this is, as long as we don't reassign the whole variable. Let's have a look at this example:</p> <pre><code>public static void myFunctionWithArray(int[] data)\n{\n    data[0] = 10;           // OK\n}\n\npublic static void myFunctionWithArray2(int[] data)\n{\n    data = {1, 2, 3, 4};    // No effect outside the function\n}\n\npublic static void main(String[] args)\n{\n    int[] numbers = {1, 1, 1, 1};\n    myFunctionWithArray(numbers);\n    // Here numbers = {10, 1, 1, 1}\n    myFunctionsWithArray2(numbers);\n    // Here numbers = {10, 1, 1, 1}\n}\n</code></pre> <p>The same happens with some other complex data, such as objects, as we will see in later units.</p>"},{"location":"04a.html#22-more-on-return-types","title":"2.2. More on return types","text":"<p>Let's have a look at this function. It returns the maximum value of its two input parameters:</p> <pre><code>public static int maximum(int n1, int n2)\n{\n    if (n1 &gt; n2)\n    {\n        return n1;\n    }\n    else\n    {\n        return n2;\n    }\n}\n</code></pre> <p>From the point of view of clean code, a function should only have ONE return point, so that it's easy for us to find out where this function ends. In order to meet this requirement, we can rewrite the function this way:</p> <pre><code>public static int maximum(int n1, int n2)\n{\n    int result = n1;\n    if (n2 &gt; n1)\n    {\n        result = n2;\n    }\n\n    return result;\n}\n</code></pre>"},{"location":"04a.html#23-global-and-local-variables","title":"2.3. Global and local variables","text":"<p>A global variable is a variable that has been defined outside of any function (and inside a class), so that it can be shared among all the functions of this class (and possibly other classes). In order for a variable to be global, we should declare it as public and static for now:</p> <pre><code>class MyClass\n{\n    public static int myGlobalVariable;\n\n    ...\n}\n</code></pre> <p>A local variable is a variable that has been defined inside a function, and it does not exist outside this function:</p> <pre><code>class MyClass\n{\n    public static void aFunction()\n    {\n        int number = 3;\n        anotherFunction();\n    }\n\n    public static void anotherFunction()\n    {\n        System.out.println(number); // Error: number does not exist here\n    }\n}\n</code></pre> <p>Global variables are not a good choice, generally, since they can produce side effects. This is, we can accidentally change their values from any function of our program. The most recommended way of dealing with variables is to declare them as local, and pass them to other functions as parameters:</p> <pre><code>class MyClass\n{\n    public static void aFunction()\n    {\n        int number = 3;\n        anotherFunction(number);\n    }\n\n    public static void anotherFunction(int n)\n    {\n        System.out.println(n); // OK\n    }\n}\n</code></pre> <p>Exercise 1</p> <p>Create a program called Palindrome with a function called <code>isPalindrome</code>. This function will take a string as a parameter and return a boolean indicating if this string is a palindrome (this is, a string that can be read the same backward as forward, ignoring upper or lower case, and whitespaces). Test this function from the main function with the texts Hannah, Too hot to hoot and Java is the best language (this last text is NOT a palindrome).</p> <p>Exercise 2</p> <p>Create a program called CountOcurrences with a function called <code>countString</code>. This function will take two strings a and b, and an integer n as parameters, and it will return a boolean indicating if the string b is contained at least n times in the main string a. Try it from the main function with the main string a = <code>This string is just a sample string</code>, the substring b = <code>string</code> and the number n = 2 (it should return <code>true</code>).</p>"},{"location":"04a.html#3-recursion","title":"3. Recursion","text":"<p>Recursion is the ability of a function to solve a task by calling itself multiple times with simpler versions of the problem to be solved.</p>"},{"location":"04a.html#31-main-components-of-a-recursive-function","title":"3.1. Main components of a recursive function","text":"<p>In every recursive function we can find two components:</p> <ul> <li>Base case: the simplest problem that we can find, in which recursive calls finish. There can be more than one base case in a recursive function, but there must be at least one of them.</li> <li>Recursive case: every internal call to the same function with a simpler version of the problem.</li> </ul> <p>So, whenever we try to solve a problem recursively, we need to think about the simplest value of this problem, and make the function tend to this simplest value through consecutive calls.</p>"},{"location":"04a.html#32-some-introductory-examples","title":"3.2. Some introductory examples","text":"<p>Let's get started with recursion by analyzing some simple examples...</p>"},{"location":"04a.html#321-the-factorial","title":"3.2.1. The factorial","text":"<p>Factorial is a mathematical operation that consists in multiplying a number by all its descending sequence up to 1. For instance factorial of number 5 can be calculated as 5 * 4 * 3 * 2 * 1, and it's represented as 5!.</p> <p>We can see the factorial as a simple multiplication sequence, or as a recursive expression: the factorial of a given number can be decomposed in two parts: the number itself and the factorial of the previous number. So, factorial of number 5 can be seen as 5 multiplied by the factorial of number 4:</p> <pre><code>5 * 4 * 3 * 2 * 1 = 5 * 4!\n</code></pre> <p>Recursively, we can also calculate the factorials of all the subsequent numbers:</p> <pre><code>4! = 4 * 3!\n3! = 3 * 2!\n2! = 2 * 1!\n1! = 1\n</code></pre> <p>As soon as we get to number 1, we've found our base case, the simplest number to calculate the factorial. After this point is reached, we can go back and calculate the rest of pending operations:</p> <pre><code>1! = 1\n2! = 2 * 1 = 2\n3! = 3 * 2 = 6\n4! = 4 * 6 = 24\n5! = 5 * 24 = 120\n</code></pre> <p>We can represent this as a recursive function in Java, this way:</p> <pre><code>public static int factorial(int number)\n{\n    // Base case\n    if (number == 1)\n    {\n        return 1;\n    }\n    // Recursive case\n    else\n    {\n        return number * factorial(number - 1);\n    }\n}\n</code></pre> <p>Alternatively, we can also express this operation as an iterative algorithm as well:</p> <pre><code>public static inf factorialIterative(int number)\n{\n    int result = 1;\n    for (int i = number; i &gt; 1; i--)\n    {\n        result = result * i;\n    }\n    return result;\n}\n</code></pre> <p>Note</p> <p>Recursive functions are an exception to the rule of a single return point. In recursive functions, we usually find a return point for the base case and another return point for the recursive case.</p>"},{"location":"04a.html#322-fibonacci-series","title":"3.2.2. Fibonacci series","text":"<p>Let's see another example. Fibonacci series starts with numbers 0 and 1, and then next number is always generated as the sum of two previous numbers. So, we have this sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21...</p> <p>How could we calculate the nth number of the Fibonacci series? We could define a function like this:</p> <pre><code>public static int fibonacci(int n)\n{\n    int previous, previous2, result;\n\n    if (n == 0)\n    {\n        result = 0;\n    }\n    else if (n == 1)\n    {\n        result = 1;\n    }\n    else\n    {\n        previous2 = 0;\n        previous = 1;\n        for (int i = 2; i &lt;= n; i++)\n        {\n            result = previous + previous2;\n            previous2 = previous;\n            previous = result;\n        }\n    }\n\n    return result;\n}\n</code></pre> <p>However, if we represent this function recursively, we can get this:</p> <pre><code>public static int fibonacci(int n)\n{\n    if (n == 0 || n == 1)\n    {\n        return n;\n    }\n    else\n    {\n        return fibonacci(n-1) + fibonacci(n-2);\n    }\n}\n</code></pre> <p>So, in some situations, recursion helps us write a shorter code to solve a problem.</p> <p>Exercise 3</p> <p>Create a program called CountDigits with a function called <code>countDigits</code> that receives a number and, recursively, counts the number of digit that this number has. Try it with number 1252 (4 digits), from the main function.</p> <p>Exercise 4</p> <p>Create a program called PalindromeRecursive with a function called <code>isPalindrome</code> that receives a string (with only alphabetical letters from a to z in lower case) and recursively determines if this string is palindrome or not, returning a boolean with the result. Try it with the same input values suggested for Exercise 1.</p>"},{"location":"04a.html#4-using-main-arguments","title":"4. Using main arguments","text":"<p>As you may have noticed, main function has a String array as parameter:</p> <pre><code>public static void main(String[] args)\n{\n    ...\n}\n</code></pre> <p>This means that we can pass as many arguments as we need to this main function from the command line. The first argument will be placed at index 0, the second argument at index 1 and so on.</p> <pre><code>public static void main(String[] args)\n{\n    if (args.length &gt; 0)\n        System.out.println(\"Received \" + args.length + \" args.\");\n}\n</code></pre> <p>For instance, if we try to run a program called Main with this command line:</p> <pre><code>java Main Nacho 20\n</code></pre> <p>Then <code>args[0]</code> will be Nacho and <code>args[1]</code> will be 20.</p> <p>Exercise 5</p> <p>Repeat exercise 3 in another program called CountDigitsMain in which the number to be checked will be passed from the command line.</p>"},{"location":"04b.html","title":"Useful Java functions","text":"<p>In this document we are going to learn some useful functions provided by Java core, that we can use in our programs.</p>"},{"location":"04b.html#1-math-functions","title":"1. Math functions","text":"<p><code>Math</code> element from Java JDK provides a set of useful functions to do some mathematical operations. Here you can see some of the most useful ones:</p> <ul> <li><code>Math.sqrt(n)</code> returns the square root of the parameter n provided. It returns a <code>double</code> value.</li> <li><code>Math.pow(b, e)</code> returns the value of the first argument b raised to the power of the second argument e. It also returns a <code>double</code> value.</li> <li><code>Math.abs(n)</code> returns the absolute value of the number n, in the same data type of n.</li> <li><code>Math.log(n)</code> returns the natural logarithm (base e) of a double value.</li> <li>...</li> </ul> <p>You can check all the functions available in the official documentation of this element.</p> <p>Exercise 1</p> <p>Create a program called Equation.java that tries to solve a 2nd degree equation ax^2 + bx + c = 0, given the values of a, b and c. Here you can see the general formula:</p>"},{"location":"04b.html#2-generating-random-numbers","title":"2. Generating random numbers","text":"<p>Random numbers are really useful in some particular kind of programs, such as some simple games (lottery, bingo, board games...). We can generate them in Java in two different ways.</p>"},{"location":"04b.html#21-using-mathrandom","title":"2.1. Using Math.random","text":"<p>We can use <code>Math.random()</code> function. It returns a random double value between 0 and 1 (1 is not included). So we can use it to just generate a double value in this range:</p> <pre><code>double randomValue = Math.random();\n</code></pre> <p>If we want to generate a random number for a wider range, we can just multiply the result by this range, and even typecast the result. This code generates a random integer between 0 and 10 (excluding 10):</p> <pre><code>int randomValue = (int)(Math.random() * 10);\n</code></pre> <p>Finally, if we want to move the range to another interval, we just need to sum or substract an initial value. This example generates a number between 20 and 30 (excluding 30):</p> <pre><code>int randomValue = 20 + (int)(Math.random() * 10);\n</code></pre>"},{"location":"04b.html#22-using-random","title":"2.2. Using Random","text":"<p>Alternatively, we can use <code>Random</code> data type to generate random values. First of all, we need to import this class (<code>java.util.Random</code>). Then, we need to initialize a Random variable (this step must be done only ONCE in the program execution), and then we can generate as many random values as we need. To do this, we can use methods such as <code>nextInt</code> inside the random variable, defining the interval for the number to be generated.</p> <p>This example generates a random number between 0 and 5 (5 is not included):</p> <pre><code>import java.util.Random;\n...\nRandom r = new Random();\nint randomValue = r.nextInt(5);\n</code></pre> <p>This example generates a random integer between 10 and 20 (20 is not included):</p> <pre><code>import java.util.Random;\n...\nRandom r = new Random();\nint randomValue = 10 + r.nextInt(10);\n</code></pre> <p>You can learn more about Random elementos in the official API.</p> <p>Exercise 2</p> <p>Create a program called NumberGuess.java that generates a random number between 1 and 50 (both included) and give the user 5 attempts to guess the number. After each attempt, the program must inform the user if the secret number is greater or lower than the one specified by the user.</p>"},{"location":"04c.html","title":"Exception management","text":"<p>Along the development of a Java program we can find two types of errors: compilation errors and runtime errors. The first ones are detected by the compiler as we type the code, whereas runtime errors are difficult to predict (in general): network errors, dividing by zero, file not found... Most of these runtime errors can be handled by exceptions.</p>"},{"location":"04c.html#1-what-is-an-exception","title":"1. What is an exception?","text":"<p>An exception is an event that happens during the execution of a program and makes it exit from its normal instruction flow. This way, we can deal with the error in a smart way, by separating the \"normal\" code from the error itself. Whenever an exception occurs, we say that it has been thrown, and we can choose among propagating it (throwing it again) or catching it and process the error. We will see these two options in a few minutes.</p>"},{"location":"04c.html#11-exception-types","title":"1.1. Exception types","text":"<p>Runtime errors can be of two main types:</p> <ul> <li>Errors: in this case, we talk about fatal errors that happen during the execution of a program, such as hardware errors, memory errors... These errors can't be managed from within a Java application.</li> <li>Exceptions: they are non-critical errors that can be managed (files not found, parsing errors...). Inside this type of errors, we can talk about:<ul> <li>Runtime exceptions: they don't need to be catched, and they are difficult to predict, in general. For instance, assigning null to a variable, or going beyond the boundaries of an array.</li> <li>Checked exceptions: these exceptions need to be catched, or declared to be thrown. In other words, if we use a function that can throw these type of exceptions, the compiler will complain if we don't catch the exception or throw it again. For instance, whenever we call the <code>Thread.sleep</code> instruction, we need to catch or throw an <code>InterruptedException</code>.</li> </ul> </li> </ul> <p>However, every type of exception is a subtype of the <code>Exception</code> main type. This generic type stores the error message produced by the exception. There are some other subtypes that store more specific information. For instance, <code>ParseException</code> is a subtype of <code>Exception</code> that is thrown whenever data can't be properly parsed. It stores the error message along with the position where the error was found.</p>"},{"location":"04c.html#12-types-of-exception-management","title":"1.2. Types of exception management","text":"<p>Whenever an exception is caused in a program, we can decide how to treat it. Basically, we have two options in our code:</p> <ul> <li>Catch the exception. This means that exception is \"destroyed\" and we can show a controlled, customized error message instead.</li> <li>Throw the exception. In this case, we don't want to care about the exception, and we delegate in another piece of code to treat it.</li> </ul> <p>In next sections of this document we will learn how to manage these two options.</p>"},{"location":"04c.html#2-catching-exceptions","title":"2. Catching exceptions","text":"<p>Whenever a piece of code can throw an exception, we can catch it by using a <code>try..catch</code> block. We put inside the <code>try</code> clause the code of our program that may produce an exception, and we use the <code>catch</code> clause to respond to the specified error. We can just output an error message, or return a given value, among other possible options.</p> <p>This example tries to convert a string into an integer value. If the conversion can't be done because the input is not valid, then a <code>NumberFormatException</code> will be thrown, and we can produce an appropriate error message in the <code>catch</code> clause.</p> <pre><code>int number;\nstring text = ... // Whatever value\n\ntry\n{\n    number = Integer.parseInt(text);\n} catch (NumberFormatException e) {\n    System.err.println(\"Error parsing text: \" + e.getMessage());\n}\n</code></pre> <p>The <code>getMessage</code> method gets the error message produced by the exception. See that we are using <code>System.err</code> instead of <code>System.in</code> because we are printing an error, and then we should use the default error output instead of the default \"normal\" output.</p> <p>We can also use <code>printStackTrace</code> method to print a complete stack trace of the error, so that we can see the call stack that have produced the error (this is, methods that have been called until the error was produced).</p> <pre><code>int number;\nstring text = ... // Whatever value\n\ntry\n{\n    number = Integer.parseInt(text);\n} catch (NumberFormatException e) {\n    e.printStackTrace();\n}\n</code></pre> <p>We can add as many <code>catch</code> clauses as we need, and each one can represent a specific exception type:</p> <pre><code>try\n{\n    // Code that may fail\n} catch (NumberFormatException e1) {\n    // Error message for number format\n} catch (ArithmeticException e2) {\n    // Error message for dividing by zero\n...\n} catch (Exception eN) {\n    // Error message for any other error\n}\n</code></pre> <p>However, we must put these <code>catch</code> clauses in order, so that the most generic ones are placed at the end, because the program will enter at the first <code>catch</code> clause that matches the exception produced. In other words, if we put the <code>catch(Exception)</code> clause at the beginning, the rest of clauses will have no effect, since any of them are subtypes of <code>Exception</code> and thus, they will be catched by the first clause.</p> <p>There are some instructions that force us to deal with a specific type of exception. For instance, if we call <code>Thread.sleep</code> instruction, the compiler will ask us to deal with an <code>InterruptedException</code>. We can do it this way:</p> <pre><code>try\n{\n    Thread.sleep(5000);\n} catch (InterruptedException e) {\n    System.err.println(\"Interruption during sleep: \" + e.getMessage());\n}\n</code></pre> <p>However, we can also use a generic <code>Exception</code> element in the <code>catch</code> clause to deal with any type of exception. We only need to specify concrete types of exceptions if we want to manage different <code>catch</code> clauses, and then, produce different error messages depending on the exception produced.</p>"},{"location":"04c.html#3-throwing-exceptions","title":"3. Throwing exceptions","text":"<p>The second way of managing an exception is throwing it. This way, we pass it to the next function in the stack call... until we reach the main function (in this function we should no longer throw exceptions, we must catch them). </p> <p>For instance, this function receives two numbers and returns the division n1 / n2. But if n2 is 0, we can't divide them, so in this case we can throw a new exception to indicate that data is not correct:</p> <pre><code>public static int divide (int n1, int n2)\n{\n    if (n2 == 0)\n        throw new ArithmeticException(\"Can't divide by zero\");\n    else\n        return n1 / n2;\n}\n</code></pre> <p>So, if we try to use this method in our program, we must be aware that an exception can be thrown, and catch it:</p> <pre><code>public static void anotherFunction()\n{\n    int number1, number2;\n\n    // ... Ask user to fill number1 and number2\n\n    try\n    {\n        int result = divide(number1, number2);\n    }\n    catch (ArithmeticException e)\n    {\n        System.err.println(\"Error: \" + e.getMessage());\n    }\n}\n</code></pre> <p>Now, let's have a look at this example:</p> <pre><code>public static void a() throws InterruptedException\n{\n    throw new InterruptedException (\"Exception in a\");\n}\n\npublic static void b() throws InterruptedException\n{\n    a();\n}\n\npublic static void c() throws InterruptedException\n{\n    b();\n}\n\npublic static void d() throws InterruptedException\n{\n    c();\n}\n\npublic static void main(String[] args)\n{\n    try\n    {\n        d();\n    } catch (InterruptedException e) {\n        System.err.println(\"Exception: \" + e.getMessage());\n    }\n}\n</code></pre> <p>This example produces an <code>InterruptedException</code> in function <code>a</code> (we can produce exceptions by throwing new exception elements of any type). Then, as <code>b</code> function calls <code>a</code> function, it is asked to either catch the exception or throw it. By adding the <code>throws</code> clause in the function definition, we explicitly say that this function can throw <code>InterruptedException</code> exceptions. This chain goes on with functions <code>c</code> and <code>d</code>. Finally, main function calls function <code>d</code>, and as this function can throw InterruptedExceptions, we need to catch the possible exception in main.</p> <p>All this chain of exception throwing have been originated from <code>a</code> function, since it throws a checked exception that needs to be catched or thrown. If this function had thrown a runtime exception (such as <code>NullPointerException</code>), then none of the <code>throws</code> clauses would have been necessary, since it is a non checked exception. The example would have been like this:</p> <pre><code>public static void a()\n{\n    throw new NullPointerException (\"Null pointer exception in a\");\n}\n\npublic static void b()\n{\n    a();\n}\n\npublic static void c()\n{\n    b();\n}\n\npublic static void d()\n{\n    c();\n}\n\npublic static void main(String[] args)\n{\n    d();\n}\n</code></pre> <p>However, if we try to run this last example, a <code>NullPointerException</code> exception will be produced in our console. As this is a non checked exception, we don't need to catch it but, as soon as it is produced, we should, to avoid these huge error messages in the console as we run the program:</p> <pre><code>Exception in thread \"main\" java.lang.NullPointerException: \nNull pointer exception in a\n    at Pruebas.a(Pruebas.java:6)\n    at Pruebas.b(Pruebas.java:11)\n    at Pruebas.c(Pruebas.java:16)\n    at Pruebas.d(Pruebas.java:21)\n    at Pruebas.main(Pruebas.java:26)\n</code></pre> <p>We can even throw (or declare to be thrown) as many exception types as we want, separated by commas in the <code>throws</code> clause. Then, we will need to catch all of them sooner or later:</p> <pre><code>public static void multipleExceptionsFunction()\nthrows IOException, InterruptedException\n{\n    ...\n    if (...)\n        throw new IOException(\"IOException produced\");\n    ...\n    if (...)\n        throw new InterruptedException(\"Interrupted!!\");\n}\n\n...\n\npublic static void anotherFunction()\n{\n    try\n    {\n        multipleExceptionsFunction();\n    } catch (IOException e1) {\n        System.err.println(...);\n    } catch (InterruptedException e2) {\n        System.err.println(...);\n    }\n}\n</code></pre> <p>Exercise 1</p> <p>Create a program called CalculateDensity that asks the user to type a weight (in grams) and a volume (in liters). Then, the program must output the density, which is calculated by dividing weight / volume. The program must catch every type of possible exception: <code>NumberFormatException</code> and <code>ArithmeticException</code> whenever they can be thrown. You can only use <code>Scanner.nextLine</code> method to get the user input in this exercise.</p> <p>Exercise 2</p> <p>Create a program called WaitApp with a function called waitSeconds that will receive a number of seconds (integer) as a parameter. Internally, this function will call <code>Thread.sleep</code> method to pause the program the given number of seconds (this function works with milliseconds, so you must convert seconds to milliseconds when calling it). As the <code>sleep</code> method can throw an <code>InterruptedException</code> element, you will need to deal with it. In this case, you are asked to throw the exception from waitSeconds method, and catch it in the main method, that will call waitSeconds with the number of seconds specified as a main parameter (inside the <code>String[] args</code> parameter). After waiting the specified number of secods, the program will prompt a \"Finish\" message before exiting.</p>"}]}